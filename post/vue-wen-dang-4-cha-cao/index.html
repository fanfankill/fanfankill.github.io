<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="&lt;strong&gt;前端小白&lt;/strong&gt;">
<meta name="theme-color" content="#000">
<title> Vue文档4 插槽 | fanfan</title>
<link rel="shortcut icon" href="/favicon.ico?v=1628416967233">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content=" Vue文档4 插槽" />
  <meta name="keywords" content="vue" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>fanfan</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/hjqM1TBv9//" target="_self">
                  <i class="fa fa-globe"></i> JS
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="tag/SPTV9Qrgr/" target="_self">
                  <i class="fa fa-globe"></i> CSS
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="tag/RyHRU5tQB//" target="_self">
                  <i class="fa fa-globe"></i> 算法
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/KATkWfQKE//" target="_self">
                  <i class="fa fa-globe"></i> Http
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/YjLqWgkox//" target="_self">
                  <i class="fa fa-globe"></i> Vue
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">fanfan</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">52</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">8</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">8</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/fanfankill">
              <i class="fa fa-github-alt" title="github"></i>
            </a>
          
        
        
          
            <a class="social-img" href="#">
              <img src="\media\images\custom-array-imgSocials-1626669538893-socialImg.png" />
              <i class="fa fa-qq" title="QQ" ></i>
            </a>
          
        
      </div>
    </div>
  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%8F%92%E6%A7%BD">插槽</a></li>
<li><a href="#%E7%BC%96%E8%BE%91%E4%BD%9C%E7%94%A8%E5%9F%9F">编辑作用域</a></li>
<li><a href="#%E5%90%8E%E5%A4%87%E5%86%85%E5%AE%B9">后备内容</a></li>
<li><a href="#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">具名插槽</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">作用域插槽</a>
<ul>
<li><a href="#%E7%8B%AC%E5%8D%A0%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99%E8%AF%AD%E6%B3%95">独占默认插槽的缩写语法</a></li>
<li><a href="#%E8%A7%A3%E6%9E%84%E6%8F%92%E6%A7%BDprop">解构插槽Prop</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E6%8F%92%E6%A7%BD%E5%90%8D">动态插槽名</a></li>
<li><a href="#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99">具名插槽的缩写</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://fanfankill.github.io/post/vue-wen-dang-4-cha-cao/">
       Vue文档4 插槽
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2021-07-19 10:19:43">2021-07-19</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://fanfankill.github.io/tag/YjLqWgkox/">
        <span>vue</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>5<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>1026<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <h2 id="插槽">插槽</h2>
<p>合成组件  里面可以包括HTML片段，其他组件等</p>
<pre><code class="language-vue">&lt;navigation-link url=&quot;/profile&quot;&gt;
  Your Profile
&lt;/navigation-link&gt;
</code></pre>
<p>组件写法</p>
<pre><code class="language-vue">  v-bind:href=&quot;url&quot;
  class=&quot;nav-link&quot;
&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/a&gt;
</code></pre>
<br>
<h2 id="编辑作用域">编辑作用域</h2>
<p>插槽中使用数据</p>
<pre><code class="language-vue">&lt;navigation-link url=&quot;/profile&quot;&gt;
  Logged in as {{ user.name }}
&lt;/navigation-link&gt;
</code></pre>
<p>该插槽跟模板的其它地方一样可以访问相同的实例 property</p>
<p>而<strong>不能</strong>访问 <code>&lt;navigation-link&gt;</code> 的作用域，例如上面的 <code>url</code> 是访问不到的。</p>
<p><strong>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的</strong></p>
<br>
<h2 id="后备内容">后备内容</h2>
<p>等于默认渲染，它只会在没有提供内容的时候被渲染 ，例如在一个 <code>&lt;submit-button&gt;</code> 组件中</p>
<pre><code class="language-vue">&lt;button type=&quot;submit&quot;&gt;
  &lt;slot&gt;Submit&lt;/slot&gt;
&lt;/button&gt;
</code></pre>
<p>现在当我在一个父级组件中使用 <code>&lt;submit-button&gt;</code> 并且不提供任何插槽内容时：</p>
<p><code>&lt;submit-button&gt;&lt;/submit-button&gt;</code></p>
<p>后备内容“Submit”将会被渲染：</p>
<pre><code class="language-vue">&lt;button type=&quot;submit&quot;&gt;
  Submit
&lt;/button&gt;
</code></pre>
<p>但如果提供内容就会替代插槽里面的后备内容</p>
<pre><code class="language-vue">&lt;submit-button&gt;
  Save
&lt;/submit-button&gt;

</code></pre>
<br>
<h2 id="具名插槽">具名插槽</h2>
<p>有时我们需要多个插槽</p>
<p>有时我们需要多个插槽。例如对于一个带有如下模板的 <code>&lt;base-layout&gt;</code> 组件：</p>
<pre><code class="language-vue">&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;!-- 我们希望把页头放这里 --&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;!-- 我们希望把主要内容放这里 --&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;!-- 我们希望把页脚放这里 --&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<p><code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code></p>
<pre><code class="language-vue">&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<p>一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。</p>
<p>我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令</p>
<pre><code class="language-vue">&lt;base-layout&gt;  &lt;template v-slot:header&gt;    &lt;h1&gt;Here might be a page title&lt;/h1&gt;  &lt;/template&gt;  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;  &lt;p&gt;And another one.&lt;/p&gt;  &lt;template v-slot:footer&gt;    &lt;p&gt;Here's some contact info&lt;/p&gt;  &lt;/template&gt;&lt;/base-layout&gt;
</code></pre>
<p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 <code>v-slot</code> 的 <code>&lt;template&gt;</code> 中的内容都会被视为默认插槽的内容。</p>
<p><strong><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上</strong></p>
<br>
<h2 id="作用域插槽">作用域插槽</h2>
<p>因为从父级传来的值在插槽子级是不可以直接访问的</p>
<p>子</p>
<pre><code class="language-vue">&lt;span&gt;  &lt;slot&gt;{{ user.lastName }}&lt;/slot&gt;&lt;/span&gt;
</code></pre>
<p>父</p>
<pre><code class="language-vue">&lt;current-user&gt;  {{ user.firstName }}&lt;/current-user&gt;
</code></pre>
<p>所以用到了<strong>插槽 prop</strong></p>
<pre><code class="language-vue">&lt;span&gt;  &lt;slot v-bind:user=&quot;user&quot;&gt;    {{ user.lastName }}  &lt;/slot&gt;&lt;/span&gt;
</code></pre>
<p><code>v-slot</code> 来定义我们提供的插槽 prop 的名字</p>
<pre><code class="language-vue">&lt;current-user&gt;  &lt;template v-slot:default=&quot;slotProps&quot;&gt;    {{ slotProps.user.firstName }}  &lt;/template&gt;&lt;/current-user&gt;
</code></pre>
<h3 id="独占默认插槽的缩写语法">独占默认插槽的缩写语法</h3>
<p>当只有默认插槽时候可以简写</p>
<pre><code class="language-vue">&lt;current-user v-slot=&quot;slotProps&quot;&gt;  {{ slotProps.user.firstName }}&lt;/current-user&gt;
</code></pre>
<p>只要出现多个插槽，请始终为<em>所有的</em>插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法：</p>
<pre><code class="language-vue">&lt;current-user&gt;  &lt;template v-slot:default=&quot;slotProps&quot;&gt;    {{ slotProps.user.firstName }}  &lt;/template&gt;  &lt;template v-slot:other=&quot;otherSlotProps&quot;&gt;    ...  &lt;/template&gt;&lt;/current-user&gt;
</code></pre>
<h3 id="解构插槽prop">解构插槽Prop</h3>
<p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里：</p>
<p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E8%A7%A3%E6%9E%84%E5%AF%B9%E8%B1%A1">ES2015 解构</a>来传入具体的插槽 prop</p>
<pre><code class="language-vue">&lt;current-user v-slot=&quot;{ user }&quot;&gt;  {{ user.firstName }}&lt;/current-user&gt;
</code></pre>
<br>
<h2 id="动态插槽名">动态插槽名</h2>
<pre><code class="language-vue">&lt;base-layout&gt;  &lt;template v-slot:[dynamicSlotName]&gt;    ...  &lt;/template&gt;&lt;/base-layout&gt;
</code></pre>
<br>
<h2 id="具名插槽的缩写">具名插槽的缩写</h2>
<p>把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code></p>
<p>例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>'</p>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      fanfan
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://fanfankill.github.io/post/vue-wen-dang-4-cha-cao/" title=" Vue文档4 插槽">https://fanfankill.github.io/post/vue-wen-dang-4-cha-cao/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://fanfankill.github.io/tag/YjLqWgkox/"># vue</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="深浅拷贝" href="https://fanfankill.github.io/post/shen-qian-kao-bei/">深浅拷贝</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="深浅拷贝" href="https://fanfankill.github.io/post/shen-qian-kao-bei/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title=" Vue文档3 Prop" href="https://fanfankill.github.io/post/vue-wen-dang-3/"> Vue文档3 Prop</a>
        <a class="nav-mobile-next" title=" Vue文档3 Prop" href="https://fanfankill.github.io/post/vue-wen-dang-3/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <span id="busuanzi_container_site_pv">浏览数 <span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数 <span id="busuanzi_value_site_uv"></span> 人</span>
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> ©2019 | Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Hardworking
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
  <div class="bg-img">
    <img src="\media\images\custom-bgImg.jpg" />
  </div>
  
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.addEventListener('resize', function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, 'stop');
      jQuery.Velocity(viewport, 'stop');
      jQuery.Velocity(rightMotions, 'stop');
      if (open) {
        jQuery.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            jQuery.Velocity(rightMotions, transitionDir, {});
          }
        })
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        jQuery.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            jQuery.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch && faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  images.forEach(image => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'images';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  })
</script>

    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/shen-ru-zuo-yong-yu-lian/"" data-c="
          &lt;p&gt;&lt;strong&gt;什么是作⽤域链？&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function bar() {
console.log(myName)
}
function foo() {
var myName = &amp;quot;极客邦&amp;quot;
bar()
}
var myName = &amp;quot;极客时间&amp;quot;
foo()

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628416965516.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;作用域链&#34;&gt;作⽤域链&lt;/h2&gt;
&lt;p&gt;在每个执⾏上下⽂的变量环境中，都包含了⼀个外部引⽤，⽤来指向外部的执⾏上下⽂，我们把这个外 部引⽤称为outer。&lt;/p&gt;
&lt;p&gt;当⼀段代码使⽤了⼀个变量时，JavaScript引擎⾸先会在“当前的执⾏上下⽂”中查找该变量&lt;/p&gt;
&lt;p&gt;如果在当前的变量环境中没有查找到，那么JavaScript引擎会继 续在outer所指向的执⾏上下⽂中查找。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628416960694.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;bar函数和foo函数的outer都是指向全局上下⽂的&lt;/p&gt;
&lt;p&gt;JavaScript引擎会去全局执⾏上下⽂中查找。我们把这个查找的链条就称为&lt;strong&gt;作⽤域链&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;foo函数调⽤的bar函数，那为什 么bar函数的外部引⽤是全局执⾏上下⽂，⽽不是foo函数的执⾏上下⽂？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;foo和bar的上级作⽤域都是全局作⽤域（&lt;strong&gt;定义为函数的时候绝对，如果把bar定义在foo里面，那么bar的上级作用域就指向foo&lt;/strong&gt;），所以如果foo或者bar函数使⽤了⼀个它 们没有定义的变量，那么它们会到全局作⽤域去查找&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;词法作⽤域是代码阶段就决定好的，和函数是怎么调⽤的没有关系。&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;词法作用域&#34;&gt;词法作⽤域&lt;/h2&gt;
&lt;p&gt;词法作⽤域就是指作⽤域是由代码中函数声明的位置来决定的，所以词法作⽤域是静态的作⽤域，通过它就 能够预测代码在执⾏过程中如何查找标识符。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628416955034.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;词法作⽤域就是根据代码的位置来决定的，其中main函数包含了bar函数，bar函数中包 含了foo函数&lt;/p&gt;
&lt;p&gt;因为JavaScript作⽤域链是由词法作⽤域决定的，所以整个词法作⽤域链的顺序是：foo函数 作⽤域—&amp;gt;bar函数作⽤域—&amp;gt;main函数作⽤域—&amp;gt;全局作⽤域。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;闭包&#34;&gt;闭包&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;	  function foo() {
    var myName = &amp;quot;极客时间&amp;quot;
    let test1 = 1
    const test2 = 2
    var innerBar = {
      getName: function () {
        console.log(test1)
        return myName
      },
      setName: function (newName) {
        myName = newName
      }
    }
    return innerBar
  }

  var bar = foo()
  bar.setName(&amp;quot;极客邦&amp;quot;)
  bar.getName()
  console.log(bar.getName())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当执⾏到foo函数内部的return innerBar这⾏代码时调⽤栈的情况&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628416949439.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;根据词法作⽤域的规则，内部函数getName和setName总是可以访问它们的外部函数foo中的变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然foo函数已经执⾏结束，但是getName和setName函数依然可 以使⽤foo函数中的变量myName和test1&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628416943836.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;foo函数执⾏完成之后，其执⾏上下⽂从栈顶弹出了，但是由于返回的setName和 getName⽅法中使⽤了foo函数内部的变量myName和test1，所以这两个变量依然保存在内存中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内部函数 总是可以访问其外部函数中声明的变量，即使该外部函数已 经执⾏结束了，但是内部函数引⽤外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;闭包是怎么回收的&#34;&gt;闭包是怎么回收的&lt;/h2&gt;
&lt;p&gt;因为如果闭包使⽤不正确，会很容易造成&lt;strong&gt;内存泄漏&lt;/strong&gt;的&lt;/p&gt;
&lt;p&gt;如果引⽤闭包的函数是个局部变量，等函数销毁后，在下次JavaScript引擎执⾏垃圾回收时，判断闭包这块 内容如果已经不再被使⽤了，那么JavaScript引擎的垃圾回收器就会回收这块内存。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;思考题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var bar = {
myName:&amp;quot;time.geekbang.com&amp;quot;,
printName: function () {
console.log(myName)
}
}

function foo() {
let myName = &amp;quot;极客时间&amp;quot;
return bar.printName
}

let myName = &amp;quot;极客邦&amp;quot;
let _printName = foo()
_printName()
bar.printName()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印两次 &lt;strong&gt;极客邦&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bar 不是⼀个函数，因此 bar 当中的 &lt;strong&gt;printName 其实是⼀个全局声明的函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bar 当中的 myName 只 是对象的⼀个属性，也和 printName 没有联系，如果要产⽣联系，需要使⽤ this 关键字&lt;/p&gt;
&lt;p&gt;printName函数定义时的执⾏上下⽂是全局，所以会在全局词法环境和变量环境下找myName。&lt;/p&gt;
&lt;p&gt;foo 函数返回的 printName 是全局声明的函数，因此和 foo 当中定义的变量也没有任何联系，这个时 候 foo 函数返回 printName 并不会产⽣闭包&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
">深入作用域链</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/var-que-xian-yi-ji-wei-shi-me-yao-yin-let-he-const/"" data-c="
          &lt;h2 id=&#34;作用域scope&#34;&gt;作⽤域（scope）&lt;/h2&gt;
&lt;p&gt;作⽤域是指在程序中定义变量的区域，该位置决定了变量的⽣命周期。&lt;/p&gt;
&lt;p&gt;作⽤域就是变量与函数 的可访问范围，即作⽤域控制着变量和函数的可⻅性和⽣命周期。&lt;/p&gt;
&lt;p&gt;ES6之前，ES的作⽤域只有两种：&lt;strong&gt;全局作⽤域和函数作⽤域&lt;/strong&gt;，是不⽀持块级作⽤域的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局作⽤域&lt;/strong&gt;中的对象在代码中的任何地⽅都能访问，其⽣命周期伴随着⻚⾯的⽣命周期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数作⽤域&lt;/strong&gt;就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数 执⾏结束之后，函数内部定义的变量会被销毁。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;变量提升带来的问题&#34;&gt;变量提升带来的问题&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function foo(){
for (var i = 0; i &amp;lt; 7; i++) {
}
console.log(i);
}
foo()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;for&lt;/code&gt;循环对于var声明的变量是全局的，所以会一直存在，最后打印出7&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;可以避免这样的问题&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;javascript是如何支持块级作用域的&#34;&gt;JavaScript是如何⽀持块级作⽤域的&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function foo(){
var a = 1
let b = 2
{
let b = 3
var c = 4
let d = 5
console.log(a)
console.log(b)
}
console.log(b)
console.log(c)
console.log(d)
}
foo()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;let关键字是如何影响执⾏上下⽂的呢？&lt;/p&gt;
&lt;p&gt;第⼀步是编译并创建执⾏上下⽂&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628341839271.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当进⼊函数的作⽤域块时，作⽤域块中通过let声明的变量，会被存放在词法环境的⼀个 单独的区域中，这个区域中的变量并不影响作⽤域块外⾯的变量，⽐如在作⽤域外⾯声明了变量b，在该作 ⽤域块内部也声明了变量b，当执⾏到作⽤域内部时，它们都是独⽴的存在。&lt;/p&gt;
&lt;p&gt;在词法环境内部，维护了⼀个⼩型栈结构，栈底是函数最外层的变量，进⼊⼀个作⽤域块后，就会把 该作⽤域块内部的变量压到栈顶；&lt;/p&gt;
&lt;p&gt;当作⽤域执⾏完成之后，该作⽤域的信息就会从栈顶弹出，这就是词法环 境的结构。&lt;/p&gt;
&lt;p&gt;当执⾏到作⽤域块中的console.log(a)这⾏代码时，就需要在&lt;strong&gt;词法环境&lt;/strong&gt;和&lt;strong&gt;变量环境&lt;/strong&gt;中查找变 量a的值了&lt;/p&gt;
&lt;p&gt;沿着词法环境的栈顶向下查询，如果在&lt;strong&gt;词法环境&lt;/strong&gt;中的某个块中查找到了，就 直接返回给JavaScript引擎，如果没有查找到，那么继续在&lt;strong&gt;变量环境&lt;/strong&gt;中查找。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628341844493.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;思考题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let myname= &#39;极客时间&#39;
{
console.log(myname)
let myname= &#39;极客邦&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当不在块级作用域声明变量的时候，代码会正常执行&lt;/p&gt;
&lt;p&gt;当在块级作用域里面声明的时候，会因为let声明的变量在编译阶段会被加⼊执⾏上下⽂的词法环境，⽽且不会被提升到作⽤域的顶部而报错&lt;/p&gt;
">var缺陷以及为什么要引⼊let和const？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/dom-new/"" data-c="
          &lt;p&gt;DOM（文档对象模型）是针对 HTML 和 XML 文档的一个 API&lt;/p&gt;
&lt;p&gt;DOM 可以将任何 HTML 或 XML 文档描绘成一个由多层节点构成的结构。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素 称之为&lt;strong&gt;文档元素&lt;/strong&gt;，文档元素是文档的最外层元素&lt;/p&gt;
&lt;h2 id=&#34;node类型&#34;&gt;Node类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;JavaScript 中的所有节点类型都继承自 Node 类型，因此所有节点类型都共享着相同的基本属性和方法。&lt;/p&gt;
&lt;p&gt;每个节点都有一个 nodeType 属性，用于表明节点的类型。会以数值的方式打印出来&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Node.ELEMENT_NODE；&lt;/li&gt;
&lt;li&gt;Node.ATTRIBUTE_NODE；&lt;/li&gt;
&lt;li&gt;Node.TEXT_NODE；&lt;/li&gt;
&lt;li&gt;Node.CDATA_SECTION_NODE；&lt;/li&gt;
&lt;li&gt;Node.ENTITY_REFERENCE_NODE；&lt;/li&gt;
&lt;li&gt;Node.ENTITY_NODE；&lt;/li&gt;
&lt;li&gt;Node.PROCESSING_INSTRUCTION_NODE；&lt;/li&gt;
&lt;li&gt;Node.COMMENT_NODE；&lt;/li&gt;
&lt;li&gt;Node.DOCUMENT_NODE；&lt;/li&gt;
&lt;li&gt;Node.DOCUMENT_TYPE_NODE；&lt;/li&gt;
&lt;li&gt;Node.DOCUMENT_FRAGMENT_NODE；&lt;/li&gt;
&lt;li&gt;Node.NOTATION_NODE。&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;h3 id=&#34;nodename和-nodevalue属性&#34;&gt;&lt;code&gt;nodeName&lt;/code&gt;和 &lt;code&gt;nodeValue&lt;/code&gt;属性&lt;/h3&gt;
&lt;p&gt;对于元素节点，nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;节点关系&#34;&gt;节点关系&lt;/h3&gt;
&lt;p&gt;每个节点都有一个 &lt;strong&gt;&lt;code&gt;childNodes&lt;/code&gt;&lt;/strong&gt; 属性，其中保存着一个 NodeList 对象。&lt;/p&gt;
&lt;p&gt;NodeList 是一种类数组 对象，用于保存一组有序的节点，可以通过位置来访问这些节点。NodeList 是动态的，随节点变化变化。&lt;/p&gt;
&lt;p&gt;访问NodeList 对象可以通过方括号，也可以使用 item() 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var firstChild = someNode.childNodes[0]; 
var secondChild = someNode.childNodes.item(1); 
var count = someNode.childNodes.length; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对 arguments 对象使用 Array.prototype.slice()方法可以 将其转换为数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0);
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;每个节点都有一个 &lt;strong&gt;&lt;code&gt;parentNode&lt;/code&gt;&lt;/strong&gt; 属性，该属性指向文档树中的父节点。&lt;/p&gt;
&lt;p&gt;通过使用列表中每个节点的 &lt;strong&gt;&lt;code&gt;previousSibling&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code&gt;nextSibling&lt;/code&gt;&lt;/strong&gt; 属性，可以访问同一列表中的其他节点&lt;/p&gt;
&lt;p&gt;列表中第一个节点的 previousSibling 属性 值为 null，而列表中最后一个节点的 nextSibling 属性的值同样也为 null&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hasChildNodes()&lt;/code&gt;这个方法在节点包含一或多个子节点的情况下返回 true&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;操作节点&#34;&gt;操作节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;appendChild()&lt;/code&gt;用于向 childNodes 列表的末尾添加一个节点，更新完成后，appendChild() 返回新增的节点&lt;/p&gt;
&lt;p&gt;如果传入到 &lt;code&gt;appendChild()&lt;/code&gt;中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置 转移到新位置。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;insertBefore()&lt;/code&gt;接受两个参数：&lt;strong&gt;要插入的节点&lt;/strong&gt;和&lt;strong&gt;作为参照的节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;插入节点后，被插 入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。&lt;/p&gt;
&lt;p&gt;如果参照节点是 null，则 insertBefore()与 appendChild()执行相同的操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//插入后成为最后一个子节点
returnedNode = someNode.insertBefore(newNode, null); 
alert(newNode == someNode.lastChild); //true 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;replaceChild()&lt;/code&gt;接受的两个参数：&lt;strong&gt;要插入的节点&lt;/strong&gt;和&lt;strong&gt;要替换的节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要替换的节点将由这个 方法返回并从文档树中被移除，同时由要插入的节点占据其位置。&lt;strong&gt;被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//替换第一个子节点
var returnedNode = someNode.replaceChild(newNode, someNode.firstChild); 

//替换最后一个子节点
returnedNode = someNode.replaceChild(newNode, someNode.lastChild); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;removeChild()&lt;/code&gt;接受一个参数：&lt;strong&gt;要移除的节点&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//移除第一个子节点
var formerFirstChild = someNode.removeChild(someNode.firstChild); 

//移除最后一个子节点
var formerLastChild = someNode.removeChild(someNode.lastChild);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过 removeChild()移除的节点仍然为文档所有，只不过在 文档中已经没有了自己的位置&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;其他方法&#34;&gt;其他方法&lt;/h3&gt;
&lt;p&gt;有两个方法是所有类型的节点都有的&lt;/p&gt;
&lt;p&gt;第一个就是 &lt;strong&gt;&lt;code&gt;cloneNode()&lt;/code&gt;&lt;/strong&gt;，用于创建调用这个方法的节点 的一个完全相同的副本。&lt;/p&gt;
&lt;p&gt;cloneNode()方法接受一个布尔值参数，表示是否执行深复制。&lt;/p&gt;
&lt;p&gt;在参数为 true 的情况下，执行深复制，也就是&lt;strong&gt;复制节点及其整个子节点树&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;在参数为 false 的情况下，执行浅复制， 即&lt;strong&gt;只复制节点本身&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul&amp;gt; 
 &amp;lt;li&amp;gt;item 1&amp;lt;/li&amp;gt; 
 &amp;lt;li&amp;gt;item 2&amp;lt;/li&amp;gt; 
 &amp;lt;li&amp;gt;item 3&amp;lt;/li&amp;gt; 
&amp;lt;/ul&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var myList=document.getElementsByTagName(&#39;ul&#39;)[0]

//深复制 复制了ul自己下面的所有子节点
var deepList = myList.cloneNode(true); 
alert(deepList.childNodes.length);

//浅复制 只复制ul一个本身元素 子节点没有复制
var shallowList = myList.cloneNode(false); 
alert(shallowList.childNodes.length); //0 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;第二个方法是**&lt;code&gt;normalize()&lt;/code&gt;**，这个方法唯一的作用就是处理文档树中的文本节点&lt;/p&gt;
&lt;p&gt;如果找到了 空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;document类型&#34;&gt;Document类型&lt;/h3&gt;
&lt;p&gt;document 对象是 HTMLDocument（继承 自 Document 类型）的一个实例，表示整个 HTML 页面。&lt;/p&gt;
&lt;p&gt;document 对象是 window 对象的一个 属性，因此可以将其作为全局对象来访问。&lt;/p&gt;
&lt;h3 id=&#34;文档的子节点&#34;&gt;文档的子节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;document.documentElement&lt;/code&gt;  取得对&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;的引用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;document.body&lt;/code&gt; 取得对&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;的引用&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;文档信息&#34;&gt;文档信息&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//取得文档标题
var originalTitle = document.title; 

//设置文档标题
document.title = &amp;quot;New page title&amp;quot;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;URL&lt;/code&gt;、&lt;code&gt;domain&lt;/code&gt;和 &lt;code&gt;referrer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;URL&lt;/code&gt;属性 中包含页面完整的 URL&lt;/p&gt;
&lt;p&gt;&lt;code&gt;domain&lt;/code&gt; 属性中只包含页面的域名&lt;/p&gt;
&lt;p&gt;&lt;code&gt;referrer&lt;/code&gt;属性中则保存着链接到当前页面的那个页面的 URL。&lt;/p&gt;
&lt;p&gt;在没有来源页面的情况下，referrer 属性中可能 会包含空字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//取得完整的 URL
var url = document.URL; 

//取得域名
var domain = document.domain; 

//取得来源页面的 URL
var referrer = document.referrer; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h3 id=&#34;查找元素&#34;&gt;查找元素&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;getElementById()&lt;/code&gt;  ID属性&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getElementsByTagName()&lt;/code&gt;   标签名字  NodeName&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getElementsByName()&lt;/code&gt;   name属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul&amp;gt; 
 &amp;lt;li&amp;gt;&amp;lt;input type=&amp;quot;radio&amp;quot; value=&amp;quot;red&amp;quot; name=&amp;quot;color&amp;quot; id=&amp;quot;colorRed&amp;quot;&amp;gt; 
 &amp;lt;label for=&amp;quot;colorRed&amp;quot;&amp;gt;Red&amp;lt;/label&amp;gt;&amp;lt;/li&amp;gt; 
 &amp;lt;li&amp;gt;&amp;lt;input type=&amp;quot;radio&amp;quot; value=&amp;quot;green&amp;quot; name=&amp;quot;color&amp;quot; id=&amp;quot;colorGreen&amp;quot;&amp;gt; 
 &amp;lt;label for=&amp;quot;colorGreen&amp;quot;&amp;gt;Green&amp;lt;/label&amp;gt;&amp;lt;/li&amp;gt; 
 &amp;lt;li&amp;gt;&amp;lt;input type=&amp;quot;radio&amp;quot; value=&amp;quot;blue&amp;quot; name=&amp;quot;color&amp;quot; id=&amp;quot;colorBlue&amp;quot;&amp;gt; 
 &amp;lt;label for=&amp;quot;colorBlue&amp;quot;&amp;gt;Blue&amp;lt;/label&amp;gt;&amp;lt;/li&amp;gt; 
 &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ID 的 作用在于将元素应用到每个单选按钮，&lt;strong&gt;而 name 特性则用以确保三个值中只有一个被发送给浏览器&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;特殊集合&#34;&gt;特殊集合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;document.anchors，包含文档中所有带 name 特性的元素；&lt;/li&gt;
&lt;li&gt;document.applets，包含文档中所有的元素，因为不再推荐使用元素， 所以这个集合已经不建议使用了；&lt;/li&gt;
&lt;li&gt;document.forms，包含文档中所有的元素，与 document.getElementsByTagName(&amp;quot;form&amp;quot;) 得到的结果相同；&lt;/li&gt;
&lt;li&gt;document.images，包含文档中所有的&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;元素，与 document.getElementsByTagName  (&amp;quot;img&amp;quot;)得到的结果相同&lt;/li&gt;
&lt;li&gt;document.links，包含文档中所有带 href 特性的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;文档写入&#34;&gt;文档写入&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;write()&lt;/code&gt;、&lt;code&gt;writeln()&lt;/code&gt;、&lt;code&gt;open()&lt;/code&gt;和 &lt;code&gt;close()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;write()会原样写入，而 writeln()则会 在字符串的末尾添加一个换行符（\n）&lt;/p&gt;
&lt;p&gt;open()和 close()分别用于打开和关闭网页的输出流。&lt;/p&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h2 id=&#34;element类型&#34;&gt;Element类型&lt;/h2&gt;
&lt;p&gt;Element 类型就要算是 Web 编程中最常用的类型了。&lt;/p&gt;
&lt;p&gt;Element 类型用 于表现 XML 或 HTML元素，提供了对元素标签名、子节点及特性的访问。&lt;/p&gt;
&lt;p&gt;也可以用tagName来获取标签名称&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;myDiv&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var div = document.getElementById(&amp;quot;myDiv&amp;quot;); 
alert(div.tagName); //&amp;quot;DIV&amp;quot; 
alert(div.tagName == div.nodeName); //true 


if (element.tagName == &amp;quot;div&amp;quot;){ //不能这样比较，很容易出错！
 //在此执行某些操作
} 

if (element.tagName.toLowerCase() == &amp;quot;div&amp;quot;){ //这样最好（适用于任何文档）
 //在此执行某些操作
}

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;html元素&#34;&gt;HTML元素&lt;/h3&gt;
&lt;p&gt;这些属性分别对应于每个 HTML 元素中都存在的下列标准特性。、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id，元素在文档中的唯一标识符。&lt;/li&gt;
&lt;li&gt;title，有关元素的附加说明信息，一般通过工具提示条显示出来。&lt;/li&gt;
&lt;li&gt;lang，元素内容的语言代码，很少使用。&lt;/li&gt;
&lt;li&gt;dir，语言的方向，值为&amp;quot;ltr&amp;quot;（left-to-right，从左至右）或&amp;quot;rtl&amp;quot;（right-to-left，从右至左）， 也很少使用。&lt;/li&gt;
&lt;li&gt;className，与元素的class 特性对应，即为元素指定的CSS类。没有将这个属性命名为class， 是因为 class 是 ECMAScript 的保留字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;myDiv&amp;quot; class=&amp;quot;bd&amp;quot; title=&amp;quot;Body text&amp;quot; lang=&amp;quot;en&amp;quot; dir=&amp;quot;ltr&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取上面元素的信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var div = document.getElementById(&amp;quot;myDiv&amp;quot;); 

//获取值
alert(div.id); //&amp;quot;myDiv&amp;quot;&amp;quot; 
alert(div.className); //&amp;quot;bd&amp;quot; 
alert(div.title); //&amp;quot;Body text&amp;quot; 
alert(div.lang); //&amp;quot;en&amp;quot; 
alert(div.dir); //&amp;quot;ltr&amp;quot; 

//设置值
div.id = &amp;quot;someOtherId&amp;quot;; 
div.className = &amp;quot;ft&amp;quot;; 
div.title = &amp;quot;Some other text&amp;quot;; 
div.lang = &amp;quot;fr&amp;quot;; 
div.dir =&amp;quot;rtl&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;获取特征&#34;&gt;获取特征&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;getAttribute()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因为 id 和 align 在 HTML 中是的公认特性&lt;/p&gt;
&lt;p&gt;自定义特性无法直接通过对象身上属性获取&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;myDiv&amp;quot; align=&amp;quot;left&amp;quot; my_special_attribute=&amp;quot;hello!&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(div.id); //&amp;quot;myDiv&amp;quot; 
alert(div.my_special_attribute); //undefined
alert(div.align); //&amp;quot;left&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也不能这样为DOM元素添加一个自定义属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;div.mycolor = &amp;quot;red&amp;quot;; 
alert(div.getAttribute(&amp;quot;mycolor&amp;quot;)); //null
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var div = document.getElementById(&amp;quot;myDiv&amp;quot;); 

//getAttribute 
alert(div.getAttribute(&amp;quot;id&amp;quot;)); //&amp;quot;myDiv&amp;quot; 
alert(div.getAttribute(&amp;quot;class&amp;quot;)); //&amp;quot;bd&amp;quot;
alert(div.getAttribute(&amp;quot;my_special_attribute&amp;quot;)) //&amp;quot;hello
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;设置特性&#34;&gt;设置特性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;setAttribute()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个方法接受两个参数：&lt;strong&gt;要设置的特性名&lt;/strong&gt;和 &lt;strong&gt;值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果特性已经存在，setAttribute()会以指定的值替换现有的值&lt;/p&gt;
&lt;p&gt;如果特性不存在，setAttribute() 则创建该属性并设置相应的值&lt;/p&gt;
&lt;p&gt;通过这个方法设置的 特性名会被统一转换为小写形式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;div.setAttribute(&amp;quot;id&amp;quot;, &amp;quot;someOtherId&amp;quot;); 
div.setAttribute(&amp;quot;class&amp;quot;, &amp;quot;ft&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;移除特性&#34;&gt;移除特性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;removeAttribute()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个方法用于彻底删除元素的特性。调用这个方 法不仅会清除特性的值，而且也会&lt;strong&gt;从元素中完全删除特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;div.removeAttribute(&amp;quot;class&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;attributes属性&#34;&gt;attributes属性&lt;/h3&gt;
&lt;p&gt;Element 类型是使用 attributes 属性的唯一一个 DOM 节点类型。&lt;/p&gt;
&lt;p&gt;元素的每一个特性都由一个 Attr 节 点表示，每个节点都保存在 NamedNodeMap 对象中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;getNamedItem(name)：返回 nodeName 属性等于 name 的节点；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;removeNamedItem(name)：从列表中移除 nodeName 属性等于 name 的节点；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;setNamedItem(node)：向列表中添加节点，以节点的 nodeName 属性为索引；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;item(pos)：返回位于数字 pos 位置处的节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;创建元素&#34;&gt;创建元素&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;document.createElement()&lt;/code&gt;可以创建新元素&lt;/p&gt;
&lt;p&gt;这个方法只接受一个参数：&lt;strong&gt;这个方法只接受一个参数&lt;/strong&gt;，这个方法只接受一个参数&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;元素的子节点&#34;&gt;元素的子节点&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var ul = document.getElementById(&amp;quot;myList&amp;quot;); 
var items = ul.getElementsByTagName(&amp;quot;li&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;的后代中只包含直接子元素。不过，&lt;strong&gt;如果它包含更多层次的后代元素，那 么各个层次中包含的&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;元素也都会返回&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;text类型&#34;&gt;Text类型&lt;/h2&gt;
&lt;p&gt;可以通过 nodeValue 属性或 data 属性访问 Text 节点中包含的文本，这两个属性中包含的值相同。&lt;/p&gt;
&lt;h3 id=&#34;创建文本节点&#34;&gt;创建文本节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;document.createTextNode()&lt;/code&gt;创建新文本节点&lt;/p&gt;
&lt;p&gt;接受一个参数：&lt;strong&gt;要插入节点 中的文本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;document.createTextNode(&amp;quot;Hello world!&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;规范化文本节点&#34;&gt;规范化文本节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;normalize()&lt;/code&gt; 能够将相邻文本节点合并的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var element = document.createElement(&amp;quot;div&amp;quot;); 

var textNode = document.createTextNode(&amp;quot;Hello world!&amp;quot;); 
element.appendChild(textNode); 

var anotherTextNode = document.createTextNode(&amp;quot;Yippee!&amp;quot;); 
element.appendChild(anotherTextNode); 

document.body.appendChild(element); 

//两个文本节点
alert(element.childNodes.length); //2 

element.normalize(); 

//合成为一个文本节点
alert(element.childNodes.length); //1 
alert(element.firstChild.nodeValue); // &amp;quot;Hello world!Yippee!&amp;quot; 

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;分割文本节点&#34;&gt;分割文本节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;splitText()&lt;/code&gt;按照指定的位置分割 nodeValue 值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var element = document.createElement(&amp;quot;div&amp;quot;); 
element.className = &amp;quot;message&amp;quot;; 

var textNode = document.createTextNode(&amp;quot;Hello world!&amp;quot;); 
element.appendChild(textNode); 

document.body.appendChild(element); 

var newNode = element.firstChild.splitText(5); 

alert(element.firstChild.nodeValue); //&amp;quot;Hello&amp;quot; 
alert(newNode.nodeValue); //&amp;quot; world!&amp;quot; 
alert(element.childNodes.length); //2 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;comment类型&#34;&gt;Comment类型&lt;/h2&gt;
&lt;p&gt;用于代码块加注释&lt;/p&gt;
&lt;p&gt;Comment 类型与 Text 类型继承自相同的基类，因此它拥有除 splitText()之外的所有字符串操 作方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;document.createComment()&lt;/code&gt;为其传递注释文本也可以创建注释节点&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;attr类型&#34;&gt;Attr类型&lt;/h2&gt;
&lt;p&gt;最常使用的是 &lt;code&gt;getAttribute()&lt;/code&gt;、&lt;code&gt;setAttribute()&lt;/code&gt;、&lt;code&gt;remveAttribute()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Attr 对象有 3 个属性：name、value 和 specified&lt;/p&gt;
&lt;p&gt;name 是特性名称（与 nodeName 的 值相同），value 是特性的值（与 nodeValue 的值相同），而 specified 是一个布尔值，用以区别特 性是在代码中指定的，还是默认的。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;document.createAttribute()&lt;/code&gt;并传入特性的名称可以创建新的特性节点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var attr = document.createAttribute(&amp;quot;align&amp;quot;); 
attr.value = &amp;quot;left&amp;quot;; 

element.setAttributeNode(attr); 

alert(element.attributes[&amp;quot;align&amp;quot;].value); //&amp;quot;left&amp;quot; 
alert(element.getAttributeNode(&amp;quot;align&amp;quot;).value); //&amp;quot;left&amp;quot; 
alert(element.getAttribute(&amp;quot;align&amp;quot;)); //&amp;quot;left&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
">DOM 节点层次</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/wei-shi-me-javascript-dai-ma-hui-chu-xian-zhan-yi-chu/"" data-c="
          &lt;p&gt;哪些情况下代码才算是“⼀段”代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 当JavaScript执⾏全局代码的时候，会编译全局代码并创建全局执⾏上下⽂，⽽且在整个⻚⾯的⽣存周期 内，全局执⾏上下⽂只有⼀份。
2. 当调⽤⼀个函数的时候，函数体内的代码会被编译，并创建函数执⾏上下⽂，⼀般情况下，函数执⾏结 束之后，创建的函数执⾏上下⽂会被销毁。
3.  当使⽤eval函数的时候，eval的代码也会被编译，并创建执⾏上下⽂。
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628256874452.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;那为什么会出现这种错误呢？这就涉及到了&lt;strong&gt;调⽤栈&lt;/strong&gt;的内容&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调⽤栈就是⽤来管理函数调⽤关系的⼀种数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;什么是函数调用&#34;&gt;什么是函数调⽤&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var a = 2
function add(){
var b = 10
return a+b
}
add()
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;⾸先，从全局执⾏上下⽂中，取出add函数代码。&lt;/li&gt;
&lt;li&gt;其次，对add函数的这段代码进⾏编译，并创建该函数的执⾏上下⽂和可执⾏代码。&lt;/li&gt;
&lt;li&gt;最后，执⾏代码，输出结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当执⾏到add函数的时候，我们就有了两个执⾏上下⽂了⸺全局执⾏上下⽂和add函数的执⾏上 下⽂。&lt;/p&gt;
&lt;p&gt;也就是说在执⾏JavaScript时，可能会存在多个执⾏上下⽂，那么JavaScript引擎是如何管理这些执⾏上下 ⽂的呢？&lt;/p&gt;
&lt;p&gt;答案是通过⼀种叫&lt;strong&gt;栈的数据结构来管理的&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;什么是栈&#34;&gt;什么是栈&lt;/h2&gt;
&lt;p&gt;栈中的元素满⾜&lt;strong&gt;后进先出&lt;/strong&gt;的特点&lt;/p&gt;
&lt;p&gt;JavaScript引擎正是利⽤栈的这种结构来管理执⾏上下⽂的。&lt;/p&gt;
&lt;p&gt;通常把这种⽤来管理执⾏上下⽂的栈称为执⾏上下⽂栈，⼜称&lt;strong&gt;调⽤栈&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调⽤栈是JavaScript引擎追踪函数执⾏的⼀个机制&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;栈溢出stack-overflow&#34;&gt;栈溢出（Stack Overflow）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;调⽤栈&lt;/strong&gt;是有⼤⼩的，当⼊栈的执⾏上下⽂超过⼀定数⽬，JavaScript引擎就会报错，我们把这种错误叫做&lt;strong&gt;栈溢出&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;特别是在你写递归代码的时候，就很容易出现栈溢出的情况。&lt;/p&gt;
&lt;p&gt;修改以下代码使其不会栈溢出&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function runStack (n) {
if (n === 0) return 100;
return runStack( n- 2);
}
runStack(50000)
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;尾递归解决&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function runStack (n, result=100) {
if (n === 0) return result;
return runStack( n- 2, result);
}
runStack(50000, 100)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者循环解决&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function runStack (n) {
    while(true)
        {
            if (n === 0) return 100;
            else if (n==1) return 100;
            else {
                n=n-2
            }
        } 


}

&lt;/code&gt;&lt;/pre&gt;
">为什么JavaScript代码会出现栈溢出？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/proxy/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程&lt;/p&gt;
&lt;p&gt;Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var obj = new Proxy({}, {
  get: function (target, propKey, receiver) {
    console.log(`getting ${propKey}!`);
    return Reflect.get(target, propKey, receiver);
  },
  set: function (target, propKey, value, receiver) {
    console.log(`setting ${propKey}!`);
    return Reflect.set(target, propKey, value, receiver);
  }
});


obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var proxy = new Proxy(target, handler);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Proxy 对象的所有用法，都是上面这种形式，不同的只是&lt;code&gt;handler&lt;/code&gt;参数的写法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;target&lt;/code&gt;参数表示所要拦截的目标对象，&lt;code&gt;handler&lt;/code&gt;参数也是一个对象，用来定制拦截行为&lt;/p&gt;
&lt;p&gt;Proxy 实例也可以作为其他对象的原型对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var proxy = new Proxy({}, {
  get: function(target, propKey) {
    return 35;
  }
});

let obj = Object.create(proxy);
obj.time // 35
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;proxy&lt;/code&gt;对象是&lt;code&gt;obj&lt;/code&gt;对象的原型，&lt;code&gt;obj&lt;/code&gt;对象本身并没有&lt;code&gt;time&lt;/code&gt;属性，所以根据原型链，会在&lt;code&gt;proxy&lt;/code&gt;对象上读取该属性，导致被拦截。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;下面是 Proxy 支持的拦截操作一览，一共 13 种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;get(target, propKey, receiver)&lt;/strong&gt;：拦截对象属性的读取，比如&lt;code&gt;proxy.foo&lt;/code&gt;和&lt;code&gt;proxy[&#39;foo&#39;]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;set(target, propKey, value, receiver)&lt;/strong&gt;：拦截对象属性的设置，比如&lt;code&gt;proxy.foo = v&lt;/code&gt;或&lt;code&gt;proxy[&#39;foo&#39;] = v&lt;/code&gt;，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;has(target, propKey)&lt;/strong&gt;：拦截&lt;code&gt;propKey in proxy&lt;/code&gt;的操作，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deleteProperty(target, propKey)&lt;/strong&gt;：拦截&lt;code&gt;delete proxy[propKey]&lt;/code&gt;的操作，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ownKeys(target)&lt;/strong&gt;：拦截&lt;code&gt;Object.getOwnPropertyNames(proxy)&lt;/code&gt;、&lt;code&gt;Object.getOwnPropertySymbols(proxy)&lt;/code&gt;、&lt;code&gt;Object.keys(proxy)&lt;/code&gt;、&lt;code&gt;for...in&lt;/code&gt;循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而&lt;code&gt;Object.keys()&lt;/code&gt;的返回结果仅包括目标对象自身的可遍历属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getOwnPropertyDescriptor(target, propKey)&lt;/strong&gt;：拦截&lt;code&gt;Object.getOwnPropertyDescriptor(proxy, propKey)&lt;/code&gt;，返回属性的描述对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;defineProperty(target, propKey, propDesc)&lt;/strong&gt;：拦截&lt;code&gt;Object.defineProperty(proxy, propKey, propDesc）&lt;/code&gt;、&lt;code&gt;Object.defineProperties(proxy, propDescs)&lt;/code&gt;，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;preventExtensions(target)&lt;/strong&gt;：拦截&lt;code&gt;Object.preventExtensions(proxy)&lt;/code&gt;，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getPrototypeOf(target)&lt;/strong&gt;：拦截&lt;code&gt;Object.getPrototypeOf(proxy)&lt;/code&gt;，返回一个对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;isExtensible(target)&lt;/strong&gt;：拦截&lt;code&gt;Object.isExtensible(proxy)&lt;/code&gt;，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;setPrototypeOf(target, proto)&lt;/strong&gt;：拦截&lt;code&gt;Object.setPrototypeOf(proxy, proto)&lt;/code&gt;，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;apply(target, object, args)&lt;/strong&gt;：拦截 Proxy 实例作为函数调用的操作，比如&lt;code&gt;proxy(...args)&lt;/code&gt;、&lt;code&gt;proxy.call(object, ...args)&lt;/code&gt;、&lt;code&gt;proxy.apply(...)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;construct(target, args)&lt;/strong&gt;：拦截 Proxy 实例作为构造函数调用的操作，比如&lt;code&gt;new proxy(...args)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var handler = {
  get: function(target, name) {
    if (name === &#39;prototype&#39;) {
      return Object.prototype;
    }
    return &#39;Hello, &#39; + name;
  },

  apply: function(target, thisBinding, args) {
    return args[0];
  },

  construct: function(target, args) {
    return {value: args[1]};
  }
};

var fproxy = new Proxy(function(x, y) {
  return x + y;
}, handler);

fproxy(1, 2) // 1     实例函数 拦截apply
new fproxy(1, 2) // {value: 2}  构造函数constructor
fproxy.prototype === Object.prototype // true
fproxy.foo === &amp;quot;Hello, foo&amp;quot; // true
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;proxy实例的方法&#34;&gt;Proxy实例的方法&lt;/h2&gt;
&lt;h3 id=&#34;get&#34;&gt;get()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;et&lt;/code&gt;方法用于拦截某个属性的读取操作，可以接受三个参数：&lt;strong&gt;目标对象&lt;/strong&gt;、&lt;strong&gt;属性名&lt;/strong&gt;和 &lt;strong&gt;proxy 实例本身&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var person = {
  name: &amp;quot;张三&amp;quot;
};

var proxy = new Proxy(person, {
  get: function(target, propKey) {
    if (propKey in target) {
      return target[propKey];
    } else {
      throw new ReferenceError(&amp;quot;Prop name \&amp;quot;&amp;quot; + propKey + &amp;quot;\&amp;quot; does not exist.&amp;quot;);
    }
  }
});

proxy.name // &amp;quot;张三&amp;quot;
proxy.age // 抛出一个错误
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;get&lt;/code&gt;方法可以继承。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let proto = new Proxy({}, {
  get(target, propertyKey, receiver) {
    console.log(&#39;GET &#39; + propertyKey);
    return target[propertyKey];
  }
});

let obj = Object.create(proto);
obj.foo // &amp;quot;GET foo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拦截操作定义在&lt;code&gt;Prototype&lt;/code&gt;对象上面，所以如果读取&lt;code&gt;obj&lt;/code&gt;对象继承的属性时，拦截会生效。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;利用&lt;code&gt;get&lt;/code&gt;拦截，实现一个生成各种 DOM 节点的通用函数&lt;code&gt;dom&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const dom = new Proxy({}, {
  get(target, property) {
    return function(attrs = {}, ...children) {
      const el = document.createElement(property);
        //添加属性
      for (let prop of Object.keys(attrs)) {
        el.setAttribute(prop, attrs[prop]);
      }
      for (let child of children) {
        if (typeof child === &#39;string&#39;) {
          child = document.createTextNode(child);
        }
        el.appendChild(child);
      }
      return el;
    }
  }
});

const el = dom.div({},
  &#39;Hello, my name is &#39;,
  dom.a({href: &#39;//example.com&#39;}, &#39;Mark&#39;),
  &#39;. I like:&#39;,
  dom.ul({},
    dom.li({}, &#39;The web&#39;),
    dom.li({}, &#39;Food&#39;),
    dom.li({}, &#39;…actually that\&#39;s it&#39;)
  )
);

document.body.appendChild(el);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628237451351.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;set&#34;&gt;set()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;set&lt;/code&gt;方法用来拦截某个属性的赋值操作，可以接受四个参数：&lt;strong&gt;目标对象&lt;/strong&gt;、&lt;strong&gt;属性名&lt;/strong&gt;、&lt;strong&gt;属性值&lt;/strong&gt;和 &lt;strong&gt;Proxy 实例本身&lt;/strong&gt;，其中最后一个参数可选&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let validator = {
  set: function(obj, prop, value) {
    if (prop === &#39;age&#39;) {
      if (!Number.isInteger(value)) {
        throw new TypeError(&#39;The age is not an integer&#39;);
      }
      if (value &amp;gt; 200) {
        throw new RangeError(&#39;The age seems invalid&#39;);
      }
    }

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
    return true;
  }
};

let person = new Proxy({}, validator);

person.age = 100;

person.age // 100
person.age = &#39;young&#39; // 报错
person.age = 300 // 报错
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;如果目标对象自身的某个属性不可写，那么&lt;code&gt;set&lt;/code&gt;方法将不起作用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const obj = {};
Object.defineProperty(obj, &#39;foo&#39;, {
  value: &#39;bar&#39;,
  writable: false
});

const handler = {
  set: function(obj, prop, value, receiver) {
    obj[prop] = &#39;baz&#39;;
    return true;
  }
};

const proxy = new Proxy(obj, handler);
proxy.foo = &#39;baz&#39;;
proxy.foo // &amp;quot;bar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;注意，&lt;code&gt;set&lt;/code&gt;代理应当返回一个布尔值。严格模式下，&lt;code&gt;set&lt;/code&gt;代理如果没有返回&lt;code&gt;true&lt;/code&gt;，就会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&#39;use strict&#39;;
const handler = {
  set: function(obj, prop, value, receiver) {
    obj[prop] = receiver;
    // 无论有没有下面这一行，都会报错
    return false;
  }
};
const proxy = new Proxy({}, handler);
proxy.foo = &#39;bar&#39;;
// TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;foo&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;apply&#34;&gt;apply()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;apply&lt;/code&gt;方法拦截函数的调用、&lt;code&gt;call&lt;/code&gt;和&lt;code&gt;apply&lt;/code&gt;操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;apply&lt;/code&gt;方法可以接受三个参数：分别是目标对象、目标对象的上下文对象（&lt;code&gt;this&lt;/code&gt;）和目标对象的参数数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var target = function () { return &#39;I am the target&#39;; };
var handler = {
  apply: function () {
    return &#39;I am the proxy&#39;;
  }
};

var p = new Proxy(target, handler);

p()
// &amp;quot;I am the proxy&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var twice = {
  apply (target, ctx, args) {
    return Reflect.apply(...arguments) * 2;
  }
};
function sum (left, right) {
  return left + right;
};
var proxy = new Proxy(sum, twice);
proxy(1, 2) // 6
proxy.call(null, 5, 6) // 22
proxy.apply(null, [7, 8]) // 30
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;reflect&#34;&gt;Reflect&lt;/h2&gt;
&lt;h3 id=&#34;概述-2&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Reflect&lt;/code&gt;对象与&lt;code&gt;Proxy&lt;/code&gt;对象一样，也是 ES6 为了操作对象而提供的新 API。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;静态方法&#34;&gt;静态方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Reflect&lt;/code&gt;对象一共有 13 个静态方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reflect.apply(target, thisArg, args)&lt;/li&gt;
&lt;li&gt;Reflect.construct(target, args)&lt;/li&gt;
&lt;li&gt;Reflect.get(target, name, receiver)&lt;/li&gt;
&lt;li&gt;Reflect.set(target, name, value, receiver)&lt;/li&gt;
&lt;li&gt;Reflect.defineProperty(target, name, desc)&lt;/li&gt;
&lt;li&gt;Reflect.deleteProperty(target, name)&lt;/li&gt;
&lt;li&gt;Reflect.has(target, name)&lt;/li&gt;
&lt;li&gt;Reflect.ownKeys(target)&lt;/li&gt;
&lt;li&gt;Reflect.isExtensible(target)&lt;/li&gt;
&lt;li&gt;Reflect.preventExtensions(target)&lt;/li&gt;
&lt;li&gt;Reflect.getOwnPropertyDescriptor(target, name)&lt;/li&gt;
&lt;li&gt;Reflect.getPrototypeOf(target)&lt;/li&gt;
&lt;li&gt;Reflect.setPrototypeOf(target, prototype)&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;reflectgettarget-name-receiver&#34;&gt;Reflect.get(target, name, receiver)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Reflect.get&lt;/code&gt;方法查找并返回&lt;code&gt;target&lt;/code&gt;对象的&lt;code&gt;name&lt;/code&gt;属性，如果没有该属性，则返回&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var myObject = {
  foo: 1,
  bar: 2,
  get baz() {
    return this.foo + this.bar;
  },
}

Reflect.get(myObject, &#39;foo&#39;) // 1
Reflect.get(myObject, &#39;bar&#39;) // 2
Reflect.get(myObject, &#39;baz&#39;) // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果&lt;code&gt;name&lt;/code&gt;属性部署了读取函数（getter），则读取函数的&lt;code&gt;this&lt;/code&gt;绑定&lt;code&gt;receiver&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var myObject = {
  foo: 1,
  bar: 2,
  get baz() {
    return this.foo + this.bar;
  },
};

var myReceiverObject = {
  foo: 4,
  bar: 4,
};

Reflect.get(myObject, &#39;baz&#39;, myReceiverObject) // 8
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;reflectsettarget-name-value-receiver&#34;&gt;Reflect.set(target, name, value, receiver)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Reflect.set&lt;/code&gt;方法设置&lt;code&gt;target&lt;/code&gt;对象的&lt;code&gt;name&lt;/code&gt;属性等于&lt;code&gt;value&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var myObject = {
  foo: 1,
  set bar(value) {
    return this.foo = value;
  },
}

myObject.foo // 1

Reflect.set(myObject, &#39;foo&#39;, 2);
myObject.foo // 2

Reflect.set(myObject, &#39;bar&#39;, 3)
myObject.foo // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果&lt;code&gt;name&lt;/code&gt;属性设置了赋值函数，则赋值函数的&lt;code&gt;this&lt;/code&gt;绑定&lt;code&gt;receiver&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var myObject = {
  foo: 4,
  set bar(value) {
    return this.foo = value;
  },
};

var myReceiverObject = {
  foo: 0,
};

Reflect.set(myObject, &#39;bar&#39;, 1, myReceiverObject);
myObject.foo // 4
myReceiverObject.foo // 1
&lt;/code&gt;&lt;/pre&gt;
">Proxy</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/bom/"" data-c="
          &lt;h2 id=&#34;window-对象&#34;&gt;window 对象&lt;/h2&gt;
&lt;p&gt;BOM 的核心对象是 window，&lt;/p&gt;
&lt;p&gt;在浏览器中，window 对象有双重角色， 它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;全局作用域&#34;&gt;全局作用域&lt;/h3&gt;
&lt;p&gt;window 对象同时扮演着 ECMAScript 中 Global 对象的角色，因此所有在全局作用域中声明 的变量、函数都会变成 window 对象的属性和方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var age = 29; 
function sayAge(){ 
 alert(this.age); 
} 

alert(window.age); //29 
sayAge(); //29 
window.sayAge(); //29
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于&lt;code&gt;sayAge()&lt;/code&gt;存在于全局作用域中，因此 this.age 被映射到 window.age&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;定义全局变量与在 window 对象上直接定义属性还 是有一点差别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var age = 29; 
window.color = &amp;quot;red&amp;quot;; 

//在 IE &amp;lt; 9 时抛出错误，在其他所有浏览器中都返回 false 
delete window.age; 

//在 IE &amp;lt; 9 时抛出错误，在其他所有浏览器中都返回 true 
delete window.color; //returns true 

alert(window.age); //29 
alert(window.color); //undefined 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为刚才使用 var 语句添加的 window 属性有一个名为[[Configurable]]的特性，这个特性的值被 设置为false，因此这样定义的属性不可以通过delete操作符删除。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;尝试访问未声明的变量会抛出错误，但是通过查询 window 对象，可以知 道某个可能未声明的变量是否存在&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//这里会抛出错误，因为 oldValue 未定义
var newValue = oldValue; 

//这里不会抛出错误，因为这是一次属性查询
//newValue 的值是 undefined 
var newValue = window.oldValue; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;窗口关系及框架&#34;&gt;窗口关系及框架&lt;/h3&gt;
&lt;p&gt;每个框架都拥有自己的 window 对象，并且保存在 frames 集合中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt; 
 &amp;lt;head&amp;gt; 
 &amp;lt;title&amp;gt;Frameset Example&amp;lt;/title&amp;gt; 
 &amp;lt;/head&amp;gt; 
 &amp;lt;frameset rows=&amp;quot;160,*&amp;quot;&amp;gt; 
 &amp;lt;frame src=&amp;quot;frame.htm&amp;quot; name=&amp;quot;topFrame&amp;quot;&amp;gt; 
 &amp;lt;frameset cols=&amp;quot;50%,50%&amp;quot;&amp;gt; 
 &amp;lt;frame src=&amp;quot;anotherframe.htm&amp;quot; name=&amp;quot;leftFrame&amp;quot;&amp;gt; 
 &amp;lt;frame src=&amp;quot;yetanotherframe.htm&amp;quot; name=&amp;quot;rightFrame&amp;quot;&amp;gt; 
 &amp;lt;/frameset&amp;gt; 
 &amp;lt;/frameset&amp;gt; 
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问框架方式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628146461601.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h3 id=&#34;窗口位置&#34;&gt;窗口位置&lt;/h3&gt;
&lt;p&gt;用来确定和修改 window 对象位置，IE、Safari、Opera 和 Chrome 都提供了 &lt;code&gt;screenLeft&lt;/code&gt;和 &lt;code&gt;screenTop&lt;/code&gt;属性，分别用于表示窗口相对于屏幕左边和上边的位置&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;窗口大小&#34;&gt;窗口大小&lt;/h3&gt;
&lt;p&gt;多个属性：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;innerWidth&lt;/code&gt;、&lt;code&gt;innerHeight&lt;/code&gt; 表示当前视窗（viewport）的宽度和高度&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;outerWidth&lt;/code&gt;、&lt;code&gt;outerHeight&lt;/code&gt;返回浏览器窗口本身的尺寸（无论是从最外层的 window 对象还是从 某个框架访问）&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;clientWidth&lt;/code&gt;、&lt;code&gt;clientHeight&lt;/code&gt; ：width+左右padding、height + 上下padding&lt;/p&gt;
&lt;p&gt;&lt;code&gt;clientTop&lt;/code&gt;：boder.top(上边框的宽度)&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;offsetWidth&lt;/code&gt; 、&lt;code&gt;offsetHeight&lt;/code&gt;：width + 左右padding + 左右boder、height + 上下padding +上下boder&lt;/p&gt;
&lt;p&gt;&lt;code&gt;offsetTop&lt;/code&gt; 当前元素 上边框 外边缘 到 最近的已定位父级（offsetParent） 上边框 内边缘的 距离&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;scrollWidth&lt;/code&gt;、&lt;code&gt;scrollHeight&lt;/code&gt;：width&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scrollTop&lt;/code&gt;：:内容层顶部 到 可视区域顶部的距离  (用的最多)&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;resizeTo()和 resizeBy()方法可以调整浏览器窗口的大小&lt;/p&gt;
&lt;p&gt;resizeTo()接收浏览器窗口的新宽度和新高度&lt;/p&gt;
&lt;p&gt;resizeBy()接收新窗口与原窗口的宽 度和高度之差&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//调整到 100×100 
window.resizeTo(100, 100); 

//调整到 200×150 
window.resizeBy(100, 50); 

//调整到 300×300 
window.resizeTo(300, 300); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;导航和打开窗口&#34;&gt;导航和打开窗口&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接收 4 个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览 器历史记录中当前加载页面的布尔值。&lt;/p&gt;
&lt;p&gt;如果第二个参数是已有窗口或框架的名称，那么就会在具 有该名称的窗口或框架中加载第一个参数指定的 URL。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//等同于&amp;lt; a href=&amp;quot;http://www.wrox.com&amp;quot; target=&amp;quot;topFrame&amp;quot;&amp;gt;&amp;lt;/a&amp;gt; 
window.open(&amp;quot;http://www.wrox.com/&amp;quot;, &amp;quot;topFrame&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;弹出窗口&#34;&gt;弹出窗口&lt;/h4&gt;
&lt;p&gt;如果给 window.open()传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根 据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。&lt;/p&gt;
&lt;p&gt;调用 close()方法还可以关闭新打开的窗口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wroxWin.close()&lt;/code&gt; 、&lt;code&gt;Window.close()&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;location对象&#34;&gt;location对象&lt;/h2&gt;
&lt;p&gt;它提供了与当前窗口中加载的文档有关的信息，还提供了一 些导航功能&lt;/p&gt;
&lt;p&gt;下表列出了 location 对象的所有属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628146473852.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;位置操作&#34;&gt;位置操作&lt;/h3&gt;
&lt;p&gt;使用 location 对象可以通过很多方式来改变浏览器的位置。&lt;/p&gt;
&lt;p&gt;使用 assign()方法并为其传递一个 URL&lt;/p&gt;
&lt;p&gt;&lt;code&gt;location.assign(&amp;quot;http://www.wrox.com&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以立即打开新 URL 并在浏览器的历史记录中生成一条记录&lt;/p&gt;
&lt;p&gt;下列两行代码与 显式调用 assign()方法的效果完全一样。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;window.location = &amp;quot;http://www.wrox.com&amp;quot;; 
location.href = &amp;quot;http://www.wrox.com&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;replace()&lt;/code&gt;方法不会在浏览器上留痕，不会在历史记录中生成新记 录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;location.replace(&amp;quot;http://www.wrox.com/&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;reload()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认先从缓存找&lt;/p&gt;
&lt;p&gt;作用是重新加载当前显示的页面，如果要强制从服务器重新加载传参&lt;code&gt;location.reload(true)&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;history-对象&#34;&gt;history 对象&lt;/h2&gt;
&lt;p&gt;history 对象保存着用户上网的历史记录&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;go()&lt;/code&gt;方法可以在用户的历史记录中任意跳转，可以向后也可以向前。&lt;/p&gt;
&lt;p&gt;还可以使用两个简写方法 &lt;code&gt;back()&lt;/code&gt;和 &lt;code&gt;forward()&lt;/code&gt;来代替 &lt;code&gt;go()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个方法接受一个参数， 表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转，正数反之&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//后退一页
history.go(-1); 

//前进一页
history.go(1); 

//前进两页
history.go(2); 


//跳转到最近的 wrox.com 页面
//如果历史记录中不包含该字符串，那么这个方法什么也不做
history.go(&amp;quot;wrox.com&amp;quot;); 

//后退一页
history.back(); 

//前进一页
history.forward(); 


&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;history 对象还有一个 length 属性，保存着历史记录的数量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (history.length == 0){ 
 //这应该是用户打开窗口后的第一个页面
} 

&lt;/code&gt;&lt;/pre&gt;
">BOM</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/htmlcss-he-javascriptshi-ru-he-bian-cheng-de/"" data-c="
          &lt;p&gt;导航被提交后就进⼊了渲染阶段。&lt;/p&gt;
&lt;h2 id=&#34;构建dom树&#34;&gt;构建DOM树&lt;/h2&gt;
&lt;p&gt;为什么要构建DOM树呢？&lt;/p&gt;
&lt;p&gt;这是因为浏览器⽆法直接理解和使⽤HTML，所以需要将HTML转换为 浏览器能够理解的结构——&lt;strong&gt;DOM树&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084109723.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;样式计算&#34;&gt;样式计算&lt;/h2&gt;
&lt;p&gt;样式计算的⽬的是为了计算出DOM节点中每个元素的具体样式&lt;/p&gt;
&lt;h3 id=&#34;把css转换为浏览器能够理解的结构&#34;&gt;把CSS转换为浏览器能够理解的结构&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084117590.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;CSS样式来源主要有上面三种&lt;/p&gt;
&lt;p&gt;浏览器也是⽆法直接理解这些纯⽂本的CSS样式，所以当渲染引擎接收到 CSS⽂本时，会执⾏⼀个转换操作，&lt;strong&gt;将CSS⽂本转换为浏览器可以理解的结构—— styleSheets&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;只需要在控制台中输⼊ document.styleSheets，然后就看到如下图所⽰的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084131779.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;)&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;转换样式表中的属性值使其标准化&#34;&gt;转换样式表中的属性值，使其标准化&lt;/h3&gt;
&lt;p&gt;接下来就要对其进⾏属性值的标准化操作&lt;/p&gt;
&lt;p&gt;的CSS⽂本中有很多属性值，如2em、blue、bold，这些类型数值不容易被渲染引 擎理解，所以需要&lt;strong&gt;将所有值转换为渲染引擎容易理解的、标准化的计算值&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084154198.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h3 id=&#34;计算出dom树中每个节点的具体样式&#34;&gt;计算出DOM树中每个节点的具体样式&lt;/h3&gt;
&lt;p&gt;样式计算过程中的第一个规则是CSS继承。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CSS继承就是每个DOM节点都包含有⽗节点的样式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;样式计算过程中的第⼆个规则是样式层叠。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;层叠是CSS的⼀个基本特征，它是⼀个定义了如何合 并来⾃多个源的属性值的算法。它在CSS处于核⼼地位，CSS的全称“层叠样式表”正是强调了这 ⼀点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个阶段最终输出的内容是每个DOM节点的样式，并被保存 在ComputedStyle的结构内。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;布局阶段&#34;&gt;布局阶段&lt;/h2&gt;
&lt;p&gt;接下来就需要&lt;strong&gt;计算出DOM树中可⻅元素的⼏何位置&lt;/strong&gt;，我们把这个计 算过程叫做布局。&lt;/p&gt;
&lt;h3 id=&#34;创建布局树&#34;&gt;创建布局树&lt;/h3&gt;
&lt;p&gt;在显⽰之前，我们还要额外地构建⼀棵只包含可⻅元素布局树&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084173184.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;从上图可以看出，DOM树中所有不可⻅的节点都没有包含到布局树中&lt;/p&gt;
&lt;p&gt;为了构建布局树，浏览器⼤体上完成了下⾯这些⼯作：&lt;/p&gt;
&lt;p&gt;为了构建布局树，浏览器⼤体上完成了下⾯这些⼯作：&lt;/p&gt;
&lt;p&gt;⽽不可⻅的节点会被布局树忽略掉，如head标签下⾯的全部内容，再⽐如body.p.span这个元 素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;布局计算&#34;&gt;布局计算&lt;/h3&gt;
&lt;p&gt;接下来，就计算布局树节点的坐标位置&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;分层&#34;&gt;分层&lt;/h2&gt;
&lt;p&gt;现在我们有了布局树，因为⻚⾯中有很多复杂的效果，如⼀些复杂的3D变换、⻚⾯滚动，或者使⽤z-indexing做z轴排序等，为了 更加⽅便地实现这些效果，&lt;strong&gt;渲染引擎还需要为特定的节点⽣成专⽤的图层，并⽣成⼀棵对应的图层树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器的⻚⾯实际上被分成了很多图层，这些图层叠加后合成了最终的⻚⾯&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084183718.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;浏览器的⻚⾯实际上被分成了很多图层，这些图层叠加后合成了最终的⻚⾯&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但并不是布局树的每个节点都包含⼀个图层，如果⼀个节点没有对应的层，那么这个节点就从属 于⽗节点的图层。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;那么需要满⾜什么条件，渲染引擎才会为特定的节点创建新的层呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第⼀点，拥有层叠上下⽂属性的元素会被提升为单独的⼀层。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084191361.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;第⼆点，需要剪裁（clip）的地⽅也会被创建为图层。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;style&amp;gt;
div {
width: 200;
height: 200;
overflow:auto;
background: gray;
}
&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div &amp;gt;
&amp;lt;p&amp;gt;所以元素有了层叠上下⽂的属性或者需要被剪裁，那么就会被提升成为单独⼀层，你可以参看下图：&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;从上图我们可以看到，document层上有A和B层，⽽B层之上⼜有两个图层。这些图层组织在⼀起也是⼀颗树状结构。&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这⾥我们把div的⼤⼩限定为200 * 200像素，⽽div⾥⾯的⽂字内容⽐较多，⽂字所显⽰的区域肯定会超出 200 * 200的⾯积，这时候就产⽣了剪裁&lt;/p&gt;
&lt;p&gt;出现这种裁剪情况的时候，渲染引擎会为⽂字部分单独创建⼀个层，如果出现滚动条，滚动条也会被提升为 单独的层。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084201544.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;图层绘制&#34;&gt;图层绘制&lt;/h2&gt;
&lt;p&gt;在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进⾏绘制&lt;/p&gt;
&lt;p&gt;渲染引擎实现图层的绘制与之类似，会把⼀个图层的绘制拆分成很多⼩的绘制指令，然后再把这些指令按照 顺序组成⼀个待绘制列表，如下图所⽰：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084215184.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;h2 id=&#34;栅格化raster操作&#34;&gt;栅格化（raster）操作&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084222127.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程&lt;/p&gt;
&lt;p&gt;我们把⽤⼾可以看到的这个部分叫做&lt;strong&gt;视⼝&lt;/strong&gt; （viewport）。&lt;/p&gt;
&lt;p&gt;有的图层可以很⼤，⽐如有的⻚⾯你使⽤滚动条要滚动好久才能滚动到底部，但是通过视 ⼝，⽤⼾只能看到⻚⾯的很⼩⼀部分，所以在这种情况下，要绘制出所有图层内容的话，就会产⽣太⼤的开 销，⽽且也没有必要。&lt;/p&gt;
&lt;p&gt;基于这个原因，&lt;strong&gt;合成线程会将图层划分为图块&lt;/strong&gt;（tile）&lt;/p&gt;
&lt;p&gt;合成线程会按照视⼝附近的图块来优先⽣成位图，实际⽣成位图的操作是由栅格化来执⾏的。所谓栅格 化，是指将图块转换为位图。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;合成和显示&#34;&gt;合成和显⽰&lt;/h2&gt;
&lt;p&gt;⼀旦所有图块都被光栅化，合成线程就会⽣成⼀个绘制图块的命令⸺“DrawQuad”，然后将该命令提交 给浏览器进程。&lt;/p&gt;
&lt;p&gt;到这⾥，经过这⼀系列的阶段，编写好的HTML、CSS、JavaScript等⽂件，经过浏览器就会显⽰出漂亮的 ⻚⾯了。&lt;/p&gt;
&lt;p&gt;整个渲染流程：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084239640.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;p&gt;⼀个完整的渲染流程⼤致可总结为如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;渲染进程将HTML内容转换为能够读懂的DOM树结构。&lt;/li&gt;
&lt;li&gt;渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。&lt;/li&gt;
&lt;li&gt;创建布局树，并计算元素的布局信息。&lt;/li&gt;
&lt;li&gt;对布局树进⾏分层，并⽣成分层树。&lt;/li&gt;
&lt;li&gt;为每个图层⽣成绘制列表，并将其提交到合成线程。&lt;/li&gt;
&lt;li&gt;合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。&lt;/li&gt;
&lt;li&gt;合成线程发送绘制图块命令DrawQuad给浏览器进程。&lt;/li&gt;
&lt;li&gt;浏览器进程根据DrawQuad消息⽣成⻚⾯，并显⽰到显⽰器上。&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;h2 id=&#34;相关概念&#34;&gt;相关概念&lt;/h2&gt;
&lt;h3 id=&#34;更新了元素的几何属性重排&#34;&gt;更新了元素的⼏何属性（重排）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084287094.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果你通过JavaScript或者CSS修改元素的⼏何位置属性，例如改变元素的宽度、⾼度 等，那么浏览器会触发重新布局，解析之后的⼀系列⼦阶段，这个过程就叫&lt;strong&gt;重排&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;重排需要更新完整 的渲染流⽔线，所以开销也是最⼤的。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;更新元素的绘制属性重绘&#34;&gt;更新元素的绘制属性（重绘）&lt;/h3&gt;
&lt;p&gt;⽐如通过JavaScript更改某些元素的背景颜⾊&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084293505.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果修改了元素的背景颜⾊，那么布局阶段将不会被执⾏，因为并没有引起⼏何位置的变 换，所以就直接进⼊了绘制阶段，然后执⾏之后的⼀系列⼦阶段，这个过程就叫&lt;strong&gt;重绘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重绘省去了布局和分层阶段，所以执⾏效率会⽐重排操作要⾼⼀些。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;直接合成阶段&#34;&gt;直接合成阶段&lt;/h3&gt;
&lt;p&gt;如果你更改⼀个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执⾏ 后续的合成操作，我们把这个过程叫做&lt;strong&gt;合成&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1628084297971.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;因为是在⾮主线程上合成，并没有占⽤主线程的资源，另外也避 开了布局和绘制两个⼦阶段，所以相对于重绘和重排，&lt;strong&gt;合成能⼤⼤提升绘制效率&lt;/strong&gt;。&lt;/p&gt;
">HTML、CSS和JavaScript，是如何变成⻚⾯的？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/mian-xiang-dui-xiang-de-cheng-xu-she-ji/"" data-c="
          &lt;h2 id=&#34;对象&#34;&gt;对象&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;var person = new Object();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var person={}&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;属性类型&#34;&gt;属性类型&lt;/h3&gt;
&lt;h4 id=&#34;数据类型&#34;&gt;数据类型&lt;/h4&gt;
&lt;p&gt;[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为 true。&lt;/p&gt;
&lt;p&gt;[[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定 义的属性，它们的这个特性默认值为 true。&lt;/p&gt;
&lt;p&gt;[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为 true。&lt;/p&gt;
&lt;p&gt;[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候， 把新值保存在这个位置。这个特性的默认值为 undefined。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;要修改属性默认的特性，使用 **Object.defineProperty()**方法&lt;/p&gt;
&lt;p&gt;这个方法 接收三个参数：属性所在的对象、属性的名字和一个描述符对象&lt;/p&gt;
&lt;p&gt;其中，描述符（descriptor）对象的属 性必须是：configurable、enumerable、writable 和 value。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var person = {}; 
Object.defineProperty(person, &amp;quot;name&amp;quot;, { 
 writable: false, 
 value: &amp;quot;Nicholas&amp;quot; 
}); 
alert(person.name); //&amp;quot;Nicholas&amp;quot; 
person.name = &amp;quot;Greg&amp;quot;; 
alert(person.name); //&amp;quot;Nicholas&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;访问器属性&#34;&gt;访问器属性&lt;/h4&gt;
&lt;p&gt;访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数&lt;/p&gt;
&lt;p&gt;在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值&lt;/p&gt;
&lt;p&gt;在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据&lt;/p&gt;
&lt;p&gt;访问器属性有如下 4 个特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 true。&lt;/li&gt;
&lt;li&gt;[[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这 个特性的默认值为 true。&lt;/li&gt;
&lt;li&gt;[[Get]]：在读取属性时调用的函数。默认值为 undefined。&lt;/li&gt;
&lt;li&gt;[[Set]]：在写入属性时调用的函数。默认值为 undefined。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;访问器属性不能直接定义，必须使用 &lt;code&gt;Object.defineProperty()&lt;/code&gt;来定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var book = { 
 _year: 2004, 
 edition: 1 
}; 
Object.defineProperty(book, &amp;quot;year&amp;quot;, { 
 get: function(){ 
 return this._year; 
 }, 
 set: function(newValue){ 
 if (newValue &amp;gt; 2004) { 
 this._year = newValue; 
 this.edition += newValue - 2004; 
 } 
 } 
}); 
book.year = 2005; 
alert(book.edition); //2 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;_year 前面 的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。&lt;/p&gt;
&lt;p&gt;不一定非要同时指定 getter 和 setter。只指定 getter 意味着属性是不能写，尝试写入属性会被忽略&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;定义多个属性&#34;&gt;定义多个属性&lt;/h4&gt;
&lt;p&gt;由于为对象定义多个属性的可能性很大，ECMAScript 5 又定义了一个 &lt;code&gt;Object.defineProperties()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;这个方法接收两个对象参数：第一 个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对 应&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var book = {};
Object.defineProperties(book, { 
    
 _year: { 
 value: 2004,
 writable:true
 }, 
 
 edition: { 
 value: 1 
 }, 
    
 year: { 
 get: function(){
 	return this._year; 
 }, 
 set: function(newValue){ 
	 if (newValue &amp;gt; 2004) { 
 		this._year = newValue; 
 		this.edition += newValue - 2004; 
 			} 
		}
	} 
}); 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码在 book 对象上定义了两个数据属性（_year 和 edition）和一个访问器属性（year）。&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;读取属性的特性&#34;&gt;读取属性的特性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Object.getOwnPropertyDescriptor()&lt;/code&gt;方法，可以取得给定属性的描述符。&lt;/p&gt;
&lt;p&gt;这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var book = {}; 
Object.defineProperties(book, { 
 _year: { 
 value: 2004 
 }, 
 edition: { 
 value: 1 
 }, 
 year: { 
 get: function(){ 
 return this._year; 
 }, 
 set: function(newValue){ 
 	if (newValue &amp;gt; 2004) { 
 		this._year = newValue; 
		this.edition += newValue - 2004; 
 			} 
 		} 
 	} 
}); 

var descriptor = Object.getOwnPropertyDescriptor(book, &amp;quot;_year&amp;quot;); 

alert(descriptor.value); //2004 
alert(descriptor.configurable); //false 
alert(typeof descriptor.get); //&amp;quot;undefined&amp;quot; 
var descriptor = Object.getOwnPropertyDescriptor(book, &amp;quot;year&amp;quot;); 

alert(descriptor.value); //undefined 
alert(descriptor.enumerable); //false 
alert(typeof descriptor.get); //&amp;quot;function&amp;quot; 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于数据属性_year，value 等于最初的值，configurable 是 false，而 get 等于 undefined&lt;/p&gt;
&lt;p&gt;对于访问器属性 year，value 等于 undefined，enumerable 是 false，而 get 是一个指向 getter 函数的指针&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;创建对象&#34;&gt;&lt;strong&gt;创建对象&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同 一个接口创建很多对象，会产生大量的重复代码。&lt;/p&gt;
&lt;h3 id=&#34;工厂模式&#34;&gt;工厂模式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function createPerson(name, age, job){ 
 var o = new Object(); 
 o.name = name; 
 o.age = age; 
 o.job = job; 
 o.sayName = function(){ 
 alert(this.name); 
 }; 
 return o; 
} 
var person1 = createPerson(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 
var person2 = createPerson(&amp;quot;Greg&amp;quot;, 27, &amp;quot;Doctor&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;构造函数模式&#34;&gt;构造函数模式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(name, age, job){ 
 this.name = name; 
 this.age = age; 
 this.job = job; 
 this.sayName = function(){ 
 alert(this.name); 
 }; 
} 

var person1 = new Person(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 

var person2 = new Person(&amp;quot;Greg&amp;quot;, 27, &amp;quot;Doctor&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;没有显式地创建对象；&lt;/li&gt;
&lt;li&gt;直接将属性和方法赋给了 this 对象；&lt;/li&gt;
&lt;li&gt;没有 return 语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要创建 Person 的新实例，必须使用 new 操作符。&lt;/p&gt;
&lt;p&gt;以这种方式调用构造函数实际上会经历以下 4 个步骤：&lt;/p&gt;
&lt;p&gt;(1) 创建一个新对象；&lt;/p&gt;
&lt;p&gt;(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；&lt;/p&gt;
&lt;p&gt;(3) 执行构造函数中的代码（为这个新对象添加属性）；&lt;/p&gt;
&lt;p&gt;(4) 返回新对象。&lt;/p&gt;
&lt;p&gt;​	&lt;br&gt;&lt;/p&gt;
&lt;p&gt;person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都 有一个 constructor（构造函数）属性，该属性指向 Person&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(person1.constructor == Person); //true 
alert(person2.constructor == Person); //true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式 胜过工厂模式的地方。&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;将构造函数当作函数&#34;&gt;将构造函数当作函数&lt;/h4&gt;
&lt;p&gt;任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 当作构造函数使用
var person = new Person(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 
person.sayName(); //&amp;quot;Nicholas&amp;quot; 

// 作为普通函数调用
Person(&amp;quot;Greg&amp;quot;, 27, &amp;quot;Doctor&amp;quot;); // 添加到 window 
window.sayName(); //&amp;quot;Greg&amp;quot; 

// 在另一个对象的作用域中调用
var o = new Object(); 
Person.call(o, &amp;quot;Kristen&amp;quot;, 25, &amp;quot;Nurse&amp;quot;); 
o.sayName(); //&amp;quot;Kristen&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;构造函数的问题&#34;&gt;构造函数的问题&lt;/h4&gt;
&lt;p&gt;使用构造函数的主要问题，就是每个方法都要在每个 实例上重新创建一遍。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this.sayName = new Function(&amp;quot;alert(this.name)&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从这个角度上来看构造函数，更容易明白每个 Person 实例都包含一个不同的 Function 实例&lt;/p&gt;
&lt;p&gt;通过把函数定义转移到构造函数外 部来解决这个问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(name, age, job){ 
 this.name = name; 
 this.age = age; 
 this.job = job; 
 this.sayName = sayName; 
} 

function sayName(){ 
 alert(this.name); 
} 

var person1 = new Person(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 
var person2 = new Person(&amp;quot;Greg&amp;quot;, 27, &amp;quot;Doctor&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可是新问题又来了：在全局作用域中定义的函数实际上只 能被某个对象调用，这让全局作用域有点名不副实。&lt;/p&gt;
&lt;p&gt;如果对象需要定义很多方 法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。&lt;/p&gt;
&lt;p&gt;好在， 这些问题可以通过使用原型模式来解决。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;原型模式&#34;&gt;原型模式&lt;/h3&gt;
&lt;h4 id=&#34;理解原型&#34;&gt;理解原型&lt;/h4&gt;
&lt;p&gt;我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象&lt;/p&gt;
&lt;p&gt;使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(){ 
} 
Person.prototype.name = &amp;quot;Nicholas&amp;quot;; 
Person.prototype.age = 29; 
Person.prototype.job = &amp;quot;Software Engineer&amp;quot;; 
Person.prototype.sayName = function(){ 
 alert(this.name); 
}; 

var person1 = new Person(); 
person1.sayName(); //&amp;quot;Nicholas&amp;quot; 
var person2 = new Person();
person2.sayName(); //&amp;quot;Nicholas&amp;quot; 
alert(person1.sayName == person2.sayName); //true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过 isPrototypeOf()方法来确定对象之 间关系&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(Person.prototype.isPrototypeOf(person1)); //true 
alert(Person.prototype.isPrototypeOf(person2)); //true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(Object.getPrototypeOf(person1) == Person.prototype); //true 
alert(Object.getPrototypeOf(person1).name); //&amp;quot;Nicholas&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。&lt;/p&gt;
&lt;p&gt;如果我们 在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该 属性将会屏蔽原型中的那个属性。&lt;/p&gt;
&lt;p&gt;添加同名属性只会阻止我们访问原型中的那个属性，但不会修改原型中的属性。&lt;/p&gt;
&lt;p&gt;使用 delete 操作符则可以完全删 除实例属性，从而让我们能够重新访问原型中的属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(){ 
} 
Person.prototype.name = &amp;quot;Nicholas&amp;quot;; 
Person.prototype.age = 29; 
Person.prototype.job = &amp;quot;Software Engineer&amp;quot;; 
Person.prototype.sayName = function(){ 
 alert(this.name); 
}; 
var person1 = new Person(); 
var person2 = new Person(); 
person1.name = &amp;quot;Greg&amp;quot;; 
alert(person1.name); //&amp;quot;Greg&amp;quot;——来自实例
alert(person2.name); //&amp;quot;Nicholas&amp;quot;——来自原型
delete person1.name; 
alert(person1.name); //&amp;quot;Nicholas&amp;quot;——来自原型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过使用 &lt;code&gt;hasOwnProperty()&lt;/code&gt;方法，什么时候访问的是实例属性，什么时候访问的是原型属性就 一清二楚了&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;原型与in操作符&#34;&gt;原型与in操作符&lt;/h4&gt;
&lt;p&gt;有两种方式使用 in 操作符：&lt;/p&gt;
&lt;p&gt;单独使用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;alert(&amp;quot;name&amp;quot; in person1);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当该属性存在于实例中还是存在于原型中，调用&lt;code&gt;&amp;quot;name&amp;quot; in person1&lt;/code&gt;都返回 true，&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;for-in 循环中使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;for( let i in person)
{
	alert(person[i])
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中 &lt;strong&gt;既包括存在于实例中的属性，也包括存在于原型中的属性&lt;/strong&gt;。屏蔽了原型中不可枚举属性&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;原型的动态性&#34;&gt;原型的动态性&lt;/h4&gt;
&lt;p&gt;我们对原型对象所做的任何修改都能够立即从实例上 反映出来——即使是先创建了实例后修改原型也照样如此&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var friend = new Person(); 
Person.prototype.sayHi = function(){ 
 alert(&amp;quot;hi&amp;quot;); 
}; 
friend.sayHi(); //&amp;quot;hi&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;原型存在的问题&#34;&gt;原型存在的问题&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Person.prototype = { 
 constructor: Person, 
 name : &amp;quot;Nicholas&amp;quot;, 
 age : 29, 
 job : &amp;quot;Software Engineer&amp;quot;, 
 friends : [&amp;quot;Shelby&amp;quot;, &amp;quot;Court&amp;quot;],  //数组
 sayName : function () { 
 alert(this.name); 
 } 
}; 

var person1 = new Person(); 
var person2 = new Person(); 

person1.friends.push(&amp;quot;Van&amp;quot;); 

alert(person1.friends); //&amp;quot;Shelby,Court,Van&amp;quot; 
alert(person2.friends); //&amp;quot;Shelby,Court,Van&amp;quot; 
alert(person1.friends === person2.friends); //true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;像这种引用类型的属性共享是会造成其他实例的属性一起改变，因此改变这种弊端&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;组合使用构造函数模式和原型模式&#34;&gt;组合使用构造函数模式和原型模式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(name, age, job){ 
 this.name = name; 
 this.age = age; 
 this.job = job; 
 this.friends = [&amp;quot;Shelby&amp;quot;, &amp;quot;Court&amp;quot;]; 
} 

Person.prototype = { 
 constructor : Person, 
 sayName : function(){ 
 alert(this.name); 
 } 
} 

var person1 = new Person(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 

var person2 = new Person(&amp;quot;Greg&amp;quot;, 27, &amp;quot;Doctor&amp;quot;); 

person1.friends.push(&amp;quot;Van&amp;quot;); 

alert(person1.friends); //&amp;quot;Shelby,Count,Van&amp;quot; 
alert(person2.friends); //&amp;quot;Shelby,Count&amp;quot; 
alert(person1.friends === person2.friends); //false 
alert(person1.sayName === person2.sayName); //true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实例属性&lt;/strong&gt;都是在&lt;strong&gt;构造函数&lt;/strong&gt;中定义的，而由所有实例&lt;strong&gt;共享的属性 constructor 和方 法&lt;/strong&gt; sayName()则是在原型中定义的。&lt;/p&gt;
&lt;p&gt;是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自 定义类型的方法&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;动态原型模式&#34;&gt;动态原型模式&lt;/h3&gt;
&lt;p&gt;可以通过 检查某个应该存在的方法是否有效，来决定是否需要初始化原型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(name, age, job){ 
 //属性
 this.name = name; 
 this.age = age; 
 this.job = job; 
 //方法
 if (typeof this.sayName != &amp;quot;function&amp;quot;){ 
 
 Person.prototype.sayName = function(){ 
 alert(this.name); 
 }; 
 
 } 
} 

var friend = new Person(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 
friend.sayName(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里只在 &lt;code&gt;sayName()&lt;/code&gt;方法不存在的情况下，才会将它添加到原 型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修 改了&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;寄生构造函数模式&#34;&gt;寄生构造函数模式&lt;/h3&gt;
&lt;p&gt;这种模式 的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(name, age, job){ 
 var o = new Object(); 
 o.name = name; 
 o.age = age; 
 o.job = job; 
 o.sayName = function(){ 
 alert(this.name); 
 }; 
 return o; 
} 

var friend = new Person(&amp;quot;Nicholas&amp;quot;, 29, &amp;quot;Software Engineer&amp;quot;); 
friend.sayName(); //&amp;quot;Nicholas&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于寄生构造函数模式，返&lt;strong&gt;回的对象与构造函数或者与构造函数的原型属 性之间没有关系&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;稳妥构造函数模式&#34;&gt;稳妥构造函数模式&lt;/h3&gt;
&lt;p&gt;所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。&lt;/p&gt;
&lt;p&gt;一是新创建对象的 实例方法不引用 this&lt;/p&gt;
&lt;p&gt;二是不使用 new 操作符调用构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Person(name, age, job){ 
 
 //创建要返回的对象
 var o = new Object(); 
 //可以在这里定义私有变量和函数
 //添加方法
 o.sayName = function(){ 
 alert(name); 
 }; 
 
 //返回对象
 return o; 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;
&lt;p&gt;其实现继承主要是依靠原型链 来实现的。&lt;/p&gt;
&lt;h3 id=&#34;原型链&#34;&gt;原型链&lt;/h3&gt;
&lt;h4 id=&#34;基本模式&#34;&gt;基本模式&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function SuperType(){ 
 this.property = true; 
}

SuperType.prototype.getSuperValue = function(){ 
 return this.property; 
}; 

function SubType(){ 
 this.subproperty = false; 
} 

//继承了 SuperType 
SubType.prototype = new SuperType(); 
//加入新方法
SubType.prototype.getSubValue = function (){ 
 return this.subproperty; 
}; 

var instance = new SubType(); 
alert(instance.getSuperValue()); //true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;instance 继承了SubType 的属性，包括&lt;strong&gt;constructor&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;constructor&lt;/strong&gt;属性指向该对象对应的构造函数&lt;/p&gt;
&lt;p&gt;instance 指向 SubType 的原型， SubType 的原型又指向 SuperType 的原型。&lt;/p&gt;
&lt;p&gt;要注意 instance.constructor 现在指向的 是 SuperType&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;确定原型和实例的关系&#34;&gt;确定原型和实例的关系&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(instance instanceof Object); //true 
alert(instance instanceof SuperType); //true 
alert(instance instanceof SubType); //true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种方式是使用&lt;code&gt;isPrototypeOf()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;只要是原型链中出现过的原型，都可以说是该 原型链所派生的实例的原型，因此 &lt;code&gt;isPrototypeOf()&lt;/code&gt;方法也会返回 true，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(Object.prototype.isPrototypeOf(instance)); //true 
alert(SuperType.prototype.isPrototypeOf(instance)); //true 
alert(SubType.prototype.isPrototypeOf(instance)); //true 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这 样做就会重写原型链&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function SuperType(){ 
 this.property = true; 
} 
SuperType.prototype.getSuperValue = function(){ 
 return this.property; 
}; 
function SubType(){ 
 this.subproperty = false; 
} 
//继承了 SuperType 
SubType.prototype = new SuperType(); 
//使用字面量添加新方法，会导致上一行代码无效
SubType.prototype = { 
 getSubValue : function (){ 
 return this.subproperty; 
 }, 
 someOtherMethod : function (){ 
 return false; 
 } 
}; 
var instance = new SubType(); 
alert(instance.getSuperValue()); //error!
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;原型链的问题&#34;&gt;原型链的问题&lt;/h4&gt;
&lt;p&gt;原型链最主要的问题来自包含&lt;strong&gt;引用类型值&lt;/strong&gt;的原型&lt;/p&gt;
&lt;p&gt;解决方式如下&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;借用构造函数&#34;&gt;借用构造函数&lt;/h3&gt;
&lt;p&gt;函数只不过是在特定环境中执行代码的对象， 因此通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function SuperType(){ 
 this.colors = [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;]; 
} 

function SubType(){ 
 //继承了 SuperType 
 SuperType.call(this); 
} 

var instance1 = new SubType(); 
instance1.colors.push(&amp;quot;black&amp;quot;); 
alert(instance1.colors); //&amp;quot;red,blue,green,black&amp;quot; 
var instance2 = new SubType(); 
alert(instance2.colors); //&amp;quot;red,blue,green&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;传递参数&#34;&gt;传递参数&lt;/h4&gt;
&lt;p&gt;借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函 数传递参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function SuperType(name){ 
 this.name = name; 
} 
function SubType(){ 
 //继承了 SuperType，同时还传递了参数
 SuperType.call(this, &amp;quot;Nicholas&amp;quot;); 
 
 //实例属性
 this.age = 29; 
} 
var instance = new SubType(); 
alert(instance.name); //&amp;quot;Nicholas&amp;quot;; 
alert(instance.age); //29
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h4 id=&#34;借用构造函数的问题&#34;&gt;借用构造函数的问题&lt;/h4&gt;
&lt;p&gt;方法都在构造函数中定 义，因此函数复用就无从谈起了&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;组合继承&#34;&gt;组合继承&lt;/h3&gt;
&lt;p&gt;指的是将原型链和借用构造函数的 技术组合到一块，从而发挥二者之长的一种继承模式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function SuperType(name){ 
 this.name = name; 
 this.colors = [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;]; 
} 

SuperType.prototype.sayName = function(){ 
 alert(this.name); 
    }; 

function SubType(name, age){ 
 //继承属性
 SuperType.call(this, name); 
 this.age = age; 
} 

//继承方法
SubType.prototype = new SuperType(); 
//完善
SubType.prototype.constructor = SubType; 

SubType.prototype.sayAge = function(){ 
 alert(this.age); 
}; 

var instance1 = new SubType(&amp;quot;Nicholas&amp;quot;, 29); 
instance1.colors.push(&amp;quot;black&amp;quot;); 
alert(instance1.colors); //&amp;quot;red,blue,green,black&amp;quot; 
instance1.sayName(); //&amp;quot;Nicholas&amp;quot;; 
instance1.sayAge(); //29 

var instance2 = new SubType(&amp;quot;Greg&amp;quot;, 27); 
alert(instance2.colors); //&amp;quot;red,blue,green&amp;quot; 
instance2.sayName(); //&amp;quot;Greg&amp;quot;; 
instance2.sayAge(); //27 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;原型式继承&#34;&gt;原型式继承&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function object(o){ 
 function F(){} 
 F.prototype = o; 
 return new F(); 
} 

var person = { 
 name: &amp;quot;Nicholas&amp;quot;, 
 friends: [&amp;quot;Shelby&amp;quot;, &amp;quot;Court&amp;quot;, &amp;quot;Van&amp;quot;] 
}; 

var anotherPerson = object(person); 
anotherPerson.name = &amp;quot;Greg&amp;quot;; 
anotherPerson.friends.push(&amp;quot;Rob&amp;quot;); 

var yetAnotherPerson = object(person); 
yetAnotherPerson.name = &amp;quot;Linda&amp;quot;; 
yetAnotherPerson.friends.push(&amp;quot;Barbie&amp;quot;); 
alert(person.friends); //&amp;quot;Shelby,Court,Van,Rob,Barbie
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;包含引用类型值的属性始终都会共享相应的值，没做到期望的效果&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;寄生式继承&#34;&gt;寄生式继承&lt;/h3&gt;
&lt;p&gt;寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来&lt;strong&gt;增强对象&lt;/strong&gt;，最后再像真地是它做了所有工作一样返回对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function createAnother(original){ 
 var clone = object(original); //通过调用函数创建一个新对象
    
 clone.sayHi = function(){ //以某种方式来增强这个对象
 alert(&amp;quot;hi&amp;quot;); 
 }; 
    
 return clone; //返回这个对象
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;寄生组合式继承&#34;&gt;寄生组合式继承&lt;/h3&gt;
&lt;p&gt;高效率体现在它只调用了一次 SuperType 构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function object(o){ 
 function F(){} 
 F.prototype = o; 
 return new F(); 
} 

function inheritPrototype(subType, superType){ 
 var prototype = object(superType.prototype); //创建对象
 prototype.constructor = subType; //增强对象
 subType.prototype = prototype; //指定对象
}

function SuperType(name){ 
 this.name = name; 
 this.colors = [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;]; 
} 
SuperType.prototype.sayName = function(){ 
 alert(this.name); 
}; 

function SubType(name, age){ 
 SuperType.call(this, name); 
 
 this.age = age; 
} 

inheritPrototype(SubType, SuperType); 

SubType.prototype.sayAge = function(){ 
 alert(this.age); 
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
"> 面向对象的程序设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/cong-shu-url-dao-zhan-zhe-zhong-jian-fa-liao-shi-me/"" data-c="
          &lt;p&gt;从输⼊URL到⻚⾯展⽰完整流程⽰意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627880380385.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
浏览器进程、渲染进程和⽹络进程的主要职责：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浏览器进程主要负责⽤⼾交互、⼦进程管理和⽂件储存等功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;⽹络进程是⾯向渲染进程和浏览器进程等提供⽹络下载功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;渲染进程的主要职责是把从⽹络下载的HTML、JavaScript、CSS、图⽚等资源解析为可以显⽰和交互的 ⻚⾯。&lt;/p&gt;
&lt;p&gt;因为渲染进程所有的内容都是通过⽹络获取的，会存在⼀些恶意代码利⽤浏览器漏洞对系统进⾏攻 击，所以运⾏在渲染进程⾥⾯的代码是不被信任的。这也是为什么Chrome会让渲染进程运⾏在安全沙箱 ⾥，就是为了保证系统的安全。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;这个过程可以⼤致描述为如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⾸先，⽤⼾从浏览器进程⾥输⼊请求信息；&lt;/li&gt;
&lt;li&gt;然后，⽹络进程发起URL请求；&lt;/li&gt;
&lt;li&gt;服务器响应URL请求之后，浏览器进程就⼜要开始准备渲染进程了；&lt;/li&gt;
&lt;li&gt;渲染进程准备好之后，需要先向渲染进程提交⻚⾯数据，我们称之为提交⽂档阶段；&lt;/li&gt;
&lt;li&gt;渲染进程接收完⽂档信息之后，便开始解析⻚⾯和加载⼦资源，完成⻚⾯的渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;从输入url到面展示&#34;&gt;从输⼊URL到⻚⾯展⽰&lt;/h2&gt;
&lt;h3 id=&#34;用戶输入&#34;&gt;⽤⼾输⼊&lt;/h3&gt;
&lt;p&gt;当⽤⼾在地址栏中输⼊⼀个查询关键字时，地址栏会判断输⼊的关键字是&lt;strong&gt;搜索内容&lt;/strong&gt;，还是&lt;strong&gt;请求的URL&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是搜索内容，地址栏会使⽤浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。&lt;/li&gt;
&lt;li&gt;如果判断输⼊内容符合URL规则，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;例如输入&lt;strong&gt;画画&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627880388812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;p&gt;输入不带协议的网址 例如  &lt;strong&gt;fanfankill.github.io&lt;/strong&gt;  会自动加上&lt;strong&gt;https:😕/&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;url请求过程&#34;&gt;URL请求过程&lt;/h3&gt;
&lt;p&gt;浏览器进程会通过进程间通信（IPC）把URL请求发送⾄⽹络 进程，⽹络进程接收到URL请求后，会在这⾥发起真正的URL请求流程。&lt;/p&gt;
&lt;p&gt;⾸先，⽹络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如 果在缓存中没有查找到资源，那么直接进⼊⽹络请求流程。&lt;/p&gt;
&lt;p&gt;这请求前的第⼀步是要进⾏&lt;strong&gt;DNS解析&lt;/strong&gt;，以获取请 求域名的服务器IP地址。如果请求协议是HTTPS，那么还需要建⽴TLS连接。&lt;/p&gt;
&lt;p&gt;接下来就是利⽤IP地址和服务器建⽴TCP连接。连接建⽴之后，浏览器端会构建请求⾏、请求头等信息，并 把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。&lt;/p&gt;
&lt;p&gt;服务器接收到请求信息后，会根据请求信息⽣成响应数据（包括响应⾏、响应头和响应体等信息），并发给 ⽹络进程。等⽹络进程接收了响应⾏和响应头之后，就开始解析响应头的内容了。&lt;/p&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重定向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在接收到服务器返回的响应头后，⽹络进程开始解析响应头，如果发现返回的状态码是301或者302，那么 说明服务器需要浏览器重定向到其他URL。这时⽹络进程会从响应头的Location字段⾥⾯读取重定向的地 址，然后再发起新的HTTP或者HTTPS请求，⼀切⼜重头开始了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;响应数据类型处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Content-Type是HTTP头中⼀个⾮常重要的字段， 它告诉浏览器服务器返回的响应 体数据是什么类型&lt;/strong&gt;，然后浏览器会根据Content-Type的值来决定如何显⽰响应体的内容。例如  text/html 是HTML格式， application/octet-stream  是&lt;strong&gt;字节流类型&lt;/strong&gt;，通常情况下，浏览器会按照&lt;strong&gt;下载类型&lt;/strong&gt;处理&lt;/p&gt;
&lt;p&gt;如果Content-Type字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该URL请求的导航流程就此结束。但如果是HTML， 那么浏览器则会继续进⾏导航流程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;准备渲染进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，Chrome会为每个⻚⾯分配⼀个渲染进程，每打开⼀个新⻚⾯就会配套创建⼀个新的渲染进程。在某些情况下，浏览器会让多个⻚⾯直接运⾏在同⼀个渲染进程中。&lt;/p&gt;
&lt;h4 id=&#34;那什么情况下多个面会同时运行在一个渲染进程中呢&#34;&gt;那什么情况下多个⻚⾯会同时运⾏在⼀个渲染进程中呢？&lt;/h4&gt;
&lt;p&gt;我们将“&lt;strong&gt;同⼀站点&lt;/strong&gt;”定 义为&lt;strong&gt;根域名&lt;/strong&gt;（例如 fanfankill.github.io）加上&lt;strong&gt;协议&lt;/strong&gt;（例如，https:// 或者http://），还包含了该根域名下的所有 ⼦域名和不同的端⼝&lt;/p&gt;
&lt;p&gt;它们都是属于同⼀站点，因为它们的协议都是HTTPS，⽽且根域名也都是fanfankill.github.io。&lt;/p&gt;
&lt;p&gt;但&lt;strong&gt;如果从⼀个⻚⾯打开了另⼀个新⻚⾯，⽽新⻚⾯和 当前⻚⾯属于同⼀站点的话，那么新⻚⾯会复⽤⽗⻚⾯的渲染进程&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;总结来说，打开⼀个新⻚⾯采⽤的&lt;strong&gt;渲染进程&lt;/strong&gt;策略就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常情况下，打开新的⻚⾯都会使⽤单独的渲染进程；&lt;/li&gt;
&lt;li&gt;如果从A⻚⾯打开B⻚⾯，且A和B都属于同⼀站点的话，那么B⻚⾯复⽤A⻚⾯的渲染进程；如果是其他情 况，浏览器进程则会为B创建⼀个新的渲染进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提交文档&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这⾥的“⽂档”是指URL请求的响应体数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“提交⽂档”的消息是由浏览器进程发出的，渲染进程接收到“提交⽂档”的消息后，会和⽹络进程建⽴ 传输数据的“&lt;strong&gt;管道&lt;/strong&gt;”。&lt;/li&gt;
&lt;li&gt;等⽂档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。&lt;/li&gt;
&lt;li&gt;浏览器进程在收到“确认提交”的消息后，会更新浏览器界⾯状态，包括了安全状态、地址栏的URL、前 进后退的历史状态，并更新Web⻚⾯。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;这也就解释了为什么在浏览器的地址栏⾥⾯输⼊了⼀个地址后，之前的⻚⾯没有⽴⻢消失，⽽是要加载⼀会 ⼉才会更新⻚⾯。&lt;/p&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;渲染阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;⼀旦⽂档被提交，渲染进程便开始⻚⾯解析和⼦资源加载了&lt;/p&gt;
&lt;p&gt;⼀旦⻚⾯⽣成完成，渲染进程会发送⼀个消息给浏览器进程，浏览器接 收到消息后，会停⽌标签图标上的加载动画。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627880395764.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">从输⼊URL到⻚⾯展⽰，这中间发⽣了什么？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/http-qing-qiu-liu-cheng-wei-shi-me-hen-duo-zhan-dian-di-ci-da-kai-su-du-hui-hen-kuai/"" data-c="
          &lt;p&gt;HTTP协议，正是建⽴在TCP连接基础之上的。&lt;strong&gt;HTTP是⼀种允许浏览器向服务器获取资源的协议，是 Web的基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP也是浏览器使⽤最⼴的协议&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;输入一个url会发生什么？&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;构建请求&#34;&gt;构建请求&lt;/h2&gt;
&lt;p&gt;⾸先，浏览器构建&lt;strong&gt;请求⾏&lt;/strong&gt;信息，如下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GET /index.html HTTP1.1&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;查找缓存&#34;&gt;查找缓存&lt;/h2&gt;
&lt;p&gt;在真正发起⽹络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的⽂件。其中，&lt;strong&gt;浏览器缓存是⼀种 在本地保存资源副本，以供下次请求时直接使⽤的技术&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会&lt;strong&gt;拦截请求&lt;/strong&gt;，返回该资源的副本。这样做的好处有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓解服务器端压⼒，提升性能（获取资源的耗时更短了）；&lt;/li&gt;
&lt;li&gt;对于⽹站来说，缓存是实现快速资源加载的重要组成部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，如果缓存查找失败，就会进⼊⽹络请求过程了。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;准备ip地址和端口&#34;&gt;准备IP地址和端⼝&lt;/h2&gt;
&lt;p&gt;HTTP和TCP的关系&lt;/p&gt;
&lt;p&gt;浏览器使⽤HTTP协议作为 &lt;strong&gt;应⽤层协议&lt;/strong&gt;，⽤来封装请求的⽂本信息；并使⽤&lt;strong&gt;TCP/IP作传输层协议&lt;/strong&gt;将它发到⽹络上&lt;/p&gt;
&lt;p&gt;在HTTP⼯作开 始之前，浏览器需要通过TCP与服务器建⽴连接。也就是说&lt;strong&gt;HTTP的内容是通过TCP的传输数据阶段来实现的&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1627811506470.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP⽹络请求的第⼀步是做什么呢？&lt;/p&gt;
&lt;p&gt;是和服务器建⽴TCP连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那怎么获取IP地址和端⼝号呢？&lt;/p&gt;
&lt;p&gt;利⽤URL 地址来获取IP和端⼝信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IP是 难以记忆，&lt;/p&gt;
&lt;p&gt;负责把域名和IP地址做⼀⼀映射关系。这套域名映射为IP的系统就叫 做“域名系统”，简称&lt;strong&gt;DNS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在第⼀步浏览器会请求DNS返回域名对应的IP&lt;/strong&gt;，当然浏览器还提供了 &lt;strong&gt;DNS数据缓存服务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使 ⽤，这样也会减少⼀次⽹络请求。&lt;/p&gt;
&lt;p&gt;拿到IP之后，接下来就需要获取端⼝号了。通常情况下，如果URL没有特别指明端⼝号，那么HTTP协议&lt;strong&gt;默认是80端⼝&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;等待tcp队列&#34;&gt;等待TCP队列&lt;/h2&gt;
&lt;p&gt;现在已经把端⼝和IP地址都准备好了，那么下⼀步是不是可以建⽴TCP连接了呢？&lt;/p&gt;
&lt;p&gt;答案依然是“不⾏”。Chrome有个机制，同⼀个域名同时最多只能建⽴6个TCP连接，如果在同⼀个域名下同时有10个请求发⽣，那么其中4个请求会进⼊排队等待状态，直⾄进⾏中的请求完成。&lt;/p&gt;
&lt;p&gt;当然，如果当前请求数量少于6，会直接进⼊下⼀步，建⽴TCP连接。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;建立tcp连接&#34;&gt;建⽴TCP连接&lt;/h2&gt;
&lt;p&gt;排队等待结束之后，终于可以快乐地和服务器握⼿了。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;发送http请求&#34;&gt;发送HTTP请求&lt;/h2&gt;
&lt;p&gt;⼀旦建⽴了TCP连接，浏览器就可以和服务器进⾏通信了。⽽HTTP中的数据正是在这个通信过程中传输 的。&lt;/p&gt;
&lt;p&gt;⾸先浏览器会向服务器发送请求⾏，它包括了&lt;strong&gt;请求⽅法、请求URI（Uniform Resource Identifier）和 HTTP版本协议&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在浏览器发送请求⾏命令之后，还要以&lt;strong&gt;请求头&lt;/strong&gt;形式发送其他⼀些信息，⽐如包含了浏览器所使⽤的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie信息，等等。&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1627812653198.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;服务端处理http请求流程&#34;&gt;服务端处理HTTP请求流程&lt;/h2&gt;
&lt;p&gt;历经千⾟万苦，HTTP的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相 应的内容。&lt;/p&gt;
&lt;h3 id=&#34;返回请求&#34;&gt;返回请求&lt;/h3&gt;
&lt;p&gt;⼀旦服务器处理结束，便可以返回数据给浏览器了。&lt;/p&gt;
&lt;p&gt;返回响应⾏、响应头和响应体的数据&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1627812730509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;⾸先服务器会返回&lt;strong&gt;响应⾏&lt;/strong&gt;，包括协议版本和状态码。&lt;/p&gt;
&lt;p&gt;服务器会 通过请求⾏的状态码来告诉浏览器它的处理结果&lt;/p&gt;
&lt;p&gt;服务器也会随同响应向浏览器发送&lt;strong&gt;响应头&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;发送完响应头后，服务器就可以继续发送&lt;strong&gt;响应体&lt;/strong&gt;的数据&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;断开连接&#34;&gt;断开连接&lt;/h2&gt;
&lt;p&gt;⼀旦服务器向客⼾端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在 其头信息中加⼊了：&lt;code&gt;Connection:Keep-Alive&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那么TCP连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同⼀个TCP连接发送请求。&lt;strong&gt;保持 TCP连接可以省去下次请求时需要建⽴连接的时间，提升资源加载速度&lt;/strong&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;重定向&#34;&gt;重定向&lt;/h3&gt;
&lt;p&gt;⽐如当你在浏览器中打开geekbang.org 后，你会发现最终打开的⻚⾯地址是 https://www.geekbang.org。&lt;/p&gt;
&lt;p&gt;这两个URL之所以不⼀样，是因为涉及到了⼀个重定向操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627811566799.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
状态301就是告诉浏览器，我需要重定向到另外⼀个⽹ 址，⽽需要重定向的⽹址正是包含在响应头的Location字段中，接下来，浏览器获取Location字段中的地 址，并使⽤该地址重新导航，这就是⼀个完整重定向的执⾏流程&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;所以为什么很多站点第二次打开速度会很快&#34;&gt;所以为什么很多站点第⼆次打开速度会很快？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DNS缓存&lt;/strong&gt;和&lt;strong&gt;⻚⾯资源缓存&lt;/strong&gt;这两块数据是 会被浏览器缓存的。&lt;/p&gt;
&lt;p&gt;DNS缓存⽐较简单，它主要就是在浏览器本地把对应的IP&lt;strong&gt;和域名关联起来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重点看下浏览器资源缓存&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627811578305.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当服务器返回HTTP响应头给浏览器时，浏览器是通过响应头中的&lt;strong&gt;Cache-Control&lt;/strong&gt;字段来设置是否缓存该资源。&lt;/p&gt;
&lt;p&gt;通过Cache-Control中的Max-age参数来设置缓存过期时间&lt;/p&gt;
&lt;p&gt;但如果缓存过期了，浏览器则会继续发起⽹络请求，并且在HTTP请求头中带上：&lt;code&gt;If-None-Match:&amp;quot;4f80f-13c-3a1xb12a&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;服务器收到请求头后，会根据If-None-Match的值来判断请求的资源是否有更新。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有更新，就返回304状态码，相当于服务器告诉浏览器：“这个缓存可以继续使⽤，这次就不重复 发送数据给你了。”&lt;/li&gt;
&lt;li&gt;如果资源有更新，服务器就直接返回最新资源给浏览器。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;登录状态是如何保持的&#34;&gt;登录状态是如何保持的？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;⽤⼾打开登录⻚⾯，在登录框⾥填⼊⽤⼾名和密码，点击确定按钮&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器接收到浏览器提交的信息校验之后，会⽣成⼀ 段表⽰⽤⼾⾝份的字符串，并把该字符串写到响应头的Set-Cookie字段⾥，如下所⽰，然后把响应头发送 给浏览器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Set-Cookie: UID=3431uad;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头⾥含有Set-Cookie字段的情况，浏 览器就会把这个字段信息保存到本地。⽐如把UID=3431uad保持到本地。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当⽤⼾再次访问时，浏览器会发起HTTP请求，但在发起请求之前，浏览器会读取之前保存的Cookie数 据，并把数据写进请求头⾥的Cookie字段⾥（如下所⽰），然后浏览器再将请求头发送给服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器在收到HTTP请求头数据之后，就会查找请求头⾥⾯的“Cookie”字段信息，当查找到包 含UID=3431uad的信息时，服务器查询后台，并判断该⽤⼾是已登录状态，然后⽣成含有该⽤⼾信息的 ⻚⾯数据，并把⽣成的数据发送给浏览器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器在接收到该含有当前⽤⼾的⻚⾯数据后，就可以正确展⽰⽤⼾登录的状态信息了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">HTTP请求流程：为什么很多站点第⼆次打开速度会很快？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/zuo-yong-yu/"" data-c="
          &lt;h2 id=&#34;类型&#34;&gt;类型&lt;/h2&gt;
&lt;p&gt;ECMAScript 变量包含：基本类型值和引用类型值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本类型值&lt;/strong&gt;指的是 简单的数据段，而&lt;strong&gt;引用类型值&lt;/strong&gt;指那些可能由多个值构成的对象。&lt;/p&gt;
&lt;p&gt;基本数据类型：Undefined、Null、Boolean、Number 和 String&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;动态属性&#34;&gt;动态属性&lt;/h3&gt;
&lt;p&gt;我们不能给基本类型的值添加属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var name = &amp;quot;Nicholas&amp;quot;; 
name.age = 27; 
alert(name.age); //undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;复制变量值&#34;&gt;复制变量值&lt;/h3&gt;
&lt;p&gt;基本类型就是值复制&lt;/p&gt;
&lt;p&gt;当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到 为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一 个对象。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;传递参数&#34;&gt;传递参数&lt;/h3&gt;
&lt;p&gt;为了证明对象是按&lt;strong&gt;值传递&lt;/strong&gt;的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function setName(obj) { 
 obj.name = &amp;quot;Nicholas&amp;quot;; 
 obj = new Object(); 
 obj.name = &amp;quot;Greg&amp;quot;; 
} 
var person = new Object(); 
setName(person); 
alert(person.name); //&amp;quot;Nicholas&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当在函数内部重写 obj 时，这 个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;检查类型&#34;&gt;检查类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var s = &amp;quot;Nicholas&amp;quot;; 
var b = true; 
var i = 22; 
var u; 
var n = null; 
var o = new Object(); 
alert(typeof s); //string 
alert(typeof i); //number 
alert(typeof b); //boolean 
alert(typeof u); //undefined 
alert(typeof n); //object 
alert(typeof o); //object
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(person instanceof Object); // 变量 person 是 Object 吗？
alert(colors instanceof Array); // 变量 colors 是 Array 吗？
alert(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有引用类型的值都是 Object 的实例。因此，在检测一个引用类型值和 Object 构造 函数时，instanceof 操作符始终会返回 true&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;执行环境及作用域&#34;&gt;执行环境及作用域&lt;/h2&gt;
&lt;p&gt;在 Web 浏览器中，全局执行环境被认为是 window 对象，因 此所有全局变量和函数都是作为 window 对象的属性和方法创建的。&lt;/p&gt;
&lt;p&gt;全局执行环境直到应用程序退 出——例如关闭网页或浏览器——时才会被销毁&lt;/p&gt;
&lt;p&gt;每个函数都有自己的&lt;strong&gt;执行环境&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当代码在一个环境中执行时，会创建变量对象的一个&lt;strong&gt;作用域链&lt;/strong&gt;（scope chain）。作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。&lt;/p&gt;
&lt;p&gt;内部环境可以通过作用域链访问所有的外部环境，但 外部环境不能访问内部环境中的任何变量和函数&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;延长作用域链&#34;&gt;延长作用域链&lt;/h3&gt;
&lt;p&gt;然执行环境的类型总共只有两种——全局和局部（函数）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;try-catch 语句的 catch 块&lt;/li&gt;
&lt;li&gt;with 语句&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function buildUrl() { 
 var qs = &amp;quot;?debug=true&amp;quot;; 
 with(location){ 
 var url = location.href + qs; 
 } 
 return url; 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with 语句接收的是 location 对象，因此其变量对象中就包含了 location 对象的所有属 性和方法，而这个变量对象被添加到了作用域链的前端&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;没有块级作用域&#34;&gt;没有块级作用域&lt;/h3&gt;
&lt;p&gt;由 for 语句创建的变量 i 即使在 for 循环执行结束后，也依旧会存在 于循环外部的执行环境中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 var 声明的变量会自动被添加到最接近的环境中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查询标识符&lt;/p&gt;
&lt;p&gt;当在某个环境中为了读取或写入而引用一个标识符时，搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。找到 了该标识符，搜索过程停止&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;垃圾收集&#34;&gt;垃圾收集&lt;/h2&gt;
&lt;p&gt;JavaScript 具有自动垃圾收集机制&lt;/p&gt;
&lt;p&gt;这种垃圾收集机制的原理其实很简单：找&lt;strong&gt;出那些不再继续使用的变 量，然后释放其占用的内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为此，垃圾收集器会按照固定的时间间隔， 周期性地执行这一操作&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;标记清除&#34;&gt;标记清除&lt;/h3&gt;
&lt;p&gt;JavaScript 中最常用的垃圾收集方式是&lt;strong&gt;标记清除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当变量进入环境时，就将这个变量标记为“进入环境”。&lt;/p&gt;
&lt;p&gt;而当变量离开环境时，则将其 标记为“离开环境”&lt;/p&gt;
&lt;p&gt;垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记 的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;引用计数&#34;&gt;引用计数&lt;/h3&gt;
&lt;p&gt;不太常见的垃圾收集策略&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用计数&lt;/strong&gt;的含义是跟踪记录每 个值被引用的次数&lt;/p&gt;
&lt;p&gt;当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1，如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这 个值了，因而就可以将其占用的内存空间回收回来。&lt;/p&gt;
&lt;br&gt;
">作用域</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tcp-xie-yi-ru-he-bao-zheng-jian-neng-bei-wan-zheng-song-da-liu-lan-qi/"" data-c="
          &lt;p&gt;衡量Web⻚⾯性能的时候有⼀个重要的指标叫“&lt;strong&gt;FP（First Paint）&lt;/strong&gt;”，是指从⻚⾯加载到⾸次开始绘制 的时⻓。影响FP指标其中⼀个重要的因素是⽹络加载速度。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;一个数据包的旅程&#34;&gt;⼀个数据包的“旅程”&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IP：把数据包送达⽬的主机&lt;/p&gt;
&lt;p&gt;数据包要在互联⽹上进⾏传输，就要符合⽹际协议（Internet Protocol，简称IP）标准。你只需要知道⼀个家庭的具体 地址，就可以往这个地址发送包裹，这样物流系统就能把物品送到⽬的地。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机的地址就称为IP地址，访问任何⽹站实际上只是你的计算机向另外⼀台计算机请求信息。&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;如果要想把⼀个数据包从主机A发送给主机B，那么在传输之前，数据包上会被附加上主机B的IP地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机A本⾝的IP地址，有了这些信息主机B 才可以回复信息给主机A。&lt;/p&gt;
&lt;p&gt;附加的信息会被装进⼀个叫IP头的数据结构⾥。&lt;/p&gt;
&lt;p&gt;IP头是IP数据包开头的信 息，包含IP版本、源IP地址、⽬标IP地址、⽣存时间等信息。&lt;/p&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP：把数据包送达应⽤程序&lt;/p&gt;
&lt;p&gt;IP是⾮常底层的协议，只负责把数据包传送到对⽅电脑，但是对⽅电脑并不知道把数据包交给哪个程序&lt;/p&gt;
&lt;p&gt;因此，需要基于IP之上开发能和应⽤打交道的协议，最常⻅的是“&lt;strong&gt;⽤⼾数据包协议&lt;/strong&gt;（User Datagram Protocol）”，简称&lt;strong&gt;UDP&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;UDP中⼀个最重要的信息是&lt;strong&gt;端⼝号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个想访问⽹络的程序都需要绑定⼀个端⼝ 号。通过端⼝号UDP就能把指定的数据包发送给指定的程序了&lt;/p&gt;
&lt;p&gt;所以&lt;strong&gt;IP&lt;/strong&gt;通过&lt;strong&gt;IP地址&lt;/strong&gt;信息把数据包发送给指定的电脑，⽽&lt;strong&gt;UDP&lt;/strong&gt;通过&lt;strong&gt;端⼝号&lt;/strong&gt;把数据包分发给正确的程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UDP头&lt;/strong&gt;中除了⽬的端⼝，还有源端⼝号等信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627717737811.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在使⽤UDP发送数据时，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是对于错误的 数据包，UDP并不提供重发机制，只是丢弃当前的包，⽽且UDP在发送之后也⽆法知道是否能达到⽬的地。&lt;/p&gt;
  &lt;br&gt;
&lt;p&gt;&lt;strong&gt;虽说UDP不能保证数据可靠性，但是传输速度却⾮常快&lt;/strong&gt;&lt;/p&gt;
  &lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP：把数据完整地送达应⽤程序&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;⽤UDP来传输会&lt;strong&gt;存在两个问题&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据包在传输过程中容易丢失&lt;/li&gt;
&lt;li&gt;⼤⽂件会被拆分成很多⼩的数据包来传输，这些⼩的数据包会经过不同的路由，并在不同的时间到达接收 端，⽽UDP协议并不知道如何组装这些数据包，从⽽把这些数据包还原成完整的⽂件。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;TCP（Transmission Control Protocol，传输控制协议）是⼀种⾯向 连接的、可靠的、基于字节流的传输层通信协议&lt;/strong&gt; 。   相对于UDP，TCP有下⾯两个特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于数据包丢失的情况，TCP提供重传机制；&lt;/li&gt;
&lt;li&gt;TCP引⼊了数据包排序机制，⽤来保证把乱序的数据包组合成⼀个完整的⽂件。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcp完整的连接过程&#34;&gt;TCP完整的连接过程&lt;/h2&gt;
&lt;p&gt;⼀个完整的TCP连接的⽣命周期包括了“&lt;strong&gt;建⽴连接&lt;/strong&gt;”“&lt;strong&gt;传输数据&lt;/strong&gt;”和“&lt;strong&gt;断开连接&lt;/strong&gt;”三个阶 段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接建立&lt;/strong&gt;。通过&amp;quot;&lt;strong&gt;三次握手&lt;/strong&gt;&amp;quot;来建立客户端和服务器端的连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传输数据阶段&lt;/strong&gt;。&lt;strong&gt;接收端需要对每个数据包进⾏确认操作&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;也就是接收端在接收到数据包 之后，需要发送确认数据包给发送端。所以当发送端发送了⼀个数据包之后，在规定时间内没有接收到接 收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;⼀个⼤的⽂件在传输过程 中会被拆分成很多⼩的数据包，这些数据包到达接收端后，接收端会按照TCP头中的序号为其排序，从⽽ 保证组成完整的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;断开连接阶段&lt;/strong&gt;。“&lt;strong&gt;四次挥⼿&lt;/strong&gt;”来保证双 ⽅都能断开连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;互联⽹中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。&lt;/li&gt;
&lt;li&gt;IP负责把数据包送达⽬的主机。&lt;/li&gt;
&lt;li&gt;UDP负责把数据包送达具体应⽤。&lt;/li&gt;
&lt;li&gt;⽽TCP保证了数据完整地传输，它的连接可分为三个阶段：建⽴连接、传输数据和断开连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​&lt;/p&gt;
">TCP协议：如何保证⻚⾯⽂件能被完整送达浏览器？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/han-shu-biao-da-shi/"" data-c="
          &lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;定义函数的 方式有两种：一种是&lt;strong&gt;函数声明&lt;/strong&gt;，另一种就是&lt;strong&gt;函数表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于函数声明，它的一个重要特征就是&lt;strong&gt;函数声明提升&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;执行以下代码的结果可 能会让人意想不到&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if(condition){ 
 function sayHi(){ 
 alert(&amp;quot;Hi!&amp;quot;); 
 } 
} else { 
 function sayHi(){ 
 alert(&amp;quot;Yo!&amp;quot;); 
 } 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这在 ECMAScript 中属于无效语法，JavaScript 引擎会尝试修正错误，将其转换为合 理的状态。大多数浏览器会返回第二个声明。&lt;/p&gt;
&lt;p&gt;修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var sayHi; 
if(condition){ 
 sayHi = function(){ 
 alert(&amp;quot;Hi!&amp;quot;); 
 }; 
} else { 
 sayHi = function(){ 
 alert(&amp;quot;Yo!&amp;quot;); 
 }; 
} 

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;递归&#34;&gt;递归&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function factorial(num){ 
 if (num &amp;lt;= 1){ 
 return 1; 
 } else { 
 return num * factorial(num-1); 
 } 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;减小耦合，但增大了内存开销。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function factorial(num){ 
 if (num &amp;lt;= 1){ 
 return 1; 
 } else { 
 return num * arguments.callee(num-1); 
 } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;闭包&#34;&gt;闭包&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;闭包&lt;/strong&gt;是指有权访问另一个 函数作用域中的变量的函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function createFunctions(){ 
 var result = new Array(); 
 for (var i=0; i &amp;lt; 10; i++){ 
 result[i] = function(){ 
 return i; 
 }; 
 } 
 return result; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以它们引用的都是同一个变量 i 。 当 createFunctions()函数返回后，变量 i 的值是 10&lt;/p&gt;
&lt;p&gt;修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function createFunctions(){ 
 var result = new Array(); 
 for (var i=0; i &amp;lt; 10; i++){ 
 result[i] = function(num){ 
 return function(){ 
 return num; 
 }; 
 }(i);
 } 
 return result; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个 匿名函数内部，又创建并返回了一个访问 num 的闭包&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;this对象&#34;&gt;this对象&lt;/h3&gt;
&lt;p&gt;匿名函数的执行环境具有&lt;strong&gt;全局性&lt;/strong&gt;，因此其 this 对象通常指向 window&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var name = &amp;quot;The Window&amp;quot;; 
var object = { 
 name : &amp;quot;My Object&amp;quot;, 
 getNameFunc : function(){ 
 return function(){ 
 return this.name; 
 }; 
 } 
}; 
alert(object.getNameFunc()()); //&amp;quot;The Window&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments。内部函 数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量&lt;/p&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var name = &amp;quot;The Window&amp;quot;; 
var object = { 
 name : &amp;quot;My Object&amp;quot;, 
 getName: function(){ 
 return this.name; 
 } 
}; 



object.getName(); //&amp;quot;My Object&amp;quot; 
(object.getName)(); //&amp;quot;My Object&amp;quot; 
(object.getName = object.getName)(); //&amp;quot;The Window&amp;quot;，
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后，就好像只 是在引用一个函数，但 this 的值得到了维持，因为 object.getName 和(object.getName)的定义 是相同的。&lt;/p&gt;
&lt;p&gt;第三行代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是 函数本身，所以 this 的值不能得到维持，结果就返回了&amp;quot;The Window&amp;quot;。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;内存泄漏&#34;&gt;内存泄漏&lt;/h3&gt;
&lt;p&gt;如果闭包的作用域链中保存着一个 HTML 元素，那么就意味着该元素将无法被销毁&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function assignHandler(){ 
 var element = document.getElementById(&amp;quot;someElement&amp;quot;); 
 element.onclick = function(){ 
 alert(element.id); 
 }; 
} 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于匿名函数保存了一个对 assignHandler()的活动对象的引用，因此 就会导致无法减少 element 的引用数&lt;/p&gt;
&lt;p&gt;修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function assignHandler(){ 
 var element = document.getElementById(&amp;quot;someElement&amp;quot;); 
 var id = element.id; 
 
 element.onclick = function(){ 
 alert(id); 
 }; 
 
 element = null; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过把 element.id 的一个副本保存在一个变量中，并且在闭包中引用该变量消 除了循环引用&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;模仿块级作用域&#34;&gt;模仿块级作用域&lt;/h2&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;(function(){ 
 //这里是块级作用域
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码定义并立即调用了一个匿名函数，可以避免命名的变量被其他地方调用&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;私有变量&#34;&gt;私有变量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;(function(){ 
    //私有变量
    var a 
    //私有函数
    function b(){
    	...  
    }
 (function(){ 
 //这里可以去调用
	})();
})();
&lt;/code&gt;&lt;/pre&gt;
"> 函数表达式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/es6-day2/"" data-c="
          &lt;h2 id=&#34;对象扩展&#34;&gt;对象扩展&lt;/h2&gt;
&lt;p&gt;ES6 一共有 5 种方法可以遍历对象的属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）for...in&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for...in&lt;/code&gt;循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）Object.keys(obj)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.keys&lt;/code&gt;返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）Object.getOwnPropertyNames(obj)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）Object.getOwnPropertySymbols(obj)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;返回一个数组，包含对象自身的所有 Symbol 属性的键名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）Reflect.ownKeys(obj)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Reflect.ownKeys&lt;/code&gt;返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;super-关键字&#34;&gt;super 关键字&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;super&lt;/code&gt;指向当前对象的原型对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const proto = {
  foo: &#39;hello&#39;
};

const obj = {
  foo: &#39;world&#39;,
  find() {
    return super.foo;
  }
};

Object.setPrototypeOf(obj, proto);
obj.find() // &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;objectis&#34;&gt;&lt;code&gt;Object.is()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.is(&#39;foo&#39;, &#39;foo&#39;)
// true
Object.is({}, {})
// false

+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;objectassign&#34;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Object.assign()&lt;/code&gt;方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const target = { a: 1 };

const source1 = { b: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Object.assign()&lt;/code&gt;方法的第一个参数是目标对象，后面的参数都是源对象。&lt;/p&gt;
&lt;p&gt;如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。&lt;/p&gt;
&lt;p&gt;如果该参数不是对象，则会先转成对象，然后返回。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;typeof Object.assign(2) // &amp;quot;object&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;上面代码中，&lt;code&gt;v1&lt;/code&gt;、&lt;code&gt;v2&lt;/code&gt;、&lt;code&gt;v3&lt;/code&gt;分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const v1 = &#39;abc&#39;;
const v2 = true;
const v3 = 10;

const obj = Object.assign({}, v1, v2, v3);
console.log(obj); // { &amp;quot;0&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;1&amp;quot;: &amp;quot;b&amp;quot;, &amp;quot;2&amp;quot;: &amp;quot;c&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;注意点&#34;&gt;注意点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;浅拷贝&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const obj1 = {a: {b: 1}};
const obj2 = Object.assign({}, obj1);

obj1.a.b = 2;
obj2.a.b // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同名属性的替换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦遇到同名属性，&lt;code&gt;Object.assign()&lt;/code&gt;的处理方法是替换，而不是添加。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const target = { a: { b: &#39;c&#39;, d: &#39;e&#39; } }
const source = { a: { b: &#39;hello&#39; } }
Object.assign(target, source)
// { a: { b: &#39;hello&#39; } }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数组的处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.assign()&lt;/code&gt;可以用来处理数组，但是会把数组视为对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.assign([1, 2, 3], [4, 5])
// [4, 5, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;Object.assign()&lt;/code&gt;把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性&lt;code&gt;4&lt;/code&gt;覆盖了目标数组的 0 号属性&lt;code&gt;1&lt;/code&gt;   这里的&lt;code&gt;key&lt;/code&gt;值就是数组的&lt;code&gt;index&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;取值函数的处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;复制函数的返回值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const source = {
  get foo() { return 1 }
};
const target = {};

Object.assign(target, source)
// { foo: 1 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;常用点&#34;&gt;常用点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为对象添加属性&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Point {  constructor(x, y) {    Object.assign(this, {x, y});  }}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为对象添加方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.assign(SomeClass.prototype, {  someMethod(arg1, arg2) {    ···  },  anotherMethod() {    ···  }});// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) {  ···};SomeClass.prototype.anotherMethod = function () {  ···};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;克隆对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。&lt;/p&gt;
&lt;p&gt;当克隆对象只有一级时候可以看做深拷贝&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function clone(origin) {  return Object.assign({}, origin);}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;合并多个对象&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const merge =  (target, ...sources) =&amp;gt; Object.assign(target, ...sources);
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为属性指定默认值&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const DEFAULTS = {  logLevel: 0,  outputFormat: &#39;html&#39;};function processContent(options) {  options = Object.assign({}, DEFAULTS, options);  console.log(options);  // ...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Object.assign()&lt;/code&gt;方法将&lt;code&gt;DEFAULTS&lt;/code&gt;和&lt;code&gt;options&lt;/code&gt;合并成一个新对象，如果两者有同名属性，则&lt;code&gt;options&lt;/code&gt;的属性值会覆盖&lt;code&gt;DEFAULTS&lt;/code&gt;的属性值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;objectgetownpropertydescriptors&#34;&gt;&lt;code&gt;Object.getOwnPropertyDescriptors()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;​			会返回某个对象属性的描述对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const obj = {  foo: 123,  get bar() { return &#39;abc&#39; }};Object.getOwnPropertyDescriptors(obj)// { foo://    { value: 123,//      writable: true,//      enumerable: true,//      configurable: true },//   bar://    { get: [Function: get bar],//      set: undefined,//      enumerable: true,//      configurable: true } }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;__proto__属性objectsetprototypeofobjectgetprototypeof&#34;&gt;__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;__proto__&lt;/code&gt;属性，用来读取或设置当前对象的原型对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// es5 的写法const obj = {  method: function() { ... }};obj.__proto__ = someOtherObj;// es6 的写法var obj = Object.create(someOtherObj);obj.method = function() { ... };
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;objectsetprototypeof&#34;&gt;&lt;code&gt;Object.setPrototypeOf()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用来设置一个对象的原型对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let proto = {};let obj = { x: 10 };Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;objectgetprototypeof&#34;&gt;&lt;code&gt;Object.getPrototypeOf()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于读取一个对象的原型对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Rectangle() {  // ...}const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;objectkeysobjectvaluesobjectentries&#34;&gt;Object.keys()，Object.values()，Object.entries()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Object.keys&lt;/code&gt;方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = { foo: &#39;bar&#39;, baz: 42 };Object.keys(obj)// [&amp;quot;foo&amp;quot;, &amp;quot;baz&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;Object.values&lt;/code&gt;方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const obj = { foo: &#39;bar&#39;, baz: 42 };Object.values(obj)// [&amp;quot;bar&amp;quot;, 42]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;Object.entries()&lt;/code&gt;方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const obj = { foo: &#39;bar&#39;, baz: 42 };Object.entries(obj)// [ [&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;], [&amp;quot;baz&amp;quot;, 42] ]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
">ES6 day2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-yin-yong-lei-xing/"" data-c="
          &lt;h2 id=&#34;object&#34;&gt;Object&lt;/h2&gt;
&lt;h3 id=&#34;表示方法&#34;&gt;表示方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;new 操作符后跟 Object 构造函数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var person = new Object();&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用对象字面量表示法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var person = { name : &amp;quot;Nicholas&amp;quot;, age : 29 };&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;访问方式&#34;&gt;访问方式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;alert(person[&amp;quot;name&amp;quot;]); //&amp;quot;Nicholas&amp;quot; 

alert(person.name); //&amp;quot;Nicholas&amp;quot; 

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;array&#34;&gt;Array&lt;/h2&gt;
&lt;h3 id=&#34;表示形式&#34;&gt;表示形式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var colors = new Array(20);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var colors = new Array(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var colors = [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;];&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;检查数组&#34;&gt;检查数组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if (value instanceof Array){ //对数组执行某些操作 }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array.isArray()方法&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.prototype.tostring.call(this)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;转换方法&#34;&gt;转换方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;alert(colors.toString()); // red,blue,green&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alert(colors.valueOf()); // red,blue,green&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alert(colors); // red,blue,green&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id=&#34;join&#34;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var colors = [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;]; 
alert(colors.join(&amp;quot;,&amp;quot;)); //red,green,blue 
alert(colors.join(&amp;quot;||&amp;quot;)); //red||green||blue 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;pop-push-shift-unshift&#34;&gt;&lt;code&gt;pop() push() shift() unshift()&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var colors = new Array(); //创建一个数组
var count = colors.unshift(&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;);
count = colors.unshift(&amp;quot;black&amp;quot;); 

//数组中各项的顺序为&amp;quot;black&amp;quot;、&amp;quot;red&amp;quot;、&amp;quot;green&amp;quot;。

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;重排序方法&#34;&gt;重排序方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reverse()&lt;/code&gt;会反转数组项的顺序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var values = [1, 2, 3, 4, 5]; 
values.reverse(); 
alert(values); //5,4,3,2,1
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;sort()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以 确定如何排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var values = [0, 1, 5, 10, 15]; 
values.sort(); 
alert(values); //0,1,10,15,5 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改造&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var values = [0, 1, 5, 10, 15]; 
values.sort((a,b)=&amp;gt;{
    return a-b
}); 
alert(values); //0,1,5,10,15 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;操作方法&#34;&gt;操作方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;concat()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个方法会先创建当前数组一个副本，然后将接收到的参数 添加到这个副本的末尾，最后返回新构建的数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var colors = [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;]; 
var colors2 = colors.concat(&amp;quot;yellow&amp;quot;, [&amp;quot;black&amp;quot;, &amp;quot;brown&amp;quot;]); 

alert(colors); //red,green,blue 
alert(colors2); //red,green,blue,yellow,black,brown 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;splice()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一参数是开始位置&lt;/li&gt;
&lt;li&gt;第二个参数是删除项&lt;/li&gt;
&lt;li&gt;第三个参数是从开始位置往后插入项&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var colors = [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;];

colors.splice(1, 1, &amp;quot;red&amp;quot;, &amp;quot;purple&amp;quot;); 

alert(colors); // red,red,purple,blue 

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;位置方法&#34;&gt;位置方法&lt;/h3&gt;
&lt;h3 id=&#34;indexof-lastindexof&#34;&gt;&lt;code&gt;indexOf() lastIndexOf()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;indexOf()&lt;/code&gt;查找到第一个符合的返回index，未找到为-1&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lastIndexOf()&lt;/code&gt;查找到最后一个符合的返回index，未找到为-1&lt;/p&gt;
&lt;p&gt;第一个参数为查找对象 第二个参数为开始位置&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;迭代方法&#34;&gt;迭代方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。&lt;/li&gt;
&lt;li&gt;filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。&lt;/li&gt;
&lt;li&gt;forEach()：对数组中的每一项运行给定函数。这个方法没有返回值&lt;/li&gt;
&lt;li&gt;map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。&lt;/li&gt;
&lt;li&gt;some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var numbers = [1,2,3,4,5,4,3,2,1]; 
var mapResult = numbers.map(function(item, index, array){ 
 return item * 2; 
}); 
alert(mapResult); //[2,4,6,8,10,8,6,4,2] 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;归并方法&#34;&gt;归并方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reduce() redunceRight()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;reduce()方法从数组的第一项开始，逐个遍历 到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var values = [1,2,3,4,5]; 
var sum = values.reduce(function(prev, cur, index, array){ 
 return prev + cur; 
}); 
alert(sum); //15 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;date类型&#34;&gt;Date类型&lt;/h2&gt;
&lt;p&gt;创建&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var now = new Date();&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 本地时间 2000 年 1 月 1 日午夜零时
var y2k = new Date(2000, 0); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Date.parse()&lt;/code&gt;接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日 期的毫秒数&lt;/p&gt;
&lt;p&gt;Date 类型的 toLocaleString()方法会按照与浏览器 设置的地区相适应的格式返回日期和时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1627622953316.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;!&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;function&#34;&gt;Function&lt;/h2&gt;
&lt;p&gt;无重载&lt;/p&gt;
&lt;p&gt;一个函数可以作为另一个函数的参数传递&lt;/p&gt;
&lt;p&gt;函数内部属性&lt;code&gt;arguments&lt;/code&gt;  和  &lt;code&gt;this&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;arguments 的主要用途是保存函数参数&lt;/p&gt;
&lt;p&gt;这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;函数内部属性&#34;&gt;函数内部属性&lt;/h3&gt;
&lt;p&gt;这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;window.color = &amp;quot;red&amp;quot;; 
var o = { color: &amp;quot;blue&amp;quot; }; 
function sayColor(){ 
 alert(this.color); 
} 
sayColor(); //&amp;quot;red&amp;quot; 
o.sayColor = sayColor; 
o.sayColor(); //&amp;quot;blue&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;函数属性和方法&#34;&gt;函数属性和方法&lt;/h3&gt;
&lt;p&gt;每个函数都包含两个 属性：length 和 prototype&lt;/p&gt;
&lt;p&gt;length 属性表示函数希望接收的命名参数的个数&lt;/p&gt;
&lt;p&gt;prototype 属性是不可枚举的，因此使用 for-in 无法发现&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;每个函数都包含两个非继承而来的方法：apply()和 call()。&lt;/p&gt;
&lt;p&gt;apply()方法接收两个参数：一个 是在其中运行函数的作用域，另一个是参数数组&lt;/p&gt;
&lt;p&gt;call()第一个参数是 this 值，其余参数都直接传递给函数&lt;/p&gt;
&lt;p&gt;真正强大的地方是能够扩充函数 赖以运行的作用域&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;window.color = &amp;quot;red&amp;quot;; 
var o = { color: &amp;quot;blue&amp;quot; }; 
function sayColor(){ 
 alert(this.color); 
} 
sayColor(); //red 
sayColor.call(this); //red 
sayColor.call(window); //red 
sayColor.call(o); //blue 
&lt;/code&gt;&lt;/pre&gt;
">JS引用类型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/es6-kai-pian/"" data-c="
          &lt;p&gt;&lt;code&gt;let&lt;/code&gt; 暂时性死区&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var tmp = 123;

if (true) {
  tmp = &#39;abc&#39;; // ReferenceError
  let tmp;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;主要注意数组，对象内部值的改变&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.freeze&lt;/code&gt;对象冻结&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;字符串拓展&#34;&gt;字符串拓展&lt;/h2&gt;
&lt;p&gt;模板字符串&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;`Hello ${name}, how are you ${time}?`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模板编译&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let template = `
&amp;lt;ul&amp;gt;
  &amp;lt;% for(let i=0; i &amp;lt; data.supplies.length; i++) { %&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;%= data.supplies[i] %&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;% } %&amp;gt;
&amp;lt;/ul&amp;gt;
`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;&amp;lt;%= ... %&amp;gt;&lt;/code&gt;输出 JavaScript 表达式。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;includes&#34;&gt;&lt;code&gt;includes()&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;includes()&lt;/strong&gt;：返回布尔值，表示是否找到了参数字符串。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;startsWith()&lt;/strong&gt;：返回布尔值，表示参数字符串是否在原字符串的头部。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;endsWith()&lt;/strong&gt;：返回布尔值，表示参数字符串是否在原字符串的尾部&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let s = &#39;Hello world!&#39;;

s.startsWith(&#39;Hello&#39;) // true
s.endsWith(&#39;!&#39;) // true
s.includes(&#39;o&#39;) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这三个方法都支持第二个参数，表示开始搜索的位置。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;repeat&#34;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;repeat&lt;/code&gt;方法返回一个新字符串，表示将原字符串重复&lt;code&gt;n&lt;/code&gt;次。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#39;x&#39;.repeat(3) // &amp;quot;xxx&amp;quot;
&#39;hello&#39;.repeat(2) // &amp;quot;hellohello&amp;quot;
&#39;na&#39;.repeat(0) // &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;padstarpadend&#34;&gt;&lt;code&gt;padStar()，padEnd()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;padStart()&lt;/code&gt;用于头部补全，&lt;code&gt;padEnd()&lt;/code&gt;用于尾部补全。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;
&#39;x&#39;.padStart(4, &#39;ab&#39;) // &#39;abax&#39;

&#39;x&#39;.padEnd(5, &#39;ab&#39;) // &#39;xabab&#39;
&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;trimstarttrimend&#34;&gt;&lt;code&gt;trimStart()，trimEnd()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;trim()&lt;/code&gt;方法的分解版&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const s = &#39;  abc  &#39;;

s.trim() // &amp;quot;abc&amp;quot;
s.trimStart() // &amp;quot;abc  &amp;quot;
s.trimEnd() // &amp;quot;  abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;replaceall&#34;&gt;&lt;code&gt;replaceAll()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;replace&lt;/code&gt;只替换第一匹配的&lt;/p&gt;
&lt;p&gt;这个替换所以匹配的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#39;aabbcc&#39;.replace(/b/g, &#39;_&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;函数拓展&#34;&gt;函数拓展&lt;/h2&gt;
&lt;p&gt;ES6默认值的加入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Point(x = 0, y = 0) {
  this.x = x;
  this.y = y;
  //参数变量是默认声明的，所以不能用let或const再次声明。
  let x = 1; // error
}

const p = new Point();
p // { x: 0, y: 0 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解构赋值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区别&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;rest参数&#34;&gt;rest参数&lt;/h3&gt;
&lt;p&gt;rest 参数代替&lt;code&gt;arguments&lt;/code&gt;变量的例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) =&amp;gt; numbers.sort();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;arguments&lt;/code&gt;对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用&lt;code&gt;Array.prototype.slice.call&lt;/code&gt;先将其转为数组.rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意，rest 参数之后不能再有其他参数&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;name属性&#34;&gt;name属性&lt;/h3&gt;
&lt;p&gt;函数的&lt;code&gt;name&lt;/code&gt;属性，返回该函数的函数名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function foo() {}
foo.name // &amp;quot;foo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;箭头函数&#34;&gt;箭头函数&lt;/h3&gt;
&lt;p&gt;一行代码的情况&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 普通函数写法
var result = values.sort(function (a, b) {
  return a - b;
});

// 箭头函数写法
var result = values.sort((a, b) =&amp;gt; a - b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）箭头函数没有自己的&lt;code&gt;this&lt;/code&gt;对象，内部的&lt;code&gt;this&lt;/code&gt;就是定义时上层作用域中的&lt;code&gt;this&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（2）不可以当作构造函数，也就是说，不可以对箭头函数使用&lt;code&gt;new&lt;/code&gt;命令，否则会抛出一个错误。&lt;/p&gt;
&lt;p&gt;（3）不可以使用&lt;code&gt;arguments&lt;/code&gt;对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。&lt;/p&gt;
&lt;p&gt;（4）不可以使用&lt;code&gt;yield&lt;/code&gt;命令，因此箭头函数不能用作 Generator 函数。&lt;/p&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function foo() {
  setTimeout(() =&amp;gt; {
    console.log(&#39;id:&#39;, this.id);
  }, 100);
}

var id = 21;

foo.call({ id: 42 });
// id: 42
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;箭头函数导致&lt;code&gt;this&lt;/code&gt;总是指向函数定义生效时所在的对象，所以打印42&lt;/p&gt;
&lt;p&gt;对象的属性建议使用传统的写法定义，不要用箭头函数定义。&lt;/p&gt;
&lt;h3 id=&#34;尾调用-递归&#34;&gt;尾调用 、递归&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function f(x){
  return g(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非尾递归的 Fibonacci 数列实现如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Fibonacci (n) {
  if ( n &amp;lt;= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 超时
Fibonacci(500) // 超时
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尾递归优化过的 Fibonacci 数列实现如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n &amp;lt;= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;数组拓展&#34;&gt;数组拓展&lt;/h3&gt;
&lt;p&gt;数组克隆&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a1 = [1, 2];
// 写法一
const a2 = [...a1];
// 写法二
const [...a2] = a1;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;数组合并&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const arr1 = [&#39;a&#39;, &#39;b&#39;];
const arr2 = [&#39;c&#39;];
const arr3 = [&#39;d&#39;, &#39;e&#39;];

// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]

// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;arraryfron&#34;&gt;&lt;code&gt;Arrary.fron()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;类数组的转换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let arrayLike = {
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

// ES6的写法
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;arrayof&#34;&gt;&lt;code&gt;Array.of()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于将一组值，转换为数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Array()&lt;/code&gt;方法没有参数、一个参数、三个参数时，返回的结果都不一样。只有当参数个数不少于 2 个时，&lt;code&gt;Array()&lt;/code&gt;才会返回由参数组成的新数组。参数只有一个正整数时，实际上是指定数组的长度。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;copywithin&#34;&gt;&lt;code&gt;copyWithin()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;使用这个方法，会修改当前数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Array.prototype.copyWithin(target, start = 0, end = this.length)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它接受三个参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;target（必需）：从该位置开始替换数据。如果为负值，表示倒数。&lt;/li&gt;
&lt;li&gt;start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。&lt;/li&gt;
&lt;li&gt;end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/ 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call({length: 5, 3: 1}, 0, 3)
// {0: 1, 3: 1, length: 5}

// 将2号位到数组结束，复制到0号位
let i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);
// Int32Array [3, 4, 5, 4, 5]

// 对于没有部署 TypedArray 的 copyWithin 方法的平台
// 需要采用下面的写法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
// Int32Array [4, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;find和findindex&#34;&gt;&lt;code&gt;find()&lt;/code&gt;和&lt;code&gt;findIndex()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;find&lt;/code&gt;方法，用于找出第一个符合条件的数组成员。如果没有符合条件的成员，则返回&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1, 4, -5, 10].find((n) =&amp;gt; n &amp;lt; 0)
// -5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;findIndex&lt;/code&gt;方法的用法与&lt;code&gt;find&lt;/code&gt;方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回&lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value &amp;gt; 9;
}) // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;fill&#34;&gt;&lt;code&gt;fill()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;fill&lt;/code&gt;方法使用给定值，填充一个数组。用于空数组的初始化非常方便。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fill&lt;/code&gt;方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;includes-2&#34;&gt;&lt;code&gt;includes()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;返回一个布尔值，表示某个数组是否包含给定的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;flag-flagmap&#34;&gt;&lt;code&gt;flag()&lt;/code&gt; 、&lt;code&gt;flagMap()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;flat()&lt;/code&gt;默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将&lt;code&gt;flat()&lt;/code&gt;方法的参数写成一个整数，表示想要拉平的层数，默认为1。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]


//如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。
[1, [2, [3]]].flat(Infinity)
// [1, 2, 3]

//如果原数组有空位，flat()方法会跳过空位。
[1, 2, , 4, 5].flat()
// [1, 2, 4, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;flatMap()&lt;/code&gt;方法对原数组的每个成员执行一个函数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flatMap()&lt;/code&gt;只能展开一层数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()
[1, 2, 3, 4].flatMap(x =&amp;gt; [[x * 2]])
// [[2], [4], [6], [8]]
&lt;/code&gt;&lt;/pre&gt;
">ES6开篇</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-wen-dang-cha-jian/"" data-c="
          &lt;p&gt;插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加全局方法或者 property。如：&lt;a href=&#34;https://github.com/karol-f/vue-custom-element&#34;&gt;vue-custom-element&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;添加全局资源：指令/过滤器/过渡等。如 &lt;a href=&#34;https://github.com/vuejs/vue-touch&#34;&gt;vue-touch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;通过全局混入来添加一些组件选项。如 &lt;a href=&#34;https://github.com/vuejs/vue-router&#34;&gt;vue-router&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;添加 Vue 实例方法，通过把它们添加到 &lt;code&gt;Vue.prototype&lt;/code&gt; 上实现。&lt;/li&gt;
&lt;li&gt;一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Vue.use()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它需要在你调用 &lt;code&gt;new Vue()&lt;/code&gt; 启动应用之前完成：&lt;/p&gt;
&lt;p&gt;有些组件经常会用这个去注册&lt;/p&gt;
&lt;p&gt;主要因为其中注册的组件都有一个叫 &lt;code&gt;install&lt;/code&gt; 的方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vue.use&lt;/code&gt; 会自动阻止多次注册相同插件&lt;/p&gt;
&lt;p&gt;Vue.use()会默认调用这个方法去注册，同时传一个 Vue 这个类的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 引入组件
import LoadingComponent from &#39;./loading.vue&#39;
// 定义 Loading 对象
const Loading={
    // install 是默认的方法。当外界在 use 这个组件的时候，就会调用本身的 install 方法，同时传一个 Vue 这个类的参数。
    install:function(Vue){
        Vue.component(&#39;Loading&#39;,LoadingComponent)
    }
}
// 导出
export default Loading
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;Vue.mixin()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vue中提供了一种混合机制--mixins，用来更高效的实现组件内容的复用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;组件在引用之后相当于&lt;strong&gt;在父组件内开辟了一块单独的空间&lt;/strong&gt;，来根据父组件props过来的值进行相应的操作，单本质上两者还是&lt;strong&gt;泾渭分明&lt;/strong&gt;，相对独立。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let mixin={
    data(){
        return{
            msg:1
        }
    },
    methods:{
        foo(){
            console.log(&#39;hello from mixin!----&#39;+this.msg++)
        }
    }
}
var child=Vue.component(&#39;child&#39;,{ 
        template:`&amp;lt;h1 @click=&amp;quot;foo&amp;quot;&amp;gt;child component&amp;lt;/h1&amp;gt;`, 
        mixins:[mixin]
})
Vue.component(&#39;kid&#39;,{ 
        template:`&amp;lt;h1 @click=&amp;quot;foo&amp;quot;&amp;gt;kid component&amp;lt;/h1&amp;gt;`, 
        mixins:[mixin]
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但引入的都是开辟独立空间的一块内存，所以不会共用，类似把有相同的方法和属性共享写出去。&lt;/p&gt;
&lt;h2 id=&#34;方法的覆盖&#34;&gt;方法的覆盖&lt;/h2&gt;
&lt;p&gt;如果在引用mixins的同时，在组件中重复定义相同的方法，则mixins中的方法会被覆盖。&lt;/p&gt;
&lt;h2 id=&#34;合并生命周期&#34;&gt;合并生命周期&lt;/h2&gt;
&lt;p&gt;与组件里面的生命周期会进行合并&lt;/p&gt;
"> Vue文档 插件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/a-li-yun-bu-shu-node-xiang-mu/"" data-c="
          &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;下载node和npm并且配置环境变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载数据库并本地连接导入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载Nginx并配置反向代理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载pm2挂载node&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;http://139.196.87.221&#34;&gt;fanfan的停车场网址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://fanfankill.github.io/post/vuenodejsmysql-kai-fa-ting-che-chang-guan-li-xi-tong/&#34;&gt;项目介绍博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前部分功能上线以后有问题，正在整改中，vue路由改为hash模式，因为后端暂时没有去做路由配置。&lt;/p&gt;
&lt;p&gt;支持自己注册，邀请码暂时没有限制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;测试账号：19198001091

测试密码：20010620
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;项目需要改进的点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首次加载过慢，未优化性能 （好像只能谷歌进？）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;头像加载有问题 （头像接口已改 目前在研究如何优化这个接口）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;某些接口上线以后出现问题，无法交互（可能数据库版本问题）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取临时车接口问题 报错显示group by语句有误 （线下都好好的）已修复&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;续费接口问题 报错插入的时间格式不正确  用的moment.js计算的时间，果然线下线上差别还是有点大&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ER_TRUNCATED_WRONG_VALUE: Incorrect datetime value: &#39;2023-08-07T16:37:39+08:00&#39; for column &#39;DueDate&#39; at&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;row 1&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间问题解决 改成标准的&lt;code&gt;&#39;YYYY-MM-DD HH:mm:ss&#39;&lt;/code&gt;模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;聊天系统暂时没优化，做了个雏形出来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;自己第一次部署项目，碰到无数的坑，这里总结出了我碰到的坑和找到的好资源&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;没头绪的小伙伴点击这里  &lt;a href=&#34;https://www.bilibili.com/video/BV1n54y1V7Ne?p=21&#34;&gt;B站老师教学&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个老师讲的很详细，但不免自己会遇到一些坑，根据这个视频的讲解配上下面的博客链接可以让自己少走点弯路。&lt;/p&gt;
&lt;p&gt;准备好一个云服务器和连接工具(我用的xshell)&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;配置node和npm&#34;&gt;配置node和npm&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/huangenai/p/10815426.html&#34;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要配置环境变量&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;数据库的配置连接&#34;&gt;数据库的配置连接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jb51.net/article/190714.htm&#34;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一定养成 &lt;code&gt;# ls&lt;/code&gt;查看目录的习惯，这里下载的mysql版本有点低，建议自己去官网下载，如果你自己本地数据库版本过高，是导入不进去阿里云服务器的。&lt;/p&gt;
&lt;p&gt;我是navicat远程连接的数据库，sql文件一直导入不进去就是因为版本的问题&lt;/p&gt;
&lt;p&gt;如有导入出错的，尝试改sql文件中以下内容&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;utf8mb4_0900_ai_ci&lt;/code&gt; 改为&lt;code&gt;utf8_general_ci&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;utf8mb4&lt;/code&gt;改为&lt;code&gt;utf8&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;还有每次更新数据库版本先要卸载当前版本，不然一直给你抛错。&lt;/p&gt;
&lt;p&gt;记得在阿里云开启安全组&lt;strong&gt;3306&lt;/strong&gt;的端口&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;nginx配置&#34;&gt;Nginx配置&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_42815754/article/details/82980326&#34;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nginx默认80端口，阿里云安全组也记得要打开&lt;/p&gt;
&lt;p&gt;proxy_pass  http://127.0.0.1:3000  //这是需要改的东西 最后的端口号依自己的来&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;pm2配置&#34;&gt;PM2配置&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/panbingwen/p/11664175.html&#34;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_43442102/article/details/100544399&#34;&gt;什么是PM2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置后应该就可以随时访问了&lt;/p&gt;
"> 阿里云部署node项目</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/suan-fa/"" data-c="
          &lt;h2 id=&#34;连续子数组的最大和&#34;&gt;&lt;strong&gt;连续子数组的最大和&lt;/strong&gt;&lt;/h2&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    function FindGreatestSumOfSubArray(array)
    {
       
        let temp=0
        let max=-99999
        let arr=[]

        for(let i=0;i&amp;lt;array.length;i++)
        {
            
            temp+=array[i]
            arr.push(array[i])
            if(temp&amp;gt;max)
            {
                max=temp
            }
            if(temp&amp;lt;0){
                temp=0
                arr=[]
            }
              
        }
        return max
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;数组中出现次数超过一半的数字&#34;&gt;&lt;strong&gt;数组中出现次数超过一半的数字&lt;/strong&gt;&lt;/h2&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function MoreThanHalfNum_Solution(numbers)
{
     
     //先排序
        numbers.sort(function (a, b) {
            return a - b
        })
        console.log(numbers);

        let flag = 0
        let count = 0
        let number
       if(numbers.length==1)
       {
           return numbers[0]
       }
       else{
        for (let i = 0; i &amp;lt; numbers.length - 1; i++) {
            if (numbers[i] == numbers[i + 1]) {
                count++

                if (count &amp;gt; flag) {

                    flag = count
                    count = 0
                    number = numbers[i]
                }
           

            }
            else {
                count = 0

            }


        }
        return number
       }
   
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;合并两个排序的链表&#34;&gt;&lt;strong&gt;合并两个排序的链表&lt;/strong&gt;&lt;/h2&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Merge(pHead1, pHead2)
{ // write code here
     
    if (pHead1 == null) {
        return pHead2;
    } else if (pHead2 == null) {
        return pHead1;
    }
    var result = {};
    if (pHead1.val &amp;lt; pHead2.val) {
        result = pHead1;
        result.next = Merge(pHead1.next, pHead2);
    } else {
        result = pHead2;
        result.next = Merge(pHead1, pHead2.next);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
">算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/shen-qian-kao-bei/"" data-c="
          &lt;ul&gt;
&lt;li&gt;基本数据类型的特点：直接存储在栈(stack)中的数据&lt;/li&gt;
&lt;li&gt;引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;浅拷贝&#34;&gt;浅拷贝&lt;/h2&gt;
&lt;p&gt;对象的直接赋值&lt;/p&gt;
&lt;p&gt;obj1=obj2&lt;/p&gt;
&lt;h2 id=&#34;深拷贝&#34;&gt;深拷贝&lt;/h2&gt;
&lt;p&gt;JSON.parse() 与 JSON.Stringify()&lt;/p&gt;
&lt;p&gt;先转化为字符串然后再转化为JS对象，相当于另外开辟了一块空间&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  var clone = function (obj) {

       return JSON.parse(JSON.stringify(obj));
        } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法只适用于&lt;strong&gt;纯数据json对象的深度克隆&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
普用方法
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  var clone = function (obj) {

                    if(obj === null) return null

                    if(typeof obj !== &#39;object&#39;) return obj;

                    if(obj.constructor===Date) return new Date(obj);

                    if(obj.constructor === RegExp) return new RegExp(obj);

                     var newObj = new obj.constructor ();  //保持继承链

                    for (var key in obj) {

                            if (obj.hasOwnProperty(key)) {  //不遍历其原型链上的属性

                            var val = obj[key];

                            newObj[key] = typeof val === &#39;object&#39; ? arguments.callee(val) : val; // 使用arguments.callee解除与函数名的耦合

                           }

                } 

                return newObj; 

        };


&lt;/code&gt;&lt;/pre&gt;
">深浅拷贝</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-wen-dang-4-cha-cao/"" data-c="
          &lt;h2 id=&#34;插槽&#34;&gt;插槽&lt;/h2&gt;
&lt;p&gt;合成组件  里面可以包括HTML片段，其他组件等&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;navigation-link url=&amp;quot;/profile&amp;quot;&amp;gt;
  Your Profile
&amp;lt;/navigation-link&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;组件写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;  v-bind:href=&amp;quot;url&amp;quot;
  class=&amp;quot;nav-link&amp;quot;
&amp;gt;
  &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;编辑作用域&#34;&gt;编辑作用域&lt;/h2&gt;
&lt;p&gt;插槽中使用数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;navigation-link url=&amp;quot;/profile&amp;quot;&amp;gt;
  Logged in as {{ user.name }}
&amp;lt;/navigation-link&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该插槽跟模板的其它地方一样可以访问相同的实例 property&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;不能&lt;/strong&gt;访问 &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; 的作用域，例如上面的 &lt;code&gt;url&lt;/code&gt; 是访问不到的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;后备内容&#34;&gt;后备内容&lt;/h2&gt;
&lt;p&gt;等于默认渲染，它只会在没有提供内容的时候被渲染 ，例如在一个 &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; 组件中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;
  &amp;lt;slot&amp;gt;Submit&amp;lt;/slot&amp;gt;
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在当我在一个父级组件中使用 &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; 并且不提供任何插槽内容时：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;submit-button&amp;gt;&amp;lt;/submit-button&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;后备内容“Submit”将会被渲染：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;
  Submit
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但如果提供内容就会替代插槽里面的后备内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;submit-button&amp;gt;
  Save
&amp;lt;/submit-button&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;具名插槽&#34;&gt;具名插槽&lt;/h2&gt;
&lt;p&gt;有时我们需要多个插槽&lt;/p&gt;
&lt;p&gt;有时我们需要多个插槽。例如对于一个带有如下模板的 &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; 组件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
  &amp;lt;header&amp;gt;
    &amp;lt;!-- 我们希望把页头放这里 --&amp;gt;
  &amp;lt;/header&amp;gt;
  &amp;lt;main&amp;gt;
    &amp;lt;!-- 我们希望把主要内容放这里 --&amp;gt;
  &amp;lt;/main&amp;gt;
  &amp;lt;footer&amp;gt;
    &amp;lt;!-- 我们希望把页脚放这里 --&amp;gt;
  &amp;lt;/footer&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 元素有一个特殊的 attribute：&lt;code&gt;name&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
  &amp;lt;header&amp;gt;
    &amp;lt;slot name=&amp;quot;header&amp;quot;&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/header&amp;gt;
  &amp;lt;main&amp;gt;
    &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/main&amp;gt;
  &amp;lt;footer&amp;gt;
    &amp;lt;slot name=&amp;quot;footer&amp;quot;&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/footer&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个不带 &lt;code&gt;name&lt;/code&gt; 的 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 出口会带有隐含的名字“default”。&lt;/p&gt;
&lt;p&gt;我们可以在一个 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元素上使用 &lt;code&gt;v-slot&lt;/code&gt; 指令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;base-layout&amp;gt;  &amp;lt;template v-slot:header&amp;gt;    &amp;lt;h1&amp;gt;Here might be a page title&amp;lt;/h1&amp;gt;  &amp;lt;/template&amp;gt;  &amp;lt;p&amp;gt;A paragraph for the main content.&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;And another one.&amp;lt;/p&amp;gt;  &amp;lt;template v-slot:footer&amp;gt;    &amp;lt;p&amp;gt;Here&#39;s some contact info&amp;lt;/p&amp;gt;  &amp;lt;/template&amp;gt;&amp;lt;/base-layout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 &lt;code&gt;v-slot&lt;/code&gt; 的 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 中的内容都会被视为默认插槽的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; 只能添加在 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 上&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;作用域插槽&#34;&gt;作用域插槽&lt;/h2&gt;
&lt;p&gt;因为从父级传来的值在插槽子级是不可以直接访问的&lt;/p&gt;
&lt;p&gt;子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;span&amp;gt;  &amp;lt;slot&amp;gt;{{ user.lastName }}&amp;lt;/slot&amp;gt;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;current-user&amp;gt;  {{ user.firstName }}&amp;lt;/current-user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以用到了&lt;strong&gt;插槽 prop&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;span&amp;gt;  &amp;lt;slot v-bind:user=&amp;quot;user&amp;quot;&amp;gt;    {{ user.lastName }}  &amp;lt;/slot&amp;gt;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;v-slot&lt;/code&gt; 来定义我们提供的插槽 prop 的名字&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;current-user&amp;gt;  &amp;lt;template v-slot:default=&amp;quot;slotProps&amp;quot;&amp;gt;    {{ slotProps.user.firstName }}  &amp;lt;/template&amp;gt;&amp;lt;/current-user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;独占默认插槽的缩写语法&#34;&gt;独占默认插槽的缩写语法&lt;/h3&gt;
&lt;p&gt;当只有默认插槽时候可以简写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;current-user v-slot=&amp;quot;slotProps&amp;quot;&amp;gt;  {{ slotProps.user.firstName }}&amp;lt;/current-user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只要出现多个插槽，请始终为&lt;em&gt;所有的&lt;/em&gt;插槽使用完整的基于 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 的语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;current-user&amp;gt;  &amp;lt;template v-slot:default=&amp;quot;slotProps&amp;quot;&amp;gt;    {{ slotProps.user.firstName }}  &amp;lt;/template&amp;gt;  &amp;lt;template v-slot:other=&amp;quot;otherSlotProps&amp;quot;&amp;gt;    ...  &amp;lt;/template&amp;gt;&amp;lt;/current-user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解构插槽prop&#34;&gt;解构插槽Prop&lt;/h3&gt;
&lt;p&gt;作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里：&lt;/p&gt;
&lt;p&gt;使用 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E8%A7%A3%E6%9E%84%E5%AF%B9%E8%B1%A1&#34;&gt;ES2015 解构&lt;/a&gt;来传入具体的插槽 prop&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;current-user v-slot=&amp;quot;{ user }&amp;quot;&amp;gt;  {{ user.firstName }}&amp;lt;/current-user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;动态插槽名&#34;&gt;动态插槽名&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;base-layout&amp;gt;  &amp;lt;template v-slot:[dynamicSlotName]&amp;gt;    ...  &amp;lt;/template&amp;gt;&amp;lt;/base-layout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;具名插槽的缩写&#34;&gt;具名插槽的缩写&lt;/h2&gt;
&lt;p&gt;把参数之前的所有内容 (&lt;code&gt;v-slot:&lt;/code&gt;) 替换为字符 &lt;code&gt;#&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如 &lt;code&gt;v-slot:header&lt;/code&gt; 可以被重写为 &lt;code&gt;#header&lt;/code&gt;&#39;&lt;/p&gt;
"> Vue文档4 插槽</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-wen-dang-3/"" data-c="
          &lt;h2 id=&#34;prop&#34;&gt;Prop&lt;/h2&gt;
&lt;p&gt;字符串数组形式列出的 prop：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;props: [&#39;title&#39;, &#39;likes&#39;, &#39;isPublished&#39;, &#39;commentIds&#39;, &#39;author&#39;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;prop 各自的名称和类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;传递静态或动态-prop&#34;&gt;传递静态或动态 Prop&lt;/h2&gt;
&lt;p&gt;给 prop 传入一个静态的值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;blog-post title=&amp;quot;My journey with Vue&amp;quot;&amp;gt;&amp;lt;/blog-post&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;prop 可以通过 &lt;code&gt;v-bind&lt;/code&gt; 动态赋值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!-- 动态赋予一个变量的值 --&amp;gt;
&amp;lt;blog-post v-bind:title=&amp;quot;post.title&amp;quot;&amp;gt;&amp;lt;/blog-post&amp;gt;

&amp;lt;!-- 动态赋予一个复杂表达式的值 --&amp;gt;
&amp;lt;blog-post
  v-bind:title=&amp;quot;post.title + &#39; by &#39; + post.author.name&amp;quot;
&amp;gt;&amp;lt;/blog-post&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要 &lt;code&gt;v-bind&lt;/code&gt; 来告诉 Vue 这是一个 JavaScript 表达式而不是一个字符串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传入数字&lt;/li&gt;
&lt;li&gt;传入布尔值&lt;/li&gt;
&lt;li&gt;传入数组&lt;/li&gt;
&lt;li&gt;传入对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;单向数据流&#34;&gt;单向数据流&lt;/h2&gt;
&lt;p&gt;所有的 prop 都使得其父子 prop 之间形成了一个&lt;strong&gt;单向下行绑定&lt;/strong&gt;：父级 prop 的更新会向下流动到子组件中，但是反过来则不行，这样会&lt;strong&gt;防止从子组件意外变更父级组件的状态&lt;/strong&gt;，从而导致你的应用的数据流向难以理解。&lt;/p&gt;
&lt;p&gt;每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你&lt;strong&gt;不&lt;/strong&gt;应该在一个子组件内部改变 prop&lt;/p&gt;
&lt;p&gt;注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身&lt;strong&gt;将会&lt;/strong&gt;影响到父组件的状态。&lt;/p&gt;
&lt;h2 id=&#34;prop-验证&#34;&gt;Prop 验证&lt;/h2&gt;
&lt;p&gt;例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Vue.component(&#39;my-component&#39;, {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: &#39;hello&#39; }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].indexOf(value) !== -1
      }
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;替换合并已有的-attribute&#34;&gt;替换/合并已有的 Attribute]&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;style&lt;/code&gt; attribute 值会被合并起来&lt;/p&gt;
&lt;h2 id=&#34;禁用-attribute-继承&#34;&gt;禁用 Attribute 继承&lt;/h2&gt;
&lt;p&gt;如果你&lt;strong&gt;不&lt;/strong&gt;希望组件的根元素继承 attribute，你可以在组件的选项中设置 &lt;code&gt;inheritAttrs: false&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Vue.component(&#39;my-component&#39;, {
  inheritAttrs: false,
  // ...
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自定义事件&#34;&gt;&lt;strong&gt;自定义事件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;事件名不存在自动大小写转换，在&lt;code&gt;v-on&lt;/code&gt;事件监听器DOM模板中会自动转化为小写&lt;/p&gt;
&lt;h2 id=&#34;自定义组件v-model&#34;&gt;自定义组件&lt;code&gt;v-model&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;一个组件上的 &lt;code&gt;v-model&lt;/code&gt; 默认会利用名为 &lt;code&gt;value&lt;/code&gt; 的 prop 和名为 &lt;code&gt;input&lt;/code&gt; 的事件&lt;/p&gt;
&lt;p&gt;但是像单选框、复选框等类型的输入控件可能会将 &lt;code&gt;value&lt;/code&gt; attribute 用于不同的目的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Vue.component(&#39;base-checkbox&#39;, {
  model: {
    prop: &#39;checked&#39;,
    event: &#39;change&#39;
  },
  props: {
    checked: Boolean
  },
  template: `
    &amp;lt;input
      type=&amp;quot;checkbox&amp;quot;
      v-bind:checked=&amp;quot;checked&amp;quot;
      v-on:change=&amp;quot;$emit(&#39;change&#39;, $event.target.checked)&amp;quot;
    &amp;gt;
  `
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;将原生事件绑定到组件&#34;&gt;将原生事件绑定到组件&lt;/h2&gt;
&lt;p&gt;想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 &lt;code&gt;v-on&lt;/code&gt; 的 &lt;code&gt;.native&lt;/code&gt; 修饰符：&lt;/p&gt;
&lt;p&gt;但元素实际上是一个 &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; 元素的时候监听不到：&lt;/p&gt;
&lt;p&gt;包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定&lt;/p&gt;
&lt;p&gt;$attrs可以接受上级传递过来的属性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;label&amp;gt;
  {{ label }}
  &amp;lt;input
    v-bind=&amp;quot;$attrs&amp;quot;
    v-bind:value=&amp;quot;value&amp;quot;
    v-on:input=&amp;quot;$emit(&#39;input&#39;, $event.target.value)&amp;quot;
  &amp;gt;
&amp;lt;/label&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vue 提供了一个 &lt;code&gt;$listeners&lt;/code&gt; property，它是一个对象，里面包含了作用在这个组件上的所有监听器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  focus: function (event) { /* ... */ }
  input: function (value) { /* ... */ },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就可以配合 &lt;code&gt;v-on=&amp;quot;$listeners&amp;quot;&lt;/code&gt;将所有的事件监听器指向这个组件的某个特定的子元素&lt;/p&gt;
&lt;h2 id=&#34;sync-修饰符&#34;&gt;&lt;code&gt;.sync&lt;/code&gt; 修饰符&lt;/h2&gt;
&lt;p&gt;真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件两侧都没有明显的变更来源&lt;/p&gt;
&lt;p&gt;带有 &lt;code&gt;.sync&lt;/code&gt; 修饰符的 &lt;code&gt;v-bind&lt;/code&gt; &lt;strong&gt;不能&lt;/strong&gt;和表达式一起使用&lt;/p&gt;
&lt;p&gt;例如 &lt;code&gt;v-bind:title.sync=”doc.title + ‘!’”&lt;/code&gt; 是无效的&lt;/p&gt;
&lt;p&gt;简写双向绑定的语法糖&lt;/p&gt;
&lt;p&gt;父&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;child :title.sync=&amp;quot;title&amp;quot;&amp;gt; &amp;lt;/child&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; &amp;lt;input :value=&amp;quot;title&amp;quot; @input=&amp;quot;abc&amp;quot; type=&amp;quot;text&amp;quot;&amp;gt;
    props: {
      title: {
        type: String,
        required: true
      }
    },
      methods: {
      abc(e) {
        console.log(e.target.value);
        this.$emit(&#39;update:title&#39;, e.target.value);
      }
    }
&lt;/code&gt;&lt;/pre&gt;
"> Vue文档3 Prop</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-wen-dang-2/"" data-c="
          &lt;h2 id=&#34;表单输入绑定&#34;&gt;表单输入绑定&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v-model&lt;/code&gt; 指令在表单 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 及 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 元素上创建双向数据绑定&lt;/p&gt;
&lt;p&gt;&lt;code&gt;v-model&lt;/code&gt; 会忽略所有表单元素的 &lt;code&gt;value&lt;/code&gt;、&lt;code&gt;checked&lt;/code&gt;、&lt;code&gt;selected&lt;/code&gt; attribute 的初始值而总是将 Vue 实例的数据作为数据来源&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.lazy&lt;/code&gt;    转为在 &lt;code&gt;change&lt;/code&gt; 事件_之后_进行同步&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;input v-model.lazy=&amp;quot;msg&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;code&gt;.number&lt;/code&gt;  自动将用户的输入值转为数值类型&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.trim&lt;/code&gt;   过滤用户输入的首尾空白字符&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;组件基础&#34;&gt;组件基础&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;// 定义一个名为 button-counter 的新组件
Vue.component(&#39;button-counter&#39;, {
  data: function () {
    return {
      count: 0
    }
  },
  template: &#39;&amp;lt;button v-on:click=&amp;quot;count++&amp;quot;&amp;gt;You clicked me {{ count }} times.&amp;lt;/button&amp;gt;&#39;
})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;div id=&amp;quot;components-demo&amp;quot;&amp;gt;
  &amp;lt;button-counter&amp;gt;&amp;lt;/button-counter&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;new Vue({ el: &#39;#components-demo&#39; })&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;data-必须是一个函数&#34;&gt;&lt;code&gt;data&lt;/code&gt; 必须是一个函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一个组件的 &lt;code&gt;data&lt;/code&gt; 选项必须是一个函数&lt;/strong&gt;，因此每个实例可以维护一份被返回对象的独立的拷贝：&lt;/p&gt;
&lt;h2 id=&#34;组件的组织&#34;&gt;组件的组织&lt;/h2&gt;
&lt;p&gt;两种组件的注册类型：&lt;strong&gt;全局注册&lt;/strong&gt;和&lt;strong&gt;局部注册&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;Vue.component&lt;/code&gt; 全局注册&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;prop向子组件传递数据&#34;&gt;prop向子组件传递数据&lt;/h2&gt;
&lt;p&gt;用&lt;code&gt;v-bind&lt;/code&gt;来动态传递prop&lt;/p&gt;
&lt;h2 id=&#34;单个根元素&#34;&gt;单个根元素&lt;/h2&gt;
&lt;p&gt;将模板的内容包裹在一个父元素内(就是最外面的div)&lt;/p&gt;
&lt;h2 id=&#34;监听子组件事件&#34;&gt;监听子组件事件&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;v-on&lt;/code&gt; 监听子组件实例的任意事件&lt;/p&gt;
&lt;p&gt;同时子组件可以通过调用内建的 &lt;strong&gt;&lt;code&gt;$emit&lt;/code&gt;&lt;/strong&gt; 方法并传入事件名称来触发一个事件&lt;/p&gt;
&lt;h3 id=&#34;在组件上使用-v-model&#34;&gt;在组件上使用 &lt;code&gt;v-model&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;input v-model=&amp;quot;searchText&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;input
  v-bind:value=&amp;quot;searchText&amp;quot;
  v-on:input=&amp;quot;searchText = $event.target.value&amp;quot;
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了让它正常工作，这个组件内的 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 必须：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将其 **&lt;code&gt;value&lt;/code&gt; **attribute 绑定到一个名叫 &lt;code&gt;value&lt;/code&gt; 的 prop 上&lt;/li&gt;
&lt;li&gt;在其 &lt;code&gt;input&lt;/code&gt; 事件被触发时，将新的值通过自定义的 &lt;code&gt;input&lt;/code&gt; 事件抛出&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;Vue.component(&#39;custom-input&#39;, {
  props: [&#39;value&#39;],
  template: `
    &amp;lt;input
      v-bind:value=&amp;quot;value&amp;quot;
      v-on:input=&amp;quot;$emit(&#39;input&#39;, $event.target.value)&amp;quot;
    &amp;gt;
  `
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在 &lt;code&gt;v-model&lt;/code&gt; 就应该可以在这个组件上完美地工作起来了：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;custom-input v-model=&amp;quot;searchText&amp;quot;&amp;gt;&amp;lt;/custom-input&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;通过插槽分发内容&#34;&gt;通过插槽分发内容&lt;/h2&gt;
&lt;p&gt;和 HTML 元素一样，我们经常需要向一个组件传递内容，像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;alert-box&amp;gt;
  Something bad happened.
&amp;lt;/alert-box&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;Vue.component(&#39;alert-box&#39;, {
  template: `
    &amp;lt;div class=&amp;quot;demo-alert-box&amp;quot;&amp;gt;
      &amp;lt;strong&amp;gt;Error!&amp;lt;/strong&amp;gt;
      &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
    &amp;lt;/div&amp;gt;
  `
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;动态组件&#34;&gt;动态组件&lt;/h2&gt;
&lt;p&gt;上述内容可以通过 Vue 的 &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; 元素加一个特殊的 &lt;code&gt;is&lt;/code&gt; attribute 来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&amp;gt;
&amp;lt;component v-bind:is=&amp;quot;currentTabComponent&amp;quot;&amp;gt;&amp;lt;/component&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;currentTabComponent&lt;/code&gt; 可以包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已注册组件的名字，或&lt;/li&gt;
&lt;li&gt;一个组件的选项对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全局注册&#34;&gt;全局注册&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Vue.component(&#39;my-component-name&#39;, {
  // ... 选项 ...
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;局部注册&#34;&gt;局部注册&lt;/h2&gt;
&lt;p&gt;全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var ComponentA = { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在 &lt;code&gt;components&lt;/code&gt; 选项中定义你想要使用的组件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;new Vue({
  el: &#39;#app&#39;,
  components: {
    &#39;component-a&#39;: ComponentA,
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import ComponentA from &#39;./ComponentA.vue&#39;

export default {
  components: {
    ComponentA
  },
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用了诸如 Babel 和 webpack 的模块系统。在这些情况下我们推荐创建一个 &lt;code&gt;components&lt;/code&gt; 目录，并将每个组件放置在其各自的文件中。&lt;/p&gt;
&lt;h2 id=&#34;基础组件的自动化全局注册&#34;&gt;基础组件的自动化全局注册&lt;/h2&gt;
&lt;p&gt;可以使用 &lt;code&gt;require.context&lt;/code&gt; 只全局注册这些非常通用的基础组件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局注册的行为必须在根 Vue 实例 (通过 &lt;code&gt;new Vue&lt;/code&gt;) 创建之前发生&lt;/strong&gt;&lt;/p&gt;
"> Vue文档2 components</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/shou-xie-promise/"" data-c="
          &lt;p&gt;promise是用来解决两个问题的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象&lt;/li&gt;
&lt;li&gt;promise可以支持多个并发的请求，获取并发请求中的数据&lt;/li&gt;
&lt;li&gt;这个promise可以解决异步的问题，本身不能说promise是异步的&lt;/li&gt;
&lt;/ul&gt;
 &lt;br&gt;
&lt;h2 id=&#34;实现代码&#34;&gt;&lt;strong&gt;实现代码&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; class mypromise {

        constructor(exeutor) {
            this.state = PENDING
            //成功的存储
            this.value = undefined
            //失败的存储
            this.reason = undefined

            //存放成功时候的回调函数
            this.ResolveCallbakc = []
            //存放失败时候的回调函数
            this.RejectCallback = []
            //要把这个值保存起来 调用then的时候还需要使用
            let resolve = (value) =&amp;gt; {
                
                if (this.state == PENDING) {
                    //定时器用于then先注册才去改变状态 
                  setTimeout(()=&amp;gt;{
                        //存起来
                    console.log(&#39;成功的构造&#39;);
                    this.value = value
                    //改变状态
                    this.state = FULFILLED
                    //全执行
                    this.ResolveCallbakc.forEach(fn =&amp;gt; fn())  //发布过程
                  })
                }
            }
            let reject = (reason) =&amp;gt; {

                if (this.state == PENDING) {
                setTimeout(()=&amp;gt;{
                    console.log(&#39;失败的构造&#39;);
                    //也存起来
                    this.reason = reason

                    this.state = REJECTED

                    this.RejectCallback.forEach(fn =&amp;gt; fn())
                })
                }
            }
            //传入两个参数 给用户来改变状态
            try {
                exeutor(resolve, reject)
            } catch (e) {
                //当前有异常
                reject(e)
            }
        }
        then(onfulfilled, onrejected) {
            if (this.state == FULFILLED) {
                onfulfilled(this.value)
               
            }
            if (this.state == REJECTED) {
                onrejected(this.reason)
             
            }
            if (this.state == PENDING) {
                console.log(&#39;推入函数&#39;);
                this.ResolveCallbakc.push(() =&amp;gt; {
                    onfulfilled(this.value)
                })
                this.RejectCallback.push(() =&amp;gt; {
                    onrejected(this.reason)
                })
                //链式调用
                return this;

            }

        }

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实例&#34;&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; let fanfan = new mypromise((resolve, reject) =&amp;gt; {
        console.log(&#39;?&#39;);
        resolve(&#39;fanfan&#39;)
    }).then(res =&amp;gt; {
        setTimeout(()=&amp;gt;{
            console.log(&#39;time&#39;);
        })
        console.log(res);

    }).then(res =&amp;gt; {
        console.log(&#39;?&#39;);
        
    }).then(res=&amp;gt;{
        console.log(res);
    })
 
 // 打印结果 可以看到先是then去注册完才去调用状态改变
 //先微后宏
 /**
 ?
promise2.html:78 推入函数
promise2.html:78 推入函数
promise2.html:78 推入函数
promise2.html:37 成功的构造
promise2.html:100 fanfan
promise2.html:103 ?
promise2.html:106 fanfan
promise2.html:98 time
 */
&lt;/code&gt;&lt;/pre&gt;
">手写Promise</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-she-ji-mo-shi/"" data-c="
          &lt;h1 id=&#34;js的设计模式&#34;&gt;JS的设计模式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;什么是设计模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设有一个空房间，我们要日复一日地往里 面放一些东西。最简单的办法当然是把这些东西 直接扔进去，但是时间久了，就会发现很难从这 个房子里找到自己想要的东西，要调整某几样东 西的位置也不容易。所以在房间里做一些柜子也 许是个更好的选择，虽然柜子会增加我们的成 本，但它可以在维护阶段为我们带来好处。使用 这些柜子存放东西的规则，或许就是一种模式&lt;/p&gt;
&lt;h2 id=&#34;单例模式&#34;&gt;单例模式&lt;/h2&gt;
&lt;p&gt;确保只有一个实例，并提供全局访问，类似闭包创建后都去访问一个。&lt;/p&gt;
&lt;h2 id=&#34;策略模式&#34;&gt;策略模式&lt;/h2&gt;
&lt;p&gt;定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。表单验证用的多&lt;/p&gt;
&lt;h2 id=&#34;代理模式&#34;&gt;代理模式&lt;/h2&gt;
&lt;p&gt;为一个对象提供一个代用品或占位符，以便控制对它的访问，用于对数据进行处理后返回&lt;/p&gt;
&lt;h2 id=&#34;发布-订阅模式&#34;&gt;发布-订阅模式&lt;/h2&gt;
&lt;p&gt;也称作观察者模式（观察者模式子模式），定义了对象间的一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都将得到通知 。不直接建立关系，依靠一个中间商来建立&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;   // 观察者
var observer = {
    // 订阅集合
    subscribes: [],

    // 订阅 存放对应key
    subscribe: function(key, fn) {
        //不存在的情况下才默认为一个空数组
        if (!this.subscribes[key]) {
            this.subscribes[key] = [];
        }
      
        
        // 订阅者的处理  是函数就推进去
        typeof fn === &#39;function&#39; &amp;amp;&amp;amp; this.subscribes[key].push(fn);
    },

    // 发布 
    publish: function() {
        
        var type =[].shift.call(arguments) // arguments[0]  去掉第一项 就是 key项 剩余项都是value项
        

            //调用对应key存的函数
            fns = this.subscribes[type];
           
        
        // 不存在的订阅类型，以及订阅时未传入处理回调的
        if (!fns || !fns.length) {
            return;
        }
        
        // 挨个处理调用 就是订阅同一个key很多次 然后一个个调用
        for (var i = 0; i &amp;lt; fns.length; ++i) {
            fns[i].apply(this, arguments);
        }
    },
     
};


//实例


observer.subscribe(&#39;examinationA&#39;, function(score) {
    console.log(score);
});

observer.subscribe(&#39;examinationA&#39;, function(score) {
    console.log(score);
});

observer.publish(&#39;examinationA&#39;, 100); // 100  100  里面两个订阅都打印了出来
&lt;/code&gt;&lt;/pre&gt;
">JS设计模式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-router/"" data-c="
          &lt;p&gt;&lt;strong&gt;这里的路由就是SPA（单页应用）的路径管理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路由用于设定访问路径，并将路径和组件映射起来&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;1-hash模式&#34;&gt;1、Hash模式：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过location.hast取得#后面的路由&lt;/p&gt;
&lt;p&gt;window.onhashchange=functioin(){}    //当hash路由改变时候触发&lt;/p&gt;
&lt;h4 id=&#34;2-history模式&#34;&gt;2、History模式：&lt;/h4&gt;
&lt;p&gt;这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。&lt;/p&gt;
&lt;p&gt;location.pathname 取得路由地址&lt;/p&gt;
&lt;p&gt;onpopstate来监听history的路由变化&lt;/p&gt;
&lt;h4 id=&#34;3-使用路由模块来实现页面跳转的方式&#34;&gt;3、使用路由模块来实现页面跳转的方式&lt;/h4&gt;
&lt;p&gt;方式1：直接修改地址栏&lt;/p&gt;
&lt;p&gt;方式2：this.$router.push(‘路由地址’)&lt;/p&gt;
&lt;p&gt;方式3：&lt;code&gt;&amp;lt;router-link to=&amp;quot;路由地址&amp;quot;&amp;gt;&amp;lt;/router-link&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;4、实现方式&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Vue.use(VueRouter)&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行VueRouter方法&lt;/li&gt;
&lt;li&gt;如果这个方法有一个属性 install 并且这个属性是一个方法 就会执行install这个方法  例如 (VueRouter.install=function(){})&lt;/li&gt;
&lt;li&gt;install这个方法的第一个参数 是vue&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h4&gt;5、手写router&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//router的index文件

import  VueRouter from &#39;../myrouter/index&#39;
import  Vue from &#39;vue&#39;

const register =() =&amp;gt;import(&#39;../src/register&#39;)
const home =()=&amp;gt;import(&#39;../src/home&#39;)

Vue.use(VueRouter)

const routes=[
    {
        path: &#39;/register&#39;,
        name: &#39;注册&#39;,
        component: register,
        title: &#39;注册&#39;,
      }, {
        path: &#39;/&#39;,
        name: &#39;首页&#39;,
        component: home,
        title: &#39;注册&#39;,
      },
   
   
]

const router = new VueRouter({
    routes
  })

export default router
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//实现VueRouter实例 hash模式实现

let Vue

//注册一个类
class VueRouter{
    constructor(options)
    {
        console.log(options);

        let initPath=&#39;/&#39; //默认值
        Vue.util.defineReactive(this,&#39;current&#39;,initPath) //this指向VueRouter  响应式
        this.current=&#39;/&#39; //当前路由
        this.routes=options.routes//用户路由规则
        this.mode=options.mode||&#39;hash&#39; //默认hash
        this.init() //监听路由改变
        
    }
    init()
    {
     
        if(this.mode==&#39;hash&#39;){
            console.log(location.hash); //拿到hash模式下的hash地址

            //监听第一次加载项目要加/#/
            window.addEventListener(&#39;load&#39;,()=&amp;gt;{
                this.current=location.hash.slice(1)
    
            })
            //监听路由改变
            window.addEventListener(&#39;hashchange&#39;,()=&amp;gt;{
                this.current=location.hash.slice(1)
            })
        }
    }
}

VueRouter.install=function(_Vue){
        Vue=_Vue

        //给调用组件添加一个属性  router
        Vue.mixin({  
            //全局添加数据和方法  vue3改为compostions api
            //每一个实例都是一个 $options api 例如app.vue 和main.js 里面的都是一个实例
            beforeCreate() {
                console.log(this.$options.name);
                if(this.$options.router)//根组件上才有的属性
                {
                    Vue.prototype.$router=this.$options.router //在Vue实例原生链上添加属性 实现全局添加this.$router属性
                }
            },
        })

        //创建全局组件
        //router-link 
        Vue.component(&#39;router-link&#39;,{
            //传参过来
            props:{
              to:{
                  type:String,
                  require:true
              }
            },
            render(h) {
                return h(&#39;a&#39;,{attrs:{
                    href:&amp;quot;#&amp;quot;+this.to
                }},this.$slots.default)//创建html的内容 就是插槽里面的内容
            },
        }),


        Vue.component(&#39;router-view&#39;,{
            //必须是响应式数据才能触发
            render(h) {

                //当前路由
                let current =this.$router.current
                console.log(current);
                //获取到了配置的路由数组  然后通过上面的取出对应的路由模块并且渲染出来
                let routers=this.$router.routes
                console.log(routers);

                //找出匹配的数组项
                let com=routers.find(item=&amp;gt;{
                    return current==item.path
                })
                console.log(com);
                return h(com.component)//创建html
            },
        })
}


export default  VueRouter
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//App.vue 文件

&amp;lt;template&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;


&amp;lt;div class=&amp;quot;tolink&amp;quot;&amp;gt;
    &amp;lt;router-link to=&#39;/register&#39;&amp;gt;注册&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&#39;/&#39;&amp;gt;home&amp;lt;/router-link&amp;gt;
   
&amp;lt;/div&amp;gt;
   &amp;lt;div&amp;gt;
      &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

export default {
  name: &#39;App&#39;,
  beforeCreate() {
    console.log(this.$router);
  },
  data() {
    return {
  
    }
  },
 


}
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
.tolink{
  width: 40%;
  margin: auto;
  display: flex;
  justify-content:space-between;
}
&amp;lt;/style&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现效果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210713165156925.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210713165208681.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">vue-router</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-wen-dang/"" data-c="
          &lt;p&gt;v-html :将模板字符串解析为html格式&lt;/p&gt;
&lt;p&gt;split() 组成字符串数组&lt;/p&gt;
&lt;p&gt;模板表达式都被放在沙盒中，只能访问&lt;a href=&#34;https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9&#34;&gt;全局变量的一个白名单&lt;/a&gt;，如 &lt;code&gt;Math&lt;/code&gt; 和 &lt;code&gt;Date&lt;/code&gt; 。你不应该在模板表达式中试图访问用户定义的全局变量。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;你可以使用动态参数为一个动态的事件名绑定处理函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;a v-on:[eventName]=&amp;quot;doSomething&amp;quot;&amp;gt; ... &amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;eventName&lt;/code&gt; 的值为 &lt;code&gt;&amp;quot;focus&amp;quot;&lt;/code&gt; 时，&lt;code&gt;v-on:[eventName]&lt;/code&gt; 将等价于 &lt;code&gt;v-on:focus&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;v-bind&#34;&gt;&lt;a href=&#34;https://cn.vuejs.org/v2/guide/syntax.html#v-bind-%E7%BC%A9%E5%86%99&#34;&gt;&lt;code&gt;v-bind&lt;/code&gt; 缩写&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!-- 完整语法 --&amp;gt;
&amp;lt;a v-bind:href=&amp;quot;url&amp;quot;&amp;gt;...&amp;lt;/a&amp;gt;

&amp;lt;!-- 缩写 --&amp;gt;
&amp;lt;a :href=&amp;quot;url&amp;quot;&amp;gt;...&amp;lt;/a&amp;gt;

&amp;lt;!-- 动态参数的缩写 (2.6.0+) --&amp;gt;
&amp;lt;a :[key]=&amp;quot;url&amp;quot;&amp;gt; ... &amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;v-on&#34;&gt;&lt;a href=&#34;https://cn.vuejs.org/v2/guide/syntax.html#v-on-%E7%BC%A9%E5%86%99&#34;&gt;&lt;code&gt;v-on&lt;/code&gt; 缩写&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!-- 完整语法 --&amp;gt;
&amp;lt;a v-on:click=&amp;quot;doSomething&amp;quot;&amp;gt;...&amp;lt;/a&amp;gt;

&amp;lt;!-- 缩写 --&amp;gt;
&amp;lt;a @click=&amp;quot;doSomething&amp;quot;&amp;gt;...&amp;lt;/a&amp;gt;

&amp;lt;!-- 动态参数的缩写 (2.6.0+) --&amp;gt;
&amp;lt;a @[event]=&amp;quot;doSomething&amp;quot;&amp;gt; ... &amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;计算属性和侦听器&#34;&gt;计算属性和侦听器&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div id=&amp;quot;example&amp;quot;&amp;gt;
  &amp;lt;p&amp;gt;Original message: &amp;quot;{{ message }}&amp;quot;&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;Computed reversed message: &amp;quot;{{ reversedMessage }}&amp;quot;&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;var vm = new Vue({
  el: &#39;#example&#39;,
  data: {
    message: &#39;Hello&#39;
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;计算属性缓存-vs-方法&#34;&gt;计算属性缓存 vs 方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;&amp;lt;p&amp;gt;Reversed message: &amp;quot;{{ reversedMessage() }}&amp;quot;&amp;lt;/p&amp;gt;

// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是&lt;strong&gt;计算属性是基于它们的响应式依赖进行缓存的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这就意味着只要 &lt;code&gt;message&lt;/code&gt; 还没有发生改变，多次访问 &lt;code&gt;reversedMessage&lt;/code&gt; 计算属性会立即返回之前的计算结果，而不必再次执行函数。&lt;/p&gt;
&lt;p&gt;所以计算属性要是响应试依赖&lt;/p&gt;
&lt;p&gt;这也同样意味着下面的计算属性将不再更新，因为 &lt;code&gt;Date.now()&lt;/code&gt; 不是响应式依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;computed: {
  now: function () {
    return Date.now()
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;计算属性-vs-侦听属性&#34;&gt;计算属性 vs 侦听属性&lt;/h2&gt;
&lt;p&gt;计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + &#39; &#39; + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(&#39; &#39;)
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;计算属性computed :&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;支持缓存，只有依赖数据发生改变，才会重新进行计算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持异步，当computed内有异步操作时无效，无法监听数据的变化&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​            3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行               缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​           5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;侦听属性watch：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不支持缓存，数据变，直接会触发相应的操作；&lt;/li&gt;
&lt;li&gt;watch支持异步；&lt;/li&gt;
&lt;li&gt;当一个属性发生变化时，需要执行对应的操作；一对多；&lt;/li&gt;
&lt;li&gt;监听数据必须是data中声明过或者父组件传递过来的props中的数据.函数有两个参数，
&lt;ol&gt;
&lt;li&gt;immediate：组件加载立即触发回调函数执行&lt;/li&gt;
&lt;li&gt;deep: 深度监听，为了发现&lt;strong&gt;对象内部值&lt;/strong&gt;的变化，复杂类型的数据时使用。deep无法监听到数组的变动和对象的新增&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;条件渲染&#34;&gt;条件渲染&lt;/h2&gt;
&lt;p&gt;当 &lt;code&gt;v-if&lt;/code&gt; 需要包裹多个元素时候 用 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;v-show&lt;/code&gt; 不支持 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元素，也不支持 &lt;code&gt;v-else&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;v-if&lt;/code&gt; 与 &lt;code&gt;v-for&lt;/code&gt; 一起使用时，&lt;code&gt;v-for&lt;/code&gt; 具有比 &lt;code&gt;v-if&lt;/code&gt; 更高的优先级&lt;/p&gt;
&lt;h2 id=&#34;事件处理方法&#34;&gt;事件处理方法&lt;/h2&gt;
&lt;p&gt;内联处理器中的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;div id=&amp;quot;example-3&amp;quot;&amp;gt; 
    &amp;lt;button v-on:click=&amp;quot;say(&#39;hi&#39;,$event)&amp;quot;&amp;gt;Say hi&amp;lt;/button&amp;gt;  
	&amp;lt;button v-on:click=&amp;quot;say(&#39;what&#39;)&amp;quot;&amp;gt;Say what&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt;

new Vue({
  el: &#39;#example-3&#39;,
  methods: {
    say: function (message,event) {
      alert(message)
        // 现在我们可以访问原生事件对象
        if (event) {
          event.preventDefault()
        }
    }
  }
})
//有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;事情修饰符&#34;&gt;事情修饰符&lt;/h2&gt;
&lt;p&gt;原文博客(https://www.cnblogs.com/xiaoyaoxingchen/p/10405207.html)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.stop&lt;/code&gt;  阻止冒泡（通俗讲就是阻止事件向上级DOM元素传递）&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626002759503.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.prevent&lt;/code&gt;  阻止默认事件的发生 例如a标签的跳转和表单的提交刷新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.capture&lt;/code&gt; 捕获冒泡 即有冒泡发生时，有该修饰符的dom元素会先执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1626002752776.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.self&lt;/code&gt;  事件有自身才能触发，通常用于避免冒泡事件的影响&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626002764276.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.once&lt;/code&gt;    只触发一次&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.passive&lt;/code&gt;   对DOM的默认事件进行性能优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;. native&lt;/code&gt; 一般给组件绑定事件加的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 阻止单击事件继续传播 --&amp;gt;
&amp;lt;a v-on:click.stop=&amp;quot;doThis&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;

&amp;lt;!-- 提交事件不再重载页面 --&amp;gt;
&amp;lt;form v-on:submit.prevent=&amp;quot;onSubmit&amp;quot;&amp;gt;&amp;lt;/form&amp;gt;

&amp;lt;!-- 修饰符可以串联 --&amp;gt;
&amp;lt;a v-on:click.stop.prevent=&amp;quot;doThat&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;

&amp;lt;!-- 只有修饰符 --&amp;gt;
&amp;lt;form v-on:submit.prevent&amp;gt;&amp;lt;/form&amp;gt;

&amp;lt;!-- 添加事件监听器时使用事件捕获模式 --&amp;gt;
&amp;lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&amp;gt;
&amp;lt;div v-on:click.capture=&amp;quot;doThis&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;

&amp;lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&amp;gt;
&amp;lt;!-- 即事件不是从内部元素触发的 --&amp;gt;
&amp;lt;div v-on:click.self=&amp;quot;doThat&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;按键修饰符&#34;&gt;按键修饰符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.enter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.delete&lt;/code&gt; (捕获“删除”和“退格”键)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.esc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.space&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.up&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.down&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.left&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.right&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&amp;gt;
    &amp;lt;input v-on:keyup.enter=&amp;quot;submit&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;系统修饰键&#34;&gt;系统修饰键&lt;/h2&gt;
&lt;p&gt;可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.ctrl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.alt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.shift&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.meta&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;exact&#34;&gt;&lt;code&gt;.exact&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;修饰符允许你控制由精确的系统修饰符组合触发的事件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&amp;gt;
&amp;lt;button v-on:click.ctrl=&amp;quot;onClick&amp;quot;&amp;gt;A&amp;lt;/button&amp;gt;

&amp;lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&amp;gt;
&amp;lt;button v-on:click.ctrl.exact=&amp;quot;onCtrlClick&amp;quot;&amp;gt;A&amp;lt;/button&amp;gt;

&amp;lt;!-- 没有任何系统修饰符被按下的时候才触发 --&amp;gt;
&amp;lt;button v-on:click.exact=&amp;quot;onClick&amp;quot;&amp;gt;A&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">VUE文档 base</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/mei-ti-cha-xun/"" data-c="
          &lt;p&gt;媒体属性是CSS3新增的内容&lt;/p&gt;
&lt;p&gt;媒体属性必须用括号()包起来&lt;/p&gt;
&lt;h5 id=&#34;media-媒体类型and-媒体特性你的样式&#34;&gt;@media 媒体类型and （媒体特性）{你的样式}&lt;/h5&gt;
&lt;h2 id=&#34;最大宽度max-width&#34;&gt;最大宽度max-width&lt;/h2&gt;
&lt;h5 id=&#34;意思是指媒体类型小于或等于指定的宽度时样式生效-如&#34;&gt;意思是指媒体类型小于或等于指定的宽度时，样式生效。如：&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@media screen and (max-width:480px){
 body {
   display:none;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;最小宽度min-width&#34;&gt;最小宽度min-width&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@media screen and (min-width:600px) and (max-width:900px){
  body {background-color:#f5f5f5;}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;多个媒体特性使用&#34;&gt;&lt;strong&gt;多个媒体特性使用&lt;/strong&gt;&lt;/h2&gt;
&lt;h5 id=&#34;media-query中可以包含0到多个表达式&#34;&gt;Media Query中可以包含0到多个表达式&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/**当屏幕在600px~900px之间时，body的背景色渲染为“#f5f5f5”*/
@media screen and (min-width:600px) and (max-width:900px){
  body {background-color:#f5f5f5;}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;设备屏幕的输出宽度device-width&#34;&gt;&lt;strong&gt;设备屏幕的输出宽度Device Width&lt;/strong&gt;&lt;/h2&gt;
&lt;h5 id=&#34;以根据屏幕设备的尺寸来设置相应的样式或者调用相应的样式文件&#34;&gt;以根据屏幕设备的尺寸来设置相应的样式（或者调用相应的样式文件）&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;screen and (max-device-width:480px)&amp;quot; href=&amp;quot;iphone.css&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;not关键词&#34;&gt;not关键词&lt;/h2&gt;
&lt;h5 id=&#34;使用关键词not是用来排除某种制定的媒体类型&#34;&gt;使用关键词“not”是用来排除某种制定的媒体类型&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@media not print and (max-width: 1200px){样式代码}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;only关键词&#34;&gt;only关键词&lt;/h2&gt;
&lt;h5 id=&#34;only用来指定某种特定的媒体类型&#34;&gt;only用来指定某种特定的媒体类型&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;only screen and (max-device-width:240px)&amp;quot; href=&amp;quot;android240.css&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
"> 媒体查询</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/css-du-liang-dan-wei-rememvwvh/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1625924625206.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;em&#34;&gt;&lt;strong&gt;em&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;继承父元素大小关系，2em 则为父元素大小的两倍  受自己上级节点影响&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;div&amp;quot; style=&amp;quot;font-size:20px;&amp;quot;&amp;gt;div 标签中的文字大小为 20px
&amp;lt;p class=&amp;quot;p&amp;quot; style=&amp;quot;font-size:2em&amp;quot;&amp;gt;P 标签中的文字大小为 2em
&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;style&gt;
.div{font-size:20px;}
.p{font-size:2em;}
.span{font-size:0.5em;}
&lt;/style&gt;
&lt;div class=&#34;div&#34; style=&#34;font-size:20px;&#34;&gt;div 标签中的文字大小为 20px
&lt;p class=&#34;p&#34; style=&#34;font-size:2em&#34;&gt;P 标签中的文字大小为 2em
    &lt;span class=&#34;span&#34; style=&#34;font-size:.5em&#34;&gt;span标签中的文字大小为0.5em&lt;/span&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;rem&#34;&gt;&lt;strong&gt;rem&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;就是相对于根节点来进行缩放，如果有嵌套的关&lt;br&gt;
系，嵌套关系的元素的字体大小始终按照根节点的字体大小进行缩放&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;style&amp;gt;
html{font-size:16px;}
.div{font-size:30px;background-color:pink;padding:50px;}
.p{font-size:1rem;}
.span{font-size:0.5rem;}
&amp;lt;/style&amp;gt;

&amp;lt;div class=&amp;quot;div&amp;quot;&amp;gt;div 标签中的文字大小为 30px
&amp;lt;p class=&amp;quot;p&amp;quot;&amp;gt;P 标签中的文字大小为 1rem
&amp;lt;span class=&amp;quot;span&amp;quot;&amp;gt;span 标 签 中 的 文 字 大 小 为
0.5rem&amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;div&#34; style=&#34;font-size:30px&#34;&gt;div 标签中的文字大小为 30px
&lt;p class=&#34;p&#34; style=&#34;font-size:1rem;&#34;&gt;P 标签中的文字大小为 1rem
&lt;span class=&#34;span&#34; style=&#34;font-size:.5rem&#34;&gt;span 标 签 中 的 文 字 大 小 为
0.5rem&lt;/span&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这个rem继承的是html的font-size  默认为16px 这才是根节点&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;vw-和-vh&#34;&gt;&lt;strong&gt;vw 和 vh&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;视窗的宽度和高度，相当于屏幕宽度和高度的 1%&lt;/p&gt;
&lt;p&gt;处理宽度的时候%单位更合适，处理高度的话 vh 单位更好&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;vmin-和-vmax&#34;&gt;&lt;strong&gt;vmin 和 vmax&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;关于视口高度和宽度两者的最小值或者最大值。&lt;/p&gt;
&lt;p&gt;如果你要让这个元素始终铺满整个视口的可见区域：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.box { 
height: 100vmax; 
width: 100vmax;
}
&lt;/code&gt;&lt;/pre&gt;
">CSS度量单位 rem、em、vw、vh</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tu-pian-lan-jia-zai/"" data-c="
          &lt;p&gt;实现图片懒加载先了解几个属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;offsetWidth/offsetHeight&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对象的可见宽度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clientWidth/clientHeight&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内容的可见宽度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scrollWidth/scrollHeight&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;元素完整的高度和宽度，overflow:hidden的部分也计算在内。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;offsetLeft/offsetTop&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当前元素距浏览器边界的偏移量，以像素为单位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clientTop/clientLeft&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个属性测试下来的结果就是border。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scrollLeft/scrollTop&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置或返回已经滚动到元素的左边界或上边界的像素数。&lt;/p&gt;
&lt;h2 id=&#34;实现代码&#34;&gt;实现代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; //显示器高度 window.innerHeight
    //图片到视窗上的距离 getBoundingClientRect().top
    let imgs=document.querySelectorAll(&#39;img&#39;)
    console.log(imgs);

    window.addEventListener(&#39;scroll&#39;,(e)=&amp;gt;{
        imgs.forEach(v=&amp;gt;{
            const imgtop=v.getBoundingClientRect().top
            console.log(imgtop);
            if(imgtop&amp;lt;window.innerHeight)
            {
              
                let data_src=v.getAttribute(&#39;data-src&#39;)
                 v.setAttribute(&#39;src&#39;,data_src)
            }
            console.log(&#39;触发&#39;);
        })
    })

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;img  data-src=&amp;quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb1-q.mafengwo.net%2Fs7%2FM00%2F2E%2F37%2FwKgB6lSuHraAYMNtAAXF8ovILuk683.png&amp;amp;refer=http%3A%2F%2Fb1-q.mafengwo.net&amp;amp;app=2002&amp;amp;size=f9999,10000&amp;amp;q=a80&amp;amp;n=0&amp;amp;g=0n&amp;amp;fmt=jpeg?sec=1627892666&amp;amp;t=953e6a19584b6772c33a1b84604fa63d&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;感觉上面这样触发太频繁 加个节流吧&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;//节流写法
    window.onscroll = throttle(getscroll,200)
    



    //主体函数
    function getscroll() {
  
        let imgs = document.querySelectorAll(&#39;img&#39;)

        imgs.forEach(v=&amp;gt;{
            const imgtop=v.getBoundingClientRect().top
            console.log(imgtop);
            if(imgtop&amp;lt;window.innerHeight)
            {

                let data_src=v.getAttribute(&#39;data-src&#39;)
                 v.setAttribute(&#39;src&#39;,data_src)
            }
          
        })
    }

    //节流函数 过一段时间才触发
    function throttle(fn, delay) {
        let timer = true
        return function () {
            if (!timer) {
                return false
            }
  
            timer=false
            setTimeout(() =&amp;gt; {
            fn()
            console.log(&#39;我是节流&#39;);
            timer = true;
        }, delay)

        }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1625323851326.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1625323855197.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;不节流效果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1625323862788.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;节流后的效果  200ms间隔&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1625323858842.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">图片懒加载</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/shou-xie-axios/"" data-c="
          &lt;h2 id=&#34;axios&#34;&gt;axios&lt;/h2&gt;
&lt;p&gt;客户端  请求  服务端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;请求行&lt;/p&gt;
&lt;p&gt;url&lt;/p&gt;
&lt;p&gt;请求方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个请求头&lt;/p&gt;
&lt;p&gt;域名，cooike，content-Type等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求体&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;post方法传的参数&lt;/p&gt;
&lt;p&gt;服务端  响应  客户端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;响应行&lt;/p&gt;
&lt;p&gt;status statusText&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个响应头&lt;/p&gt;
&lt;p&gt;Content-Type:text/html&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应体&lt;/p&gt;
&lt;p&gt;数据返回&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xhr&#34;&gt;XHR&lt;/h2&gt;
&lt;p&gt;XMLHttpRequest对象可以和服务器交互 不会刷新网页&lt;/p&gt;
&lt;p&gt;只有XHR和fetch发出的才是ajax请求&lt;/p&gt;
&lt;p&gt;一般的请求就类似跳转和刷新页面&lt;/p&gt;
&lt;p&gt;ajax只是调用监视回调函数并传入响应相关的数据&lt;/p&gt;
&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;
&lt;p&gt;XMLHttpRequest() //创建XHR对象的构造函数&lt;/p&gt;
&lt;p&gt;status：响应状态码&lt;/p&gt;
&lt;p&gt;statusText：响应状态文本&lt;/p&gt;
&lt;p&gt;onreadystatechange：绑定readyState改变的监听&lt;/p&gt;
&lt;p&gt;open(method,url)：初始化请求&lt;/p&gt;
&lt;p&gt;send(data)：发送请求&lt;/p&gt;
&lt;p&gt;abort()：中断请求&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;手写实现ajax&#34;&gt;手写实现ajax&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;script&amp;gt;
    
    //接口在本地node.js实现
      function getdata()
    {
        console.log(&#39;发送get请求&#39;);
        ajax({
            url:&#39;http://localhost:3000/getposition&#39;,
            parmas:{
               
            name:&#39;fanfan&#39;,
            age:19,
            number:13142278876
            }
        }).then(res=&amp;gt;{
            console.log(res);
        })
    }

    
    //ajax手写实现
     
    function ajax({
        //解构赋值  写好默认值
        url,
        method=&#39;GET&#39;,
        data={},
        parmas={},
    }){
        //返回promise对象
         return new Promise( (resolve,reject)=&amp;gt;{
       
         //对url的处理  有些get请求参数需要拼接另外函数实现拼接
            url+=&#39;?&#39;+pinjie(parmas)
    
             //创建xhr对象
             const request=new XMLHttpRequest()
            //打开连接
             request.open(method,url,true) 
            //转换为JSON对象 
            if(method==&#39;GET&#39;)
            {
                request.send()
            }
           else if(method==&#39;post&#39;)
           {
          
           //发送JSON格式的对象肯定要加请求头 告诉服务器请求体是JSON格式
            request.setRequestHeader(&#39;Content-Type&#39;,&#39;application/json;charset=uft-8&#39;)
            //转换为JSON发送
            request.send(JSON.stringify(data))
           }
    
           //绑定状态改变的监听 从发送变为成功或者失败调用的函数
           request.onreadystatechange=function(){
                //进入判断 如果请求没有完成 直接结束
                if(request.readyState!==4)
                {
                    return 
                }
                //如果响应状态码在 200~299为成功
                const {status,statusText} =request
                //自己加的属性
                let author=&#39;fanfan&#39;
                
                if(status&amp;gt;=200&amp;amp;&amp;amp;status&amp;lt;=299)
                {
                    //准备结果对象response 的其中几条
                    const response={
                        //对应返回的数据可以知道这些东西是什么
                        data:JSON.parse(request.response),
                        status,
                        statusText,
                        //自己添加的属性
                        author
                      
                    }
                    resolve(response)
                }else{
                    //请求失败返回message信息和状态码
                    reject(new Error(&#39;requset error status is &#39;+status))
                }
           }
              
         })
    }

    //拼接参数 for-in解决
    function pinjie(obj)
    {
        let  queryString=&#39;&#39;
        for(let k in obj)
        {
            queryString+= k+&#39;=&#39;+obj[k]+&#39;&amp;amp;&#39;
        }
        //判断有没有值
        if(queryString)
        {
            queryString=queryString.slice(0,queryString.length-1)
        }
        //拼接到url上面
       return  queryString
    }
    
    
&amp;lt;/script&amp;gt;


&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;实现结果&#34;&gt;实现结果&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1624712565528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;axios特点&#34;&gt;axios特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本promise的异步ajax请求库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器和node都可以使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持请求/响应数据转换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持请求取消&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多个请求响应拦截器-洋葱模型&#34;&gt;多个请求/响应拦截器  （洋葱模型）&lt;/h2&gt;
&lt;p&gt;请求拦截器 先添加后执行  响应拦截器 先添加先执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; //添加请求拦截器
    axios.interceptors.request.use(
        config=&amp;gt;{
            console.log(&#39;request interceptor1&#39;);
            return config
        },
        error=&amp;gt;{
            return Promise.reject(error)
        }
    )

     //添加请求拦截器
     axios.interceptors.request.use(
        config=&amp;gt;{
            console.log(&#39;request interceptor2&#39;);
            return config
        },
        error=&amp;gt;{
            return Promise.reject(error)
        }
    )
    //添加响应拦截器
    axios.interceptors.response.use(
        response=&amp;gt;{
            console.log(&#39;response interceptor1&#39;);
            return response
        },error=&amp;gt;{
            return Promise.reject(error)
        }
    )
      //添加响应拦截器
      axios.interceptors.response.use(
        response=&amp;gt;{
            console.log(&#39;response interceptor2&#39;);
            return response
        },error=&amp;gt;{
            return Promise.reject(error)
        }
    )


 //config 就是传的配置文件 不返回的话就传不过去

//response return的结果会给下一个响应拦截器 最后执行.then(res) 将数据传给res


/*request interceptor2
request interceptor1
response interceptor1
response interceptor2*/

&lt;/code&gt;&lt;/pre&gt;
">手写ajax</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/mustache/"" data-c="
          &lt;h1 id=&#34;vue源码学习&#34;&gt;vue源码学习&lt;/h1&gt;
&lt;h2 id=&#34;什么是模板引擎&#34;&gt;什么是模板引擎&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;将数据要变为试图最优雅的解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;历史上出现过数据变为视图的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;纯DOM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组join法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ES6的反引号法&lt;/p&gt;
&lt;p&gt;新增的 &lt;code&gt;${a}&lt;/code&gt;的语法糖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模板引擎&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数组join法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//换行一样
var message=&#39;fanfan&#39;
var str=[
    &#39;&amp;lt;li&amp;gt;&#39;,
    &#39;&amp;lt;div&amp;gt;&#39;+message+&#39;&amp;lt;/div&amp;gt;&#39;,
    &#39;&amp;lt;/li&amp;gt;&#39;
].join()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ES6的语法糖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let a=&#39;fanfan&#39;
list.innerHTTML+=`
	&amp;lt;li&amp;gt;
		&amp;lt;div class=&amp;quot;fanfan&amp;quot;&amp;gt;
				${a}的信息
		&amp;lt;/div&amp;gt;
	&amp;lt;/li&amp;gt;
`
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mustache库&#34;&gt;mustache库&lt;/h2&gt;
&lt;p&gt;{{ }} 像胡子  所以取名叫胡子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  var user = { name: &amp;quot;Olive&amp;quot;, age: 23, sex: &amp;quot;girl&amp;quot; };
        var template = &amp;quot;My name is  {{name}} ,I&#39;m  {{age}} ,Sex is {{sex}}&amp;quot;;
        var view = Mustache.render(template, user)

   console.log(view);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;简单模式下正则表达式可以实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; var template = &amp;quot;My name is  {{name}} ,I&#39;m  {{age}} ,Sex is {{sex}}&amp;quot;;
    
            console.log(template.replace(/\{\{(\w+)\}\}/g,function(a,b,c){
                console.log(a,b,c);
                return &#39;❤&#39;
            }));

/**
	b 找出了里面的内容 可以用来替换
	{{name}} name 12
	{{age}} age 27
	{{sex}} sex 43
 	My name is  ❤ ,I&#39;m  ❤ ,Sex is ❤*/
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; 
//进行函数封装
function likerender(template,data)
            {
                return template.replace(/\{\{(\w+)\}\}/g,function(findstr,$1){
                //匹配data对象里面的属性
                return data[$1]
                     });
            }

            var data={
                name:&#39;fanfan&#39;,
                age:18,
                sex:&#39;man&#39;
            }

            console.log(likerender(template,data));
		
//My name is  fanfan ,I&#39;m  18 ,Sex is man
&lt;/code&gt;&lt;/pre&gt;
">mustache</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/xiao-cheng-xu-kai-fa-ji-lu/"" data-c="
          &lt;h2 id=&#34;es6-map函数-选择作用&#34;&gt;ES6 map()函数 (选择作用)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var users = [
{name: &amp;quot;张含韵&amp;quot;, &amp;quot;email&amp;quot;: &amp;quot;zhang@email.com&amp;quot;},
{name: &amp;quot;江一燕&amp;quot;, &amp;quot;email&amp;quot;: &amp;quot;jiang@email.com&amp;quot;},
{name: &amp;quot;李小璐&amp;quot;, &amp;quot;email&amp;quot;: &amp;quot;li@email.com&amp;quot;}
];

var emails = users.map(function (user) { return user.email; });

console.log(emails.join(&amp;quot;, &amp;quot;)); 

// zhang@email.com, jiang@email.com, li@email.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此方法用于我对于获取总数据中选择data里面的数组去选择我需要的部分&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;小程序本地储存&#34;&gt;小程序本地储存&lt;/h2&gt;
&lt;p&gt;wx.setStorageSync(&#39;key&#39;,&#39;value);&lt;/p&gt;
&lt;p&gt;wx.getStorageSync( &#39;key&#39;);&lt;/p&gt;
&lt;p&gt;web中存数据会先调用toString() 把数据变为字符串 再进行储存&lt;/p&gt;
&lt;p&gt;小程序存的数据什么类型 获取的就是什么类型&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;onloadoption&#34;&gt;onload(option)&lt;/h2&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;​	//option里面包含我从其他页面跳转url带参的参数&lt;/p&gt;
&lt;p&gt;}&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;组件的子传父-父传子&#34;&gt;组件的子传父 父传子&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 监听自定义事件 bindtabsitemchange是子组件向父组件传值加bind --&amp;gt;
&amp;lt;tab tabs=&amp;quot;{{tabs}}&amp;quot; bindtabsitemchange=&amp;quot;handitemchange&amp;quot;&amp;gt;&amp;lt;/tab&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子组件接受参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; properties: {
    tabs:{
      type:Array,
      value:[]
    }
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子组件向父组件传值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  methods: {
      //点击事件
      handleitemtap(e)
      {
        const {index}=e.currentTarget.dataset
        this.triggerEvent(&amp;quot;tabsitemchange&amp;quot;,{index} )
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父组件对传值的处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//tab子组件点击事件
handitemchange(e)
{
  console.log(e);
  //获取被点击的标题索引
  const {index}=e.detail;
  let {tabs}=this.data
  tabs.forEach((value,i)=&amp;gt;i==index?value.isactive=true:value.isactive=false)
  this.setData({
      //更新父组件的内容
    tabs
  })
  
},
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
## 用到的周期函数
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//只用加载该页面才调用  
  onLoad: function (options) {
      console.log(options);
      this.qureyparams.cid=options.cid
      console.log(this.qureyparams);
      this.getgoodslist()
  },

       //每次回到该页面就会调用
     onShow(){
         ...
     },
      
//页面滚动条触底事件 要判断是否有下一页数据 总页数 页码   页码*获取条数&amp;gt;=总数据 没有下一页
  onReachBottom()
  {
      //判断是否还有下一页
      if(this.qureyparams.pagenum&amp;gt;=this.totalpagesize)
      {
        //给个提示
        wx.showToast({
          title:&#39;&#39;,
          icon:&#39;none&#39;,
          duration:1500,
         
        })
      }
      else{
     
         this.qureyparams.pagenum++
        console.log(this.qureyparams.pagenum);
        this.getgoodslist()
      }
  },
	
//下拉刷新触发函数 
  onPullDownRefresh(){
      //1 重置数组
      this.setData({
        goodslist:[]
      })
      //重置页数
      this.qureyparams.pagenum=1
      //重新发请求
      this.getgoodslist()
      //在方法里面手动关闭下拉刷新等待效果
      //（ wx.stopPullDownRefresh()）
  },
      
      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于下拉刷新可以在需要的文件下加&lt;code&gt;&amp;quot;enablePullDownRefresh&amp;quot;: true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可以在app.json全局加刷新效果 包括下拉刷新的样式也是可以添加的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  &amp;quot;window&amp;quot;:{
    &amp;quot;backgroundTextStyle&amp;quot;:&amp;quot;light&amp;quot;,
    &amp;quot;navigationBarBackgroundColor&amp;quot;: &amp;quot;#eb4450&amp;quot;,
    &amp;quot;navigationBarTitleText&amp;quot;: &amp;quot;fanfan&amp;quot;,
    &amp;quot;navigationBarTextStyle&amp;quot;:&amp;quot;white&amp;quot;,

    &amp;quot;backgroundColor&amp;quot;: &amp;quot;#0094ff&amp;quot;

  },
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h2 id=&#34;对于下拉加载新数据的方法&#34;&gt;对于下拉加载新数据的方法&lt;/h2&gt;
&lt;p&gt;先对原先数据进行解构后，把新数据加进去，而不是刷新数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; this.setData({
      goodslist:[...this.data.goodslist,...res.data.message.goods]
    })
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;小程序对于用户权限调用以及获取&#34;&gt;小程序对于用户权限调用以及获取&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//权限给与设置  ***
  //调用小程序内置api 获取用户的收货地址 追踪授权状态 SCOPE
  //增加收货地址
  handleaddress() {

    //打印授权的状态
    wx.getSetting({
      success: (res) =&amp;gt; { 
        console.log(res);
        //判断用户是否给权限
        const scopeaddress = res.authSetting[&amp;quot;scope.address&amp;quot;]
        //用户同意权限 直接调用
        if (scopeaddress || scopeaddress == undefined) {
          wx.chooseAddress({
            success: (result) =&amp;gt; {
              //存地址到缓存
              wx.setStorageSync(&#39;address&#39;, result);
              console.log(result);
            },
          });
        }
        //如果没给 调用接口让用户同意  打开授权页面
        else {
          wx.openSetting({
            success: (result) =&amp;gt; {
              console.log(result);
              //调用用户同意权限接口
              wx.chooseAddress({
                success: (res) =&amp;gt; {
                  wx.setStorageSync(&#39;address&#39;, res);
                  console.log(res);

                },

              });
            },

          });
        }
      },
    });
  },

&lt;/code&gt;&lt;/pre&gt;
"> 微信小程序开发记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/socketio-shi-xian-shi-shi-liao-tian-shi/"" data-c="
          &lt;p&gt;&lt;strong&gt;Node.js&lt;/strong&gt;部分（服务端）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  var express=require(&#39;express&#39;)
var app=express()
var server=require(&#39;http&#39;).createServer(app)
var io=require(&#39;socket.io&#39;)(server)

app.use(express.static(__dirname+&#39;/public&#39;))

//设置允许跨域
app.all(&#39;*&#39;, function (req, res, next) {
      res.header(&amp;quot;Access-Control-Allow-Credentials&amp;quot;, true)
      res.header(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;)
      res.header(&amp;quot;Access-Control-Allow-Headers&amp;quot;, &amp;quot;X-Requested-With&amp;quot;)
      res.header(&amp;quot;Access-Control-Allow-Methods&amp;quot;, &amp;quot;PUT,POST,GET,DELETE,OPTIONS&amp;quot;)
      res.header(&amp;quot;X-Powered-By&amp;quot;, &#39; 3.2.1&#39;)
      res.header(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json;charset=utf-8&amp;quot;)
      next()
})

//放用户
const users=[]

io.on(&#39;connection&#39;,function(socket){
    console.log(&amp;quot;新用户加入房间&amp;quot;);

    //监听Login事件
    socket.on(&#39;login&#39;,(data)=&amp;gt;{
            console.log(data);
        //放数据,顺便增加唯一id
        users.push({...data,id:socket.id})

        console.log(&#39;id是&#39;+socket.id);
        //所有人广播
        io.emit(&#39;loginback&#39;,{...data,id:socket.id})
    })

    socket.on(&#39;client&#39;,data2=&amp;gt;{
        console.log(data2.value);
        data2.users=users.find(u=&amp;gt;u.id==socket.id)
        console.log(data2.users);
        socket.broadcast.emit(&#39;sendmes&#39;,data2)
    })
    
})

server.listen(3000,()=&amp;gt;{
    console.log(&#39;http://127.0.0.1:3000&#39;);
})

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;前端部分&#34;&gt;前端部分&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;Socket聊天室&amp;lt;/title&amp;gt;
  &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
    /**输入框样式*/
    .text * {
      margin: 0;
      padding: 0;
    }

    #main {
      text-align: center;
    }

    #showmes {
      position: relative;
      background: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fcdn.duitang.com%2Fuploads%2Fitem%2F201209%2F08%2F20120908134318_YVAwx.jpeg&amp;amp;refer=http%3A%2F%2Fcdn.duitang.com&amp;amp;app=2002&amp;amp;size=f9999,10000&amp;amp;q=a80&amp;amp;n=0&amp;amp;g=0n&amp;amp;fmt=jpeg?sec=1626261869&amp;amp;t=964bbb79e059f74901698cdd5f6de691) no-repeat;
      background-size: 100% 110%;
      margin: auto;
      width: 600px;
      height: 600px;
      overflow: hidden;
      overflow-y: scroll;
    }

    /**别人气泡*/
    .leftspan2 {
      float: left;
      color: grey;
      font-weight: 1000;
      position: absolute;
      top: -18px;
      font-size: 3px;
      left: 25px;
    }

    .leftspan {
      color: white;
      background-color: #635f5fec;
      padding: 5px 8px;
      font-size: 14px;
      float: left;
      position: relative;
      border-radius: 4px;
      margin-left: 25px;
      margin-right: 5px;

    }

    .leftspan::after {
      content: &#39;&#39;;
      border: 8px solid #ffffff00;
      border-right: 8px solid #635f5fec;
      ;
      position: absolute;
      top: 6px;
      left: -16px;
    }

    /*自己气泡**/
    .pp {
      width: 100%;
      position: relative;
      min-height: 20px;
      float: right;
      margin-bottom: 15px;
    }

    .rightspan2 {
      float: right;
      color: grey;
      font-weight: 1000;
      position: absolute;
      top: -18px;
      font-size: 3px;
      right: 15px;
    }

    .rightspan {
      float: right;
      position: relative;
      color: rgb(2, 2, 2);
      font-weight: 500;
      background-color: #88e99d;
      padding: 5px 8px;
      font-size: 14px;
      border-radius: 4px;
      margin-left: 5px;
      margin-right: 15px;

    }

    .rightspan::after {
      content: &#39;&#39;;
      border: 8px solid #ffffff00;
      border-left: 8px solid #88e99d;
      ;
      position: absolute;
      top: 6px;
      right: -13px;

    }

    /**输入框*/
    #text {
      width: 500px;
      height: 25px;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

  &amp;lt;div id=&amp;quot;joinname&amp;quot;&amp;gt;
    &amp;lt;span&amp;gt;请输入加入的姓名&amp;lt;/span&amp;gt; &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;button onclick=&amp;quot;joinchat()&amp;quot;&amp;gt;提交&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;main&amp;quot; style=&amp;quot;display: none;&amp;quot;&amp;gt;
    
    &amp;lt;h1&amp;gt;fanfan的聊天室&amp;lt;/h1&amp;gt;
    &amp;lt;div id=&amp;quot;showmes&amp;quot;&amp;gt;

    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;inputtxt&amp;quot;&amp;gt;
      &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;text&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
      &amp;lt;button id=&amp;quot;btn&amp;quot; onclick=&amp;quot;sendmes()&amp;quot;&amp;gt;发送&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;

  &amp;lt;/div&amp;gt;

  &amp;lt;script src=&amp;quot;/socket.io/socket.io.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script&amp;gt;
    //全局变量
    name = &#39;&#39;
    var socket = io(); //连接聊天室的io服务器 io服务器的根地址
    //连接进聊天室
    function firstjoin() {

      socket.on(&#39;hello&#39;, data =&amp;gt; {
        console.log(&#39;服务端发送的东西为：&#39; + data);
      })
    }

    function notnull() {
      if (document.getElementById(&#39;text&#39;).value != &#39;&#39;) {
        return 1;
      }
      else {
        return 0;
      }
    }
    //自己发信息
    function sendmes() {
      if (notnull()) {
        var mes = document.getElementById(&#39;text&#39;).value
        var p = document.createElement(&#39;p&#39;);
        var span = document.createElement(&#39;span&#39;)
        var span2 = document.createElement(&#39;span&#39;)
        span.innerHTML = mes;
        span2.innerHTML = name;
        span2.className = &#39;rightspan2&#39;
        span.className = &#39;rightspan&#39;
        p.className = &#39;pp&#39;
        p.appendChild(span2)
        p.appendChild(span)
        document.getElementById(&#39;showmes&#39;).appendChild(p)
        socket.emit(&#39;client&#39;, {&#39;value&#39;:document.getElementById(&#39;text&#39;).value,&#39;name&#39;:name})
        document.getElementById(&#39;text&#39;).value = &#39;&#39;

        document.getElementById(&amp;quot;showmes&amp;quot;).scrollTop += document.getElementById(&amp;quot;showmes&amp;quot;).offsetHeight;
      }

    }
    //收到别人发的信息
    socket.on(&#39;sendmes&#39;, data =&amp;gt; {
      console.log(data);
      var p = document.createElement(&#39;p&#39;);
      var span = document.createElement(&#39;span&#39;);
      var span2 = document.createElement(&#39;span&#39;);
      span.className = &#39;leftspan&#39;
      console.log(&#39;姓名是&#39;+data.users.name);
      span2.innerHTML = data.users.name
      span2.className = &#39;leftspan2&#39;
      span.innerHTML = data.value;
      p.appendChild(span2)
      p.appendChild(span)
      p.className = &#39;pp&#39;

      document.getElementById(&#39;showmes&#39;).appendChild(p)

      document.getElementById(&amp;quot;showmes&amp;quot;).scrollTop += document.getElementById(&amp;quot;showmes&amp;quot;).offsetHeight;
    })

    //加入聊天室提醒
    function joinchat() {
      if (document.getElementById(&#39;name&#39;).value.length &amp;gt;= 1 &amp;amp;&amp;amp; document.getElementById(&#39;name&#39;).value.length &amp;lt;= 6) {
        //加入盒子隐藏 聊天盒子显示
        document.getElementById(&#39;main&#39;).style.display=&#39;block&#39;
        document.getElementById(&#39;joinname&#39;).style.display=&#39;none&#39;
        name=document.getElementById(&#39;name&#39;).value
        socket.emit(&#39;login&#39;, { &#39;name&#39;: document.getElementById(&#39;name&#39;).value })
      }

    }
    socket.on(&#39;loginback&#39;, data =&amp;gt; {
      var p = document.createElement(&#39;p&#39;);
      p.innerHTML = data.name + &#39;加入了房间&#39;;
      p.style.color = &#39;grey&#39;
      p.style.fontWeight = &#39;1000&#39;
      p.style.textAlign = &#39;center&#39;
      p.style.fontSize = &#39;6px&#39;
      document.getElementById(&#39;showmes&#39;).appendChild(p)
    })
    //回车发送消息
    document.onkeydown = function (e) {
      console.log(&#39;1&#39;);
      var ev = document.all ? window.event : e;
      if (ev.keyCode == 13) {
        sendmes();
      }
    }
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
每次进入页面先输入自己的姓名才能进入聊天室
每个客户端对应自己独特的socket id来获取发送消息的名称
给回车绑定事件，每次回车发送 可以实现多人在线实时聊天，且有自己对应的名称 自己发送的消息和收到的消息进行区分
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015910759.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015915621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015921537.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015925385.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015929804.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015931812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/mage-20210616015934765.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">socket.io实现实时聊天室</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/shi-jian-xun-huan/"" data-c="
          &lt;p&gt;JS为单线程&lt;br&gt;
宏任务主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)&lt;/p&gt;
&lt;p&gt;微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1623256115003.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;例子1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(&#39;script start&#39;);

setTimeout(function() {
  console.log(&#39;timeout1&#39;);
}, 10);

new Promise(resolve =&amp;gt; {
    console.log(&#39;promise1&#39;);
    resolve();
    setTimeout(() =&amp;gt; console.log(&#39;timeout2&#39;), 10);
}).then(function() {
    console.log(&#39;then1&#39;)
})

console.log(&#39;script end&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1623255042505.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
先执行第一个log&lt;/p&gt;
&lt;p&gt;setTimeout推入宏队列hong1&lt;/p&gt;
&lt;p&gt;遇到promise马上执行打印然后将它所有的then推入微队列后把setTimeout推入宏队列hong2&lt;/p&gt;
&lt;p&gt;先执行微队列，所以先打印then里面的。然后宏队列再打印&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
例子2&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  console.log(&#39;1&#39;);

setTimeout(function() {
    console.log(&#39;2&#39;);
  
    new Promise(function(resolve) {
        console.log(&#39;4&#39;);
        resolve();
    }).then(function() {
        console.log(&#39;5&#39;)
    })
})

new Promise(function(resolve) {
    console.log(&#39;7&#39;);
    resolve();
}).then(function() {
    console.log(&#39;8&#39;)
})

setTimeout(function() {
    console.log(&#39;9&#39;);
   
    new Promise(function(resolve) {
        console.log(&#39;11&#39;);
        resolve();
    }).then(function() {
        console.log(&#39;12&#39;)
    })
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1623255137440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当在只剩两个宏任务的setTimeout时候执行第一个时，Promise压入了then的微任务，让第二个宏任务又排到微任务后等待&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;async和await&#34;&gt;async和await&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;await后面接一个会return new promise的函数并执行它&lt;/li&gt;
&lt;li&gt;await只能放在async函数里&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function 摇色子(){
    return new Promise((resolve, reject)=&amp;gt;{
        let sino = parseInt(Math.random() * 6 +1)
        setTimeout(()=&amp;gt;{
            resolve(sino)
        },3000)
    })
}
async function test(){
    let n =await 摇色子()
    console.log(n)
}
test()
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;async函数会返回一个promise，并且Promise对象的状态值是resolved（成功的）
&lt;ul&gt;
&lt;li&gt;如果你没有在async函数中写return，那么Promise对象resolve的值就是是undefined&lt;/li&gt;
&lt;li&gt;如果你写了return，那么return的值就会作为你成功的时候传入的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;await 等到之后，做了一件什么事情？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不是promise对象&lt;/li&gt;
&lt;li&gt;是promise对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果。&lt;br&gt;
如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果asycn里的代码都是同步的，那么这个函数被调用就会同步执行&lt;/li&gt;
&lt;li&gt;如果在await后面接的这个promsie都是同步的，后面的promise会同步执行&lt;/li&gt;
&lt;li&gt;如果await里面的promise没有resolve()的成功函数就不会执行await下面的线程了&lt;/li&gt;
&lt;/ul&gt;
">事件循环</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-zhi-shi-dian/"" data-c="
          &lt;h2 id=&#34;节流和防抖&#34;&gt;节流和防抖&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;防抖&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; //防抖 在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms  用于停止动作后才开始触发的
    function debounce(fn,delay){
        let timer=null;
        return function(){
            if(timer){
                clearTimeout(timer)//存在即重新计时
                
            }
              timer=setTimeout(fn,delay)
            
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;节流&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//节流 适合一直不给机会触发防抖的
    function throttle(fn,delay){
       
    let valid = true
    return function() {
        
        //闭包函数内的vaild为同一个
       if(!valid){
           
           return false 
       }
       
        valid = false//防止多次触发
        
        setTimeout(() =&amp;gt; {
            fn()
            valid = true;
        }, delay)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;判断是不是数组&#34;&gt;判断是不是数组&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var a=new Array()
var b=new Object()

console.log(Array instanceof Object); //true   js数组可以看作对象

console.log(Array.isArray(a)); //true   数组方法

//误区
typeof(a) //object  typeof运算符用于判断对象的类型，但是对于一些创建的对象，它们都会返回&#39;object&#39;  返回的类型 undefined&#39; &#39;boolean&#39; &#39;string&#39; &#39;number&#39; &#39;object&#39;  &#39;function&#39;

Object.prototype.toString.call(a) //Object Array 用来判断类型

Object.prototype.toString.call(b) //object Object

//Array 和 Function都是Object的实例 都重写了toString()方法 所以直接调用的话是重写后的方法 调用原型上的方法返回类型

//对toString()方法重写的证明
console.log(Array.prototype.hasOwnProperty(&amp;quot;toString&amp;quot;));//true

delete Array.prototype.toString;//delete操作符可以删除实例属性

console.log(arr.toString());//&amp;quot;[object Array]&amp;quot;


//  prototype 和__proto__    一般来说 __proto__==constructor.prototype


&lt;/code&gt;&lt;/pre&gt;
">JS 节流和防抖 判断数组</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/dom/"" data-c="
          &lt;h2 id=&#34;节点层次&#34;&gt;节点层次&lt;/h2&gt;
&lt;h2 id=&#34;nodename-和-nodevalue-属性&#34;&gt;nodeName 和 nodeValue 属性&lt;/h2&gt;
&lt;p&gt;if(someNode.nodeType == 1)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;//先确定是个元素&lt;/p&gt;
&lt;p&gt;value = someNode.nodeName;   //nodeName 的值是元素的标签名&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;对于元素节点，nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;节点关系&#34;&gt;节点关系&lt;/h2&gt;
&lt;p&gt;每个节点都有一个 **childNodes **属性，其中保存着一个 **NodeList **对象。**NodeList **是一种类数组 对象，用于保存一组有序的节点&lt;/p&gt;
&lt;p&gt;val.childNodes[0]   //如果是标签之间有空隙 默认为文字  打印出  #text&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nextSibling&lt;/p&gt;
&lt;p&gt;previousSibling&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;firstChild&lt;/p&gt;
&lt;p&gt;lastChild&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看是否有子节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;val.hasChildNodes()  //boolean&lt;/p&gt;
&lt;h2 id=&#34;操作节点&#34;&gt;操作节点&lt;/h2&gt;
&lt;p&gt;**appendChild()**和 **insertBefore()**方法都只插入节点&lt;/p&gt;
&lt;p&gt;**replaceChild()**方法接受的两个参数是：要插入的节点和要替换的节点。尽管从技术上讲，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;removeChild()&lt;/strong&gt; 即要移除 的节点。被移除的节点将成为方法的返回值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cloneNode()&lt;/strong&gt; 用于创建调用这个方法的节点 的一个完全相同的副本，接受一个布尔值参数，表示是否执行深复制&lt;/p&gt;
&lt;h2 id=&#34;document类型&#34;&gt;Document类型&lt;/h2&gt;
&lt;p&gt; nodeType 的值为 9；&lt;/p&gt;
&lt;p&gt; nodeName 的值为&amp;quot;#document&amp;quot;；、&lt;/p&gt;
&lt;p&gt; nodeValue 的值为 null；&lt;/p&gt;
&lt;p&gt; parentNode 的值为 null；&lt;/p&gt;
&lt;p&gt; ownerDocument 的值为 null；&lt;/p&gt;
&lt;p&gt; 其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment。&lt;/p&gt;
&lt;p&gt;//设置文档标题&lt;/p&gt;
&lt;p&gt;document.title = &amp;quot;New page title&amp;quot;;&lt;/p&gt;
&lt;p&gt;//取得完整的 URL&lt;/p&gt;
&lt;p&gt;var url = document.URL;&lt;/p&gt;
&lt;p&gt;//取得域名&lt;/p&gt;
&lt;p&gt;var domain = document.domain;&lt;/p&gt;
&lt;p&gt;//取得来源页面的 URL&lt;/p&gt;
&lt;p&gt;var referrer = document.referrer;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;星号（*）通常表示“全部”。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var allElements = document.getElementsByTagName(&amp;quot;*&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 IE 中调用getElementsByTagName(&amp;quot;*&amp;quot;)将会返回所有注释节点&lt;/p&gt;
&lt;h2 id=&#34;element类型&#34;&gt;Element类型&lt;/h2&gt;
&lt;p&gt; nodeType 的值为 1；&lt;/p&gt;
&lt;p&gt; nodeName 的值为元素的标签名；&lt;/p&gt;
&lt;p&gt; nodeValue 的值为 null；&lt;/p&gt;
&lt;p&gt; parentNode 可能是 Document 或 Element；&lt;/p&gt;
&lt;p&gt; 其子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。&lt;/p&gt;
&lt;p&gt;访问元素的标签名&lt;strong&gt;nodeName&lt;/strong&gt; 和&lt;strong&gt;tagName&lt;/strong&gt; 这两个属性会返回 相同的值&lt;/p&gt;
&lt;p&gt;在 HTML 中，标签名始终都以全部大写表示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (element.tagName.toLowerCase() == &amp;quot;div&amp;quot;) //这样最好（适用于任何文档） //在此执行某些操作 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;取得特性&#34;&gt;取得特性&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;getAttribute()&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;div.getAttribute(&amp;quot;id&amp;quot;) //取得这个元素的特征值&lt;/p&gt;
&lt;p&gt;特性的名称是不区分大小写的&lt;/p&gt;
&lt;p&gt;自定义特性应该加上 data-前缀以便验证(用轮播图的时候自定义特性)&lt;/p&gt;
&lt;h2 id=&#34;设置特性&#34;&gt;设置特性&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;setAttribute()&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个方法接受两个参数：要设置的特性名和 值。如果特性已经存在，setAttribute()会以指定的值替换现有的值&lt;/p&gt;
&lt;p&gt;通过这个方法设置的 特性名会被统一转换为小写形式，即&amp;quot;ID&amp;quot;最终会变成&amp;quot;id&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;div.mycolor = &amp;quot;red&amp;quot;; 

 alert(div.getAttribute(&amp;quot;mycolor&amp;quot;)); //null（IE 除外） 因此想通过 getAttribute()取得同名特性的值，结果会返回 null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;***removeAttribute()***用于彻底删除元素的特性&lt;/p&gt;
&lt;p&gt;div.removeAttribute(&amp;quot;class&amp;quot;);&lt;/p&gt;
&lt;h2 id=&#34;attributes-属性&#34;&gt;attributes 属性&lt;/h2&gt;
">DOM</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vuenodejsmysql-kai-fa-ting-che-chang-guan-li-xi-tong/"" data-c="
          &lt;p&gt;前端github  &lt;strong&gt;https://github.com/fanfankill/depotsystem&lt;/strong&gt;&lt;br&gt;
服务端node整合   &lt;strong&gt;https://github.com/fanfankill/DeportCar.git&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;522-529&#34;&gt;&lt;strong&gt;5.22-5.29&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;对于车位管理页面完成了以下功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对所有车位信息的获取，总条数的获取以及分页操作&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622270278948.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新增车位信息（暂时以车位编号为主键 且按自动递增处理，所有其他信息都是在,未要求自己填入）&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622270324356.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除车位信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索车位信息&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622270252631.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改车位信息（两个1 0 的修改和对车位所属区域的修改，车位价格和车位区域绑定一起，修改区域自动修改价格）&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622270469346.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加车位区域（车位名称（主键）车位区域价格 对车位区域的描述）&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622270291881.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;530&#34;&gt;&lt;strong&gt;5.30&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;进出车辆登记&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;暂时登记车牌号码 选择停车区域 node获取当前进入时间&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622391426393.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622391499326.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;当获取停车区域时候，使用watch属性，确保每次切换不同区域能够获取相应区域空闲车位&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622391514068.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622391521639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;保证每个车辆只能进入时候被登记一次&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622391560153.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;进出管理表与车位管理表相连接，每次登记一个，车位管理也会更新车位状态和车牌信息&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622391622553.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;每次完成添加后立马更新车位空闲状态，防止多次更新同一个车位&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;531-66&#34;&gt;&lt;strong&gt;5.31-6.6&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;车辆入库出库记录&lt;br&gt;
(与车位管理相关 每次记录一个后会修改选中的车位状态)&lt;br&gt;
1.按已出库和未出库来获取数据 点击直接获取（wacth属性）&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622973621842.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622973626404.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2.对于不同情况下的按钮和驶出时间进行区别设计，当为已驶出状态的按钮点击为已经记录过的详细信息&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622973728852.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当为未出库状态下点击为预计算的信息()，若再次点击驶出按钮后则会修改该车位状态和进出状态并记录数据库&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1622973813093.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;630更新&#34;&gt;6.30更新&lt;/h2&gt;
&lt;p&gt;1.新增Echarts图表统计 和 日期天气显示&lt;br&gt;
2.加强表与表的联系&lt;br&gt;
3.新增固定车主功能，主要针对小区业主&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1624985566544.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1624985575278.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1624985582564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1624985591593.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1624985599641.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;实训更新&#34;&gt;实训更新&lt;/h2&gt;
&lt;p&gt;1.对页面的美化&lt;br&gt;
2.对车主续费管理&lt;br&gt;
3.聊天室搭建&lt;br&gt;
4.使用vuex实现头像实时更新&lt;br&gt;
5.将页面的弹出框等代码进行组件抽离管理&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;新增骨架框等一系列美化页面操作&#34;&gt;新增骨架框等一系列美化页面操作&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1626858133359.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857156637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3 id=&#34;个人资料更新&#34;&gt;个人资料更新&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857162502.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857165919.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;聊天室&#34;&gt;聊天室&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857172416.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857159756.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;续费操作&#34;&gt;续费操作&lt;/h3&gt;
&lt;p&gt;续费的金额也会同步到当日收入中 （echart表中）&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857365522.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857362095.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1626857722866.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">vue+node.js+mysql开发停车场管理系统</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-shi-jian/"" data-c="
          &lt;h1 id=&#34;事件&#34;&gt;事件&lt;/h1&gt;
&lt;p&gt;通过&lt;strong&gt;侦听器&lt;/strong&gt;来预定事件&lt;/p&gt;
&lt;h2 id=&#34;事件流&#34;&gt;事件流&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;事件流&lt;/strong&gt;描述的是从页面中接收事件的顺序&lt;br&gt;
事件例图：&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619594865905.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;IE 的事件流是事件冒泡流&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619594715319.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;Netscape Communicator 的事件流是事件捕获流&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619594736001.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;事件冒泡&#34;&gt;事件冒泡&lt;/h2&gt;
&lt;p&gt;IE 的事件流叫做&lt;strong&gt;事件冒泡&lt;/strong&gt;，即事件开始时由最具体的元素（文档中嵌套层次最深 的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;事件捕捉&#34;&gt;事件捕捉&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;事件捕获&lt;/strong&gt;的思想 是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;dom事件流&#34;&gt;DOM事件流&lt;/h2&gt;
&lt;p&gt;DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619594960277.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在 DOM 事件流中，实际的目标（元素）在捕获阶段不会接收到事件。这意味着在捕获阶段， 事件从 document 到再到后就停止了。下一个阶段是“处于目标”阶段，于是事件在上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生， 事件又传播回文档。&lt;/p&gt;
&lt;br&gt;
## 事件处理程序
&lt;p&gt;事件就是用户或浏览器自身执行的某种动作。诸如 click、load 和 mouseover，都是事件的名字。 而响应某个事件的函数就叫做事件处理程序（或事件侦听器）&lt;/p&gt;
&lt;p&gt;事件处理程序的名字以&amp;quot;on&amp;quot;开头（onclick，onload）&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;html事件处理程序&#34;&gt;HTML事件处理程序&lt;/h2&gt;
&lt;p&gt;这个操作是通过指定 onclick 特性并将一些 JavaScript 代码作为它的值来定义的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; onclick=&amp;quot;alert(&#39;Clicked&#39;)&amp;quot; /&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了避免使用 HTML 实体，这里使用了单 引号。如果想要使用双引号，那么就要将代码改写成如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; onclick=&amp;quot;alert(&amp;amp;quot;Clicked&amp;amp;quot;)&amp;quot; /&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事件处理程序中的代码在执行时，有权访问全局作用 域中的任何代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 输出 &amp;quot;click&amp;quot; --&amp;gt; 
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; onclick=&amp;quot;alert(event.type)&amp;quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样指定事件处理程序具有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。这个 函数中有一个局部变量 event&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;通过 event 变量，可以直接访问事件对象，你不用自己定义它，也不用从函数的参数列表中读取。 在这个函数内部，this 值等于事件的目标元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 输出 &amp;quot;Click Me&amp;quot; --&amp;gt; 
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; onclick=&amp;quot;alert(this.value)&amp;quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
 ##  HTML 中指定事件处理程序的缺点
&lt;p&gt;1.存在一个时差问题。因为用户可能会在 HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件。以前面的例子来说明，假设 showMessage()函数是在按钮下方、页面的最底部定义的。如果用户在页面解 析 showMessage()函数之前就单击了按钮就会引发错误。为此，很多 HTML 事件处理程序都会被封 装在一个 try-catch 块中，以便错误不会浮出水面，如下面的例子所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;Click Me&amp;quot; onclick=&amp;quot;try{showMessage();}catch(ex){}&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同 JavaScript 引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。&lt;/p&gt;
&lt;p&gt;3.是 HTML 与 JavaScript 代码紧密耦合。如果要更换事 件处理程序，就要改动两个地方：HTML 代码和 JavaScript 代码&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;dom0-级事件处理程序&#34;&gt;DOM0 级事件处理程序&lt;/h2&gt;
&lt;p&gt;通过 JavaScript 指定事件处理程序的传统方式&lt;/p&gt;
&lt;p&gt;原因一是简单，二是具有跨浏览器的优势&lt;/p&gt;
&lt;p&gt;要使用 JavaScript 指定事件处理程序，首先必须取得一 个要操作的对象的引用&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;使用 DOM0 级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在 元素的作用域中运行；换句话说，程序中的 this 引用当前元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.onclick = function(){ 
alert(this.id); //&amp;quot;myBtn&amp;quot; 
};

btn.onclick = null; //删除事件处理程序
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理&lt;/p&gt;
&lt;p&gt;将事件处理程序设置为 null 之后，再单击按钮将不会有任何动作发生。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
## DOM2 级事件处理程序
&lt;p&gt;“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：**addEventListener() **和 &lt;strong&gt;removeEventListener()&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;它们都接受 3 个参数：要处 理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获 阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序&lt;/p&gt;
&lt;p&gt;在按钮上为 click 事件添加事件处理程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.addEventListener(&amp;quot;click&amp;quot;, function(){ 
 alert(this.id); 
}, false); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的代码为一个按钮添加了 onclick 事件处理程序，而且该事件会在冒泡阶段被触发&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.addEventListener(&amp;quot;click&amp;quot;, function(){ 
 alert(this.id); 
}, false); 
btn.addEventListener(&amp;quot;click&amp;quot;, function(){ 
 alert(&amp;quot;Hello world!&amp;quot;); 
}, false); 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这里为按钮添加了两个事件处理程序。这两个事件处理程序会按照添加它们的顺序触发，因此首先 会显示元素的 ID，其次会显示&amp;quot;Hello world!&amp;quot;消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除，这也意味着通过 addEventListener()添加的匿 名函数将无法移除。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.addEventListener(&amp;quot;click&amp;quot;, function(){ 
 alert(this.id)}, false); 
//这里省略了其他代码
btn.removeEventListener(&amp;quot;click&amp;quot;, function(){ //没有用！
 alert(this.id); 
}, false); 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传入 removeEventListener()中的事件处理程序函数必须与传入 addEventListener()中的&lt;strong&gt;相同&lt;/strong&gt; ，因为一一对应，addEvenListener()可以给click或其他添加很多函数，所以removeEvenListener()也要一一去和它对应&lt;/p&gt;
&lt;p&gt;大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段（f第三个参数为false），这样可以最大限度地兼容各种浏览器。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;事件对象&#34;&gt;事件对象&lt;/h2&gt;
&lt;p&gt;在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的 信息。&lt;/p&gt;
&lt;h2 id=&#34;dom中的事件对象&#34;&gt;DOM中的事件对象&lt;/h2&gt;
&lt;p&gt;兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.onclick = function(event){ 
 alert(event.type); //&amp;quot;click&amp;quot; 
}; 
btn.addEventListener(&amp;quot;click&amp;quot;, function(event){ 
 alert(event.type); //&amp;quot;click&amp;quot; 
}, false);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要阻止特定事件的默认行为，可以使用 preventDefault()方法&lt;/p&gt;
&lt;p&gt;链接的默认行为就是在 被单击时会导航到其 href 特性指定的 URL。如果你想阻止链接导航这一默认行为，那么通过链接的 onclick 事件处理程序可以取消它&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var link = document.getElementById(&amp;quot;myLink&amp;quot;); 
link.onclick = function(event){ 
 event.preventDefault(); 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;stopPropagation()方法用于立即停止事件在 DOM 层次中的传播&lt;/p&gt;
&lt;p&gt;从而避免触 发注册在 document.body 上面的事件处理程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var btn = document.getElementById(&amp;quot;myBtn&amp;quot;); 
btn.onclick = function(event){ 
 alert(&amp;quot;Clicked&amp;quot;); 
 event.stopPropagation(); 
}; 
document.body.onclick = function(event){ 
 alert(&amp;quot;Body clicked&amp;quot;); 
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;事件类型&#34;&gt;事件类型&lt;/h2&gt;
&lt;br&gt;
&lt;h3 id=&#34;load事件&#34;&gt;&lt;strong&gt;load事件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当页面完全加载后（包括所有图像、JavaScript 文件、 CSS 文件等外部资源），就会触发 window 上面的 load 事件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;body onload=&amp;quot;alert(&#39;Loaded!&#39;)&amp;quot;&amp;gt; 
&amp;lt;/body&amp;gt;

//对图像的load事件
&amp;lt;img src=&amp;quot;smile.gif&amp;quot; onload=&amp;quot;alert(&#39;Image loaded.&#39;)&amp;quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;unload-事件&#34;&gt;&lt;strong&gt;unload 事件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;利用这个事件最多的情况是清除引用，以避免内存泄漏&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;resize-事件&#34;&gt;&lt;strong&gt;resize 事件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当浏览器窗口被调整到一个新的高度或宽度时，就会触发 resize 事件&lt;/p&gt;
&lt;p&gt;IE、Safari、Chrome 和 Opera 会在浏览 器窗口变化了 1 像素时就触发 resize 事件，然后随着变化不断重复触发。Firefox 则只会在用户停止调 整窗口大小时才会触发 resize 事件&lt;/p&gt;
&lt;p&gt;浏览器窗口最小化或最大化时也会触发 resize 事件&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;scroll-事件&#34;&gt;&lt;strong&gt;scroll 事件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;scroll 事件也会在文档被滚动期间重复被触发，所以有必要尽量保持事件 处理程序的代码简单&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;焦点事件&#34;&gt;&lt;strong&gt;焦点事件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与 document.hasFocus()方法及 document.activeElement 属性配合，可以知晓用户在页面上的行踪&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;blur&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DOMFocusIn&lt;/p&gt;
&lt;p&gt;在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它冒泡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DOMFoucusOut&lt;/p&gt;
&lt;p&gt;在元素失去焦点时触发，兼容性不强&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;focus&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;focusin&lt;/p&gt;
&lt;p&gt;这个事件与 HTML 事件 focus 等价，但它冒泡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;focusout&lt;/p&gt;
&lt;p&gt;这个事件是 HTML 事件 blur 的通用版本&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;鼠标与滚轮事件&#34;&gt;&lt;strong&gt;鼠标与滚轮事件&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;click&lt;/p&gt;
&lt;p&gt;在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dblclick&lt;/p&gt;
&lt;p&gt;在用户双击主鼠标按钮（一般是左边的按钮）时触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mousedown&lt;/p&gt;
&lt;p&gt;在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mouseenter&lt;/p&gt;
&lt;p&gt;在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且 在光标移动到后代元素上不会触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mouseleave&lt;/p&gt;
&lt;p&gt;在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且 在光标移动到后代元素上不会触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mousemove&lt;/p&gt;
&lt;p&gt;当鼠标指针在元素内部移动时重复地触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mouseout&lt;/p&gt;
&lt;p&gt;在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mouseover&lt;br&gt;
在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触 发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mouseup&lt;/p&gt;
&lt;p&gt;在用户释放鼠标按钮时触发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">JS事件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tu-jie-http-di-liu-zhang/"" data-c="
          &lt;h1 id=&#34;与http协助的web服务器&#34;&gt;与HTTP协助的Web服务器&lt;/h1&gt;
&lt;h2 id=&#34;用单台虚拟主机实现多个域名&#34;&gt;用单台虚拟主机实现多个域名&lt;/h2&gt;
&lt;p&gt;允许一台HTTP服务器搭建多个Web站点。&lt;/p&gt;
&lt;p&gt;即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器&lt;/p&gt;
&lt;p&gt;在互联网上，域名通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站，所以，当请求发送到服务器时，已经是IP地址形式访问了&lt;/p&gt;
&lt;h2 id=&#34;通信数据转发程序代理-网关-隧道&#34;&gt;通信数据转发程序：代理、网关、隧道&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代理&lt;/p&gt;
&lt;p&gt;扮演中间人，接收由客户端发送的请求并转发给服务器，同是，也接收服务器返回的响应并转发给客户端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网关&lt;/p&gt;
&lt;p&gt;网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隧道&lt;/p&gt;
&lt;p&gt;隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;代理&#34;&gt;&lt;strong&gt;代理&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;利用代理服务器的理由：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的&lt;/p&gt;
&lt;p&gt;代理按两种基准分类：一种是是否使用缓存，另一种是是否会修改报文&lt;/p&gt;
&lt;h4 id=&#34;缓存代理&#34;&gt;缓存代理&lt;/h4&gt;
&lt;p&gt;代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上&lt;/p&gt;
&lt;p&gt;当代理再次接收对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回&lt;/p&gt;
&lt;h4 id=&#34;透明代理&#34;&gt;透明代理&lt;/h4&gt;
&lt;p&gt;转发请求或响应时，不对报文做任何加工的代理类型被称为&lt;strong&gt;透明代理&lt;/strong&gt;，反之，称为非透明代理&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;网关&#34;&gt;网关&lt;/h2&gt;
&lt;p&gt;可以利用网关将HTTP请求转化为其他协议通信&lt;/p&gt;
&lt;p&gt;利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619484447634.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;隧道&#34;&gt;隧道&lt;/h2&gt;
&lt;p&gt;隧道可以按要求建立起一条与其他服务器的通信线路，可以使用SSL等加密手段进行通信。隧道的目的就是保住客户端与服务器能安全进行通信&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619484421757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;隧道本身不会去解析HTTP请求。请求保持原样中转给服务器。隧道会在双方通信断开连接的时候结束&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;保存资源的缓存&#34;&gt;保存资源的缓存&lt;/h2&gt;
&lt;p&gt;代理服务器会在服务器返回的响应时，保存一份资源副本&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619484470802.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;缓存有效期&#34;&gt;缓存有效期&lt;/h3&gt;
&lt;p&gt;存在资源更新等影响，需要去向源服务器确认&lt;/p&gt;
&lt;h3 id=&#34;客户端的缓存&#34;&gt;客户端的缓存&lt;/h3&gt;
&lt;p&gt;缓存也可以存在于客户端浏览器中，这种叫做&lt;strong&gt;临时网络文件&lt;/strong&gt;&lt;/p&gt;
">图解HTTP第五章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tu-jie-http-di-si-zhang/"" data-c="
          &lt;h1 id=&#34;返回结果的http状态&#34;&gt;返回结果的HTTP状态&lt;/h1&gt;
&lt;h2 id=&#34;状态码告知从服务器端返回的请求结果&#34;&gt;状态码告知从服务器端返回的请求结果&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619419502006.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-xx成功&#34;&gt;&lt;strong&gt;2 XX成功&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;响应结果表明请求被正常处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;200-ok&#34;&gt;200 OK&lt;/h3&gt;
&lt;p&gt;正常处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;204-no-content&#34;&gt;204 NO Content&lt;/h3&gt;
&lt;p&gt;表示请求被成功处理，但在返回的响应报文中不含实体的主体部分。&lt;/p&gt;
&lt;p&gt;应用于只需要客户端往服务器发送信息，而对客户端不需要发送新信息的情况下使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;206-partial-content&#34;&gt;206 Partial Content&lt;/h3&gt;
&lt;p&gt;表示客户端进行了范围请求，而服务器成功执行这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容&lt;/p&gt;
&lt;hr&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-xx重定向&#34;&gt;&lt;strong&gt;3 XX重定向&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表明浏览器需要执行某些特殊的处理以正确处理请求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;301-moved-permanently&#34;&gt;301 Moved Permanently&lt;/h3&gt;
&lt;p&gt;永久性重定向。表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI&lt;/p&gt;
&lt;p&gt;例如当指定路径末尾未加&amp;quot;/&amp;quot;时，会产生301状态码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;302-found&#34;&gt;302 Found&lt;/h3&gt;
&lt;p&gt;临时性重定向。表示请求的资源已经被分配了新的URI，希望用户能使用新的URI访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;303-see-other&#34;&gt;303 See Other&lt;/h3&gt;
&lt;p&gt;表示请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;304-not-modified&#34;&gt;304 Not Modified&lt;/h3&gt;
&lt;p&gt;表示客户端发送附带条件的请求时，服务器允许请求访问资源，但未找到满足条件的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;307-temporary-redirect&#34;&gt;307 Temporary Redirect&lt;/h3&gt;
&lt;p&gt;临时冲顶先。与302相似。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4-xx客户端错误&#34;&gt;&lt;strong&gt;4 XX客户端错误&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表明客户端发生错误的原因所在&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;400-bad-request&#34;&gt;400 Bad Request&lt;/h3&gt;
&lt;p&gt;该状态码表示请求报文中存在语法错误。需修改请求的内容后再次发送请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;401-unauthorized&#34;&gt;401 Unauthorized&lt;/h3&gt;
&lt;p&gt;表示发送的请求需要有通过HTTP认证的认证信息&lt;/p&gt;
&lt;p&gt;当浏览器初次接收到401响应，会弹出认证用的对话窗口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;403-forbidden&#34;&gt;403 Forbidden&lt;/h3&gt;
&lt;p&gt;表明请求的资源的访问被服务器拒绝了&lt;/p&gt;
&lt;p&gt;未获得文件系统的访问授权，访问权限出现某些问题等列举的情况都可能发生403的原因&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;404-not-found&#34;&gt;404 Not Found&lt;/h3&gt;
&lt;p&gt;表明服务器上无法找到请求的资源。&lt;/p&gt;
&lt;hr&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-xx服务器错误&#34;&gt;&lt;strong&gt;5 XX服务器错误&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;服务器本身的错误&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;500-internal-server-error&#34;&gt;500 Internal Server Error&lt;/h3&gt;
&lt;p&gt;表明服务器在执行请求时发生了错误。也有可能是WEB应用存在的bug或某些临时故障&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;503-service-unavailable&#34;&gt;503 Service Unavailable&lt;/h3&gt;
&lt;p&gt;表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​&lt;/p&gt;
">图解HTTP第四章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tu-jie-http-di-san-zhang/"" data-c="
          &lt;h1 id=&#34;http报文内的http信息&#34;&gt;&lt;strong&gt;HTTP报文内的HTTP信息&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;http报文&#34;&gt;&lt;strong&gt;HTTP报文&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;用于HTTP协议交互的信息被称为HTTP报文。请求端的HTTP报文叫做请求报文，响应端的叫做响应报文&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619330989639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&#34;请求行&#34;&gt;&lt;strong&gt;请求行&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;请求行包括请求的方法，URI和HTTP的版本&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;状态行&#34;&gt;&lt;strong&gt;状态行&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;包含响应结果的状态码，原因短语和HTTP版本&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;首部字段&#34;&gt;&lt;strong&gt;首部字段&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;包含表示请求和响应的各种条件和属性的各类首部&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;编码提升传输速率&#34;&gt;&lt;strong&gt;编码提升传输速率&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;报文主体和实体主体的差异&#34;&gt;&lt;strong&gt;报文主体和实体主体的差异&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;报文&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是HTTP通信中的基本单位&lt;/strong&gt;，有8个字节流组成，通过HTTP通信传输&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实体&lt;/p&gt;
&lt;p&gt;作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP报文的主体用于传输请求或响应的实体主体&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;压缩传输的内容编码&#34;&gt;&lt;strong&gt;压缩传输的内容编码&lt;/strong&gt;&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619331895496.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;分割发送的分块传输编码&#34;&gt;分割发送的分块传输编码&lt;/h2&gt;
&lt;p&gt;在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分块传输编码&lt;/strong&gt;会将实体主体分成多个部分。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用&amp;quot;0(CR+LF)&amp;quot;来标记&lt;/p&gt;
&lt;p&gt;客户端复制解码，恢复到编码前的实体主体&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;发送多种数据的多部分对象集合&#34;&gt;发送多种数据的多部分对象集合&lt;/h1&gt;
&lt;p&gt;例如图片，文件的上传&lt;/p&gt;
&lt;p&gt;在HTTP报文使用多部分对象集合时，需要在首部字段里加上Content-Type。&lt;/p&gt;
&lt;p&gt;boundary字符串来划分多部分对象集合指明的各类实体&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;获取部分内容的范围请求&#34;&gt;获取部分内容的范围请求&lt;/h1&gt;
&lt;p&gt;指定范围发送的请求叫&lt;strong&gt;范围请求&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619332602950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;内容协商返回最合适的内容&#34;&gt;内容协商返回最合适的内容&lt;/h1&gt;
&lt;p&gt;例网站的中英文版本，以下内容作为为判断标准&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Accept&lt;/li&gt;
&lt;li&gt;Accept-Charset&lt;/li&gt;
&lt;li&gt;Accept-Encoding&lt;/li&gt;
&lt;li&gt;Accept-Language&lt;/li&gt;
&lt;li&gt;Content-Language&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内容协商三种类型&lt;/p&gt;
&lt;h3 id=&#34;服务器驱动协商&#34;&gt;服务器驱动协商&lt;/h3&gt;
&lt;h3 id=&#34;客户端驱动协商&#34;&gt;客户端驱动协商&lt;/h3&gt;
&lt;h3 id=&#34;透明协商&#34;&gt;透明协商&lt;/h3&gt;
">图解HTTP第三章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tu-jie-http-di-er-zhang/"" data-c="
          &lt;h2 id=&#34;http协议用于客户端和服务端之间的通信&#34;&gt;&lt;strong&gt;HTTP协议用于客户端和服务端之间的通信&lt;/strong&gt;&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619145642116.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619145670666.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;h2 id=&#34;http是不保存状态协议&#34;&gt;&lt;strong&gt;HTTP是不保存状态协议&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;HTTP是不保存状态的协议，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。这样是为了更快的处理大量事务，确保协议的 可伸缩性&lt;/p&gt;
&lt;p&gt;为了保证页面跳转时的状态保存，Cooike就被引入&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;## &lt;em&gt;&lt;strong&gt;*请求URI定位资源*&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619145690268.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;h2 id=&#34;告知服务器意图的http方法&#34;&gt;&lt;strong&gt;告知服务器意图的HTTP方法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt;：获取资源&lt;/p&gt;
&lt;p&gt;GET方法用来请求访问已被URI 识别的资源&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619147700579.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;POST&lt;/strong&gt;：传输实体主体&lt;/p&gt;
&lt;p&gt;POST传输更常用&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619147796053.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;PUT&lt;/strong&gt;：传输文件&lt;/p&gt;
&lt;p&gt;PUT方法自身不带验证机制，在一般情况下不用&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619147670212.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;HEAD&lt;/strong&gt;：获得报文头部&lt;/p&gt;
&lt;p&gt;HEAD方法和GET方法一样，只是不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619147639933.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;DELETE&lt;/strong&gt;：删除文件&lt;/p&gt;
&lt;p&gt;与PUT方法相反的方法，也是不带验证机制的方法&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1619147846458.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;OPTIONS&lt;/strong&gt;：询问支持的方法&lt;/p&gt;
&lt;p&gt;OPTIONS方法用来查询针对URI指定的资源支持的方法&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;TRACE&lt;/strong&gt;：追踪路径&lt;br&gt;
TRACE方法是让WEB服务器端将之前的请求通信返回给客户端的方法&lt;br&gt;
客户端用于查询发送出去的请求怎样被加工的，但不常用&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;持久连接&#34;&gt;&lt;strong&gt;持久连接&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;因为每进行一次HTTP通信就要断开一次TCP连接，对于网页的请求就要很多次的连接和断开操作，浪费通信量。&lt;/p&gt;
&lt;p&gt;所以HTTP keep-alive的方法出现，只要任意一端没有明确提出断开连接，则保持TCP连接状态&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;使用cookie的状态管理&#34;&gt;&lt;strong&gt;使用Cookie的状态管理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态&lt;/p&gt;
&lt;p&gt;Cookie会根据从服务端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值发送出去&lt;/p&gt;
">图解HTTP 第二章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/tu-jie-http/"" data-c="
          &lt;h2 id=&#34;http超文本传输协议&#34;&gt;HTTP（超文本传输协议）&lt;/h2&gt;
&lt;br&gt;
&lt;h2 id=&#34;tcpip-分层&#34;&gt;TCP/IP 分层&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  	     1. 决定向用户提供应用服务时通信的活动 (HTTP，FTP，DNS)  
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  	     1. 提供处于网络连接中两台计算机之间的数据传输
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  	     1. 处理网络上流动的数据包，为数据传输选择一条路线
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据链路层&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  	     1. 一些肉眼可见的硬件设施 网卡 光纤 等
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;tcpip通信传输流&#34;&gt;TCP/IP通信传输流&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;客户端&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;过程&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;服务器&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;应用层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HTTP数据&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;应用层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;加/消去 TCP首部&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;传输层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;加/消去 IP首部&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;网络层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;链路层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;加/消去 以太网首部&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;链路层&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;与http关系紧密的协议&#34;&gt;&lt;strong&gt;与HTTP关系紧密的协议&lt;/strong&gt;&lt;/h1&gt;
&lt;br&gt;
&lt;h3 id=&#34;负责传输的ip协议&#34;&gt;&lt;strong&gt;负责传输的IP协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;IP(网际协议)处于网络层，IP协议的作用是把各种数据包传送给对方，而确保传送到对方那里，要满足各种条件。其中两个重要的条件就是&lt;strong&gt;IP地址&lt;/strong&gt;和&lt;strong&gt;MAC地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IP地址&lt;/strong&gt;指明了节点被分配到的地址，&lt;strong&gt;Mac地址&lt;/strong&gt;是指网卡所属的固定地址，IP地址可以和MAC地址进行匹配。IP地址可以变换，MAC地址基本不会更改&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;arp协议&#34;&gt;&lt;strong&gt;ARP协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;IP间的通信依赖MAC地址。在网络上，通信的双方在同一局域网（LAN）内的情况还是很少的，通常需要多台计算机和网络设备中转。而在进行中转时，&lt;strong&gt;会利用下一站中转设备的MAC地址来搜索下一个中转目标&lt;/strong&gt;。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcp协议&#34;&gt;&lt;strong&gt;TCP协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;TCP协议位于传输层，提供可靠的字节流服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字节流服务&lt;/strong&gt;指为了方便传输将大块数据分割成以报文段为单位的数据包进行管理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可靠的服务&lt;/strong&gt;指TCP协议能够确认数据最终是否送到对方&lt;/p&gt;
&lt;br&gt;
&lt;h4 id=&#34;确保数据能达到目标&#34;&gt;&lt;strong&gt;确保数据能达到目标&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;TCP协议采用&lt;strong&gt;三次握手&lt;/strong&gt;策略。用TCP协议把数据包送出去后，TCP一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN和——ACK。&lt;/p&gt;
&lt;p&gt;发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后发送端再回传一个带ACK标志的数据包，代表“握手”结束&lt;/p&gt;
&lt;p&gt;若在握手的过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;负责域名解析的dns服务&#34;&gt;&lt;strong&gt;负责域名解析的DNS服务&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;DNS服务位于应用层的协议。它提供域名到IP地址之间的解析服务&lt;/p&gt;
&lt;p&gt;DNS协议提供通过&lt;strong&gt;域名&lt;/strong&gt;(例如 www.baidu.com)查找&lt;strong&gt;IP&lt;/strong&gt;(14.215.177.39)，或逆向从IP反查域名的服务(cmd的nslookup 指令)&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;各种协议与http协议的关系&#34;&gt;各种协议与HTTP协议的关系&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1619064689862.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">图解HTTP 第一章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/zheng-ze-biao-da-shi/"" data-c="
          &lt;h1 id=&#34;语法&#34;&gt;语法&lt;/h1&gt;
&lt;p&gt;runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。&lt;/p&gt;
&lt;p&gt;runoo&lt;em&gt;b，可以匹配 runob、runoob、runoooooob 等，&lt;/em&gt; 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。&lt;/p&gt;
&lt;p&gt;colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。&lt;/p&gt;
">正则表达式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/vue-qian-zhi-dao-hang-shou-wei/"" data-c="
          &lt;h1 id=&#34;路由守卫&#34;&gt;路由守卫&lt;/h1&gt;
&lt;h2 id=&#34;当token不存在时-跳转到登陆界面&#34;&gt;当token不存在时 跳转到登陆界面&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;只有登录界面时 (不考虑注册等其他界面)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-router.beforeEach((to,from,next)=&amp;gt;{&#34;&gt;  let token=localStorage.getItem(&amp;quot;token&amp;quot;);
  if(token){//判断是否登录
    next()
  }

  else{
    if(to.path!==&#39;/login&#39;){
      alert(&amp;quot;请先登录&amp;quot;)
      next({path:&#39;/login&#39;})
    }
    else{
      next()
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;
">VUE 前置导航守卫</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/niu-ke-cuo-ti/"" data-c="
          &lt;br&gt;
&lt;h1 id=&#34;3true&#34;&gt;3==true&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1617673888601.PNG&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h1 id=&#34;2tostring&#34;&gt;2.toString()&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1617673913588.PNG&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-数组查重返回有重复的值&#34;&gt;3 数组查重(返回有重复的值)&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function(arr)
{
    let res=[];
    arr.forEach(function(val){
        //保证是重复项且新数组中没有存这项
        if(arr.indexOf(val)!=arr.lastIndexOf(val)&amp;amp;&amp;amp;res.indexOf(val)==-1)
        {
            res.push(val)
        }
    } )
    return res
}
&lt;/code&gt;&lt;/pre&gt;
">牛客</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js-ji-ben-shu-ju-lei-xing/"" data-c="
          &lt;h1 id=&#34;基本数据类型&#34;&gt;基本数据类型&lt;/h1&gt;
&lt;p&gt;ECMAScript中有5中简单数据类型（也称为基本数据类型）: Undefined、Null、Boolean、Number和String。还有1中复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;typeof-操作符&#34;&gt;typeof 操作符&lt;/h1&gt;
&lt;p&gt;由于js中的变量是松散类型的，所以它提供了一种检测当前变量的数据类型的方法，也就是typeof关键字.&lt;br&gt;
通过typeof关键字，对这5种数据类型会返回下面的值（以字符串形式显示)&lt;br&gt;
undefined ---------- 如果值未定义 Undefined&lt;/p&gt;
&lt;p&gt;boolean ---------- 如果这个值是布尔值 Boolean&lt;/p&gt;
&lt;p&gt;string ---------- 如果这个值是字符串 String&lt;/p&gt;
&lt;p&gt;number ---------- 如果这个值是数值类型 Number&lt;/p&gt;
&lt;p&gt;object ---------- 如果这个值是对象或null Object&lt;/p&gt;
&lt;p&gt;需要注意的是typeof null返回为object,因为特殊值null被认为是一个空的对象引用。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;undefined&#34;&gt;Undefined&lt;/h1&gt;
&lt;p&gt;Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。不过，一般建议尽量给变量初始化，但是在早期的js版本中是没有规定undefined这个值的，所以在有些框架中为了兼容旧版浏览器，会给window对象添加undefined值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window[&#39;undefined&#39;] = window[&#39;undefined&#39;];  
//或者
window.undefined = window.undefined;  
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h1 id=&#34;null&#34;&gt;Null&lt;/h1&gt;
&lt;p&gt;Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null时会返回object的原因。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var car = null;
  console.log(typeof car); // &amp;quot;object&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检测null值就可以知道相应的变量是否已经保存了一个对象的引用了。&lt;br&gt;
例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  if(car != null){
    //对car对象执行某些操作
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上，undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true。&lt;br&gt;
&lt;code&gt;console.log(undefined == null); //true&lt;/code&gt;&lt;br&gt;
尽管null和undefined有这样的关系，但它们的用途完全不同。无论在什么情况下都没有必要把一个变量的值显式地设置为undefined，可是同样的规则对null却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。&lt;/p&gt;
  &lt;br&gt;
&lt;h1 id=&#34;boolean&#34;&gt;Boolean&lt;/h1&gt;
&lt;p&gt;该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0。&lt;/p&gt;
&lt;p&gt;虽然Boolean类型的字面值只有两个，但JavaScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean()，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var message = &#39;Hello World&#39;;
    var messageAsBoolean = Boolean(message);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，字符串message被转换成了一个Boolean值，该值被保存在messageAsBoolean变量中。可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值。至于返回的这个值是true还是false，取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对象的转换规则。&lt;/p&gt;
&lt;p&gt;数据类型 转换为true的值	 转换为false的值&lt;br&gt;
Boolean	true	false&lt;br&gt;
String	任何非空的字符串	&amp;quot;&amp;quot;(空字符串)&lt;br&gt;
Number	任何非0数值（包括无穷大）	0和NAN&lt;br&gt;
Object	任何对象	null&lt;br&gt;
Undefined	不适用	undefined&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;number&#34;&gt;Number&lt;/h1&gt;
&lt;p&gt;这种类型用来表示整数和浮点数值，还有一种特殊的数值，即NaN（非数值 Not a Number）。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在JavaScript中，任何数值除以0会返回NaN，因此不会影响其他代码的执行。&lt;/p&gt;
&lt;p&gt;NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。例如，下面的代码会返回false。&lt;br&gt;
&lt;code&gt;alert(NaN == NaN); //false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#String&lt;br&gt;
String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由单引号(&#39;)或双引号(&amp;quot;)表示。&lt;/p&gt;
&lt;h1 id=&#34;string类型的特殊性&#34;&gt;String类型的特殊性&lt;/h1&gt;
&lt;p&gt;string类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，我们希望JS只复制对字符串的引用，而不是字符串的内容。但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成行为与基本&lt;/p&gt;
&lt;h1 id=&#34;类型相似的不可变引用类型&#34;&gt;类型相似的不可变引用类型&lt;/h1&gt;
&lt;p&gt;Boolean、Number、String 这三个是Javascript中的基本包装类型，也就是这三个其实是一个构造函数，他们是Function的实例，是引用类型，至于这里的String与以上说的String是同名，是因为其实上文说的String是指字符串，这里的String指的是String这个构造函数，上面那么写，是为了更好的理解，因为Javascript是松散类型的。我们可以看下String实例化的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var name = String(&amp;quot;jwy&amp;quot;);
alert(typeof name);//&amp;quot;string&amp;quot;
var x=new String(&#39;12345&#39;)
typeof x //object
x=&#39;12345&#39;
typeof x //string
var author = &amp;quot;Tom&amp;quot;;
alert(typeof name);//&amp;quot;string&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至于author这个会有length，substring等等这些方法，其实string只是String的一个实例，类似于C#中的String，和string.&lt;/p&gt;
&lt;p&gt;注意，typeof 变量 如果值是&amp;quot;string&amp;quot; 的话，也就是这个变量是字符串，在Javascript中，字符串是基本类型，而在C#或Java中，字符串是引用类型，但是Javascript中的String是引用类型，因为它是Javascript中定义好的基本包装类型，在C#中，String跟string其实是一样的。&lt;/p&gt;
&lt;h1 id=&#34;es6新增&#34;&gt;ES6新增&lt;/h1&gt;
&lt;p&gt;es6中新增了let命令来声明变量、const命令声明一个只读的常量。&lt;/p&gt;
&lt;p&gt;let的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。&lt;/p&gt;
&lt;p&gt;const一旦声明，常量的值就不能改变。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1617632333308.JPG&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1617632362296.JPG&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">JS基本数据类型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/js/"" data-c="
          &lt;h2 id=&#34;animation-属性&#34;&gt;&lt;strong&gt;animation 属性&lt;/strong&gt;&lt;/h2&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;animation-delay&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​       属性规定动画开始的延迟时间(2秒延时)&lt;/p&gt;
&lt;p&gt;​            &lt;code&gt;animation-delay: 2s;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​        负值也是允许的。如果使用负值，则动画将开始播放，如同已播放 N 秒&lt;/p&gt;
&lt;p&gt;​            &lt;code&gt;animation-delay: -2s;&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;animation-iteration-count&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		 属性指定动画应运行的次数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;		` animation-iteration-count: 3;`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		使用值 &amp;quot;infinite&amp;quot; 使动画永远持续下去&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;animation-direction&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		属性指定是向前播放、向后播放还是交替播放动画&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;normal - 动画正常播放（向前）。默认值&lt;/li&gt;
&lt;li&gt;reverse - 动画以反方向播放（向后）&lt;/li&gt;
&lt;li&gt;alternate - 动画先向前播放，然后向后&lt;/li&gt;
&lt;li&gt;alternate-reverse - 动画先向后播放，然后向前&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;animation-timing-function&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		属性规定动画的速度曲线&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ease - 指定从慢速开始，然后加快，然后缓慢结束的动画（默认）&lt;/li&gt;
&lt;li&gt;linear - 规定从开始到结束的速度相同的动画&lt;/li&gt;
&lt;li&gt;ease-in - 规定慢速开始的动画&lt;/li&gt;
&lt;li&gt;ease-out - 规定慢速结束的动画&lt;/li&gt;
&lt;li&gt;ease-in-out - 指定开始和结束较慢的动画&lt;/li&gt;
&lt;li&gt;cubic-bezier(n,n,n,n) - 运行您在三次贝塞尔函数中定义自己的值&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;animation-fill-mode&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		CSS 动画不会在第一个关键帧播放之前或在最后一个关键帧播放之后影响元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;none - 默认值。动画在执行之前或之后不会对元素应用任何样式。&lt;/li&gt;
&lt;li&gt;forwards - 元素将保留由最后一个关键帧设置的样式值（依赖 animation-direction 和 animation-iteration-count）。&lt;/li&gt;
&lt;li&gt;backwards - 元素将获取由第一个关键帧设置的样式值（取决于 animation-direction），并在动画延迟期间保留该值。&lt;/li&gt;
&lt;li&gt;both - 动画会同时遵循向前和向后的规则，从而在两个方向上扩展动画属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
&lt;pre&gt;&lt;code&gt;
//使用简写属性，将动画与 div 元素绑定：

div

{

animation:mymove 5s infinite;

-webkit-animation:mymove 5s infinite; /* Safari 和 Chrome */

}



//动画帧

 @keyframes mymove {

​          50% {transform-origin: 0 0 0;transform: rotate(360deg);background-color: rgb(83, 83, 90);}

​        

​        }

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1617525832441.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;## &lt;strong&gt;动画可用属性&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1617524085576.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">CSS3动画属性</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/xiang-mu-cooike-dai-ma/"" data-c="
          &lt;h1 id=&#34;cooike详细介绍&#34;&gt;cooike详细介绍&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_37002901/article/details/86601904&#34;&gt;&lt;strong&gt;原文博客&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;cooike储存机制&#34;&gt;cooike储存机制&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Set-Cookie: name=value[; expires=GMTDate][; domain=domain][; path=path][; secure]&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;项目实现代码&#34;&gt;项目实现代码&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;    //获取储存的cooike
getCookie(name) {
     var reg=RegExp(name+&#39;=([^;]+)&#39;);
     var arr=document.cookie.match(reg);
     if(arr)
     {
       return arr[1];
     }else{
       return &#39;&#39;;
     }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;/**存放cookie */

  setCookie(name, value, day) {

   let data = new Date();

   data.setDate(data.getDate() + day);

   document.cookie = name + &amp;quot;=&amp;quot; + value + &amp;quot;;expires=&amp;quot; + data;

  },
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;/**删除cooike*/
delCookie(name) {

   this.setCookie(name, &#39;&#39;, -1);

  },
&lt;/code&gt;&lt;/pre&gt;
">项目cooike实现保存账号密码功能</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/markdown-ji-ben-yu-fa/"" data-c="
          &lt;h1 id=&#34;对必要语法的摘记&#34;&gt;对必要语法的摘记&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fanfankill.github.io/post-images/1617462999416.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">markdown基本语法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fanfankill.github.io/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://4399.com&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://fanfankill.github.io/post-images/1617460798662.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;br&gt;
sdsd&lt;br&gt;
🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<script src="/media/js/mouse/peace.js"></script>


<script src="/media/js/cool.js"></script>



</html>