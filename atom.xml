<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fanfankill.github.io</id>
    <title>fanfan</title>
    <updated>2021-04-28T07:37:19.410Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fanfankill.github.io"/>
    <link rel="self" href="https://fanfankill.github.io/atom.xml"/>
    <subtitle>&lt;strong&gt;前端小白&lt;/strong&gt;</subtitle>
    <logo>https://fanfankill.github.io/images/avatar.png</logo>
    <icon>https://fanfankill.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, fanfan</rights>
    <entry>
        <title type="html"><![CDATA[JS事件]]></title>
        <id>https://fanfankill.github.io/post/js-shi-jian/</id>
        <link href="https://fanfankill.github.io/post/js-shi-jian/">
        </link>
        <updated>2021-04-28T07:09:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="事件">事件</h1>
<p>通过<strong>侦听器</strong>来预定事件</p>
<h2 id="事件流">事件流</h2>
<p><strong>事件流</strong>描述的是从页面中接收事件的顺序<br>
事件例图：<br>
<img src="https://fanfankill.github.io/post-images/1619594865905.png" alt="" loading="lazy"></p>
<p>IE 的事件流是事件冒泡流<br>
<img src="https://fanfankill.github.io/post-images/1619594715319.png" alt="" loading="lazy"></p>
<p>Netscape Communicator 的事件流是事件捕获流<br>
<img src="https://fanfankill.github.io/post-images/1619594736001.png" alt="" loading="lazy"><br>
<br></p>
<h2 id="事件冒泡">事件冒泡</h2>
<p>IE 的事件流叫做<strong>事件冒泡</strong>，即事件开始时由最具体的元素（文档中嵌套层次最深 的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。<br>
<br></p>
<h2 id="事件捕捉">事件捕捉</h2>
<p><strong>事件捕获</strong>的思想 是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。<br>
<br></p>
<h2 id="dom事件流">DOM事件流</h2>
<p>DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。<br>
<img src="https://fanfankill.github.io/post-images/1619594960277.png" alt="" loading="lazy"><br>
在 DOM 事件流中，实际的目标（元素）在捕获阶段不会接收到事件。这意味着在捕获阶段， 事件从 document 到再到后就停止了。下一个阶段是“处于目标”阶段，于是事件在上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生， 事件又传播回文档。</p>
<br>
## 事件处理程序
<p>事件就是用户或浏览器自身执行的某种动作。诸如 click、load 和 mouseover，都是事件的名字。 而响应某个事件的函数就叫做事件处理程序（或事件侦听器）</p>
<p>事件处理程序的名字以&quot;on&quot;开头（onclick，onload）<br>
<br></p>
<h2 id="html事件处理程序">HTML事件处理程序</h2>
<p>这个操作是通过指定 onclick 特性并将一些 JavaScript 代码作为它的值来定义的</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert('Clicked')&quot; /&gt; 
</code></pre>
<p>为了避免使用 HTML 实体，这里使用了单 引号。如果想要使用双引号，那么就要将代码改写成如下所示：</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&amp;quot;Clicked&amp;quot;)&quot; /&gt; 
</code></pre>
<p>事件处理程序中的代码在执行时，有权访问全局作用 域中的任何代码</p>
<pre><code class="language-html">&lt;!-- 输出 &quot;click&quot; --&gt; 
&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;&gt; 
</code></pre>
<p>这样指定事件处理程序具有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。这个 函数中有一个局部变量 event</p>
<br>
<p>通过 event 变量，可以直接访问事件对象，你不用自己定义它，也不用从函数的参数列表中读取。 在这个函数内部，this 值等于事件的目标元素</p>
<pre><code class="language-html">&lt;!-- 输出 &quot;Click Me&quot; --&gt; 
&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(this.value)&quot;&gt; 
</code></pre>
<br>
 ##  HTML 中指定事件处理程序的缺点
<p>1.存在一个时差问题。因为用户可能会在 HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件。以前面的例子来说明，假设 showMessage()函数是在按钮下方、页面的最底部定义的。如果用户在页面解 析 showMessage()函数之前就单击了按钮就会引发错误。为此，很多 HTML 事件处理程序都会被封 装在一个 try-catch 块中，以便错误不会浮出水面，如下面的例子所示：</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;try{showMessage();}catch(ex){}&quot;&gt;
</code></pre>
<p>2.这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同 JavaScript 引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。</p>
<p>3.是 HTML 与 JavaScript 代码紧密耦合。如果要更换事 件处理程序，就要改动两个地方：HTML 代码和 JavaScript 代码<br>
<br></p>
<h2 id="dom0-级事件处理程序">DOM0 级事件处理程序</h2>
<p>通过 JavaScript 指定事件处理程序的传统方式</p>
<p>原因一是简单，二是具有跨浏览器的优势</p>
<p>要使用 JavaScript 指定事件处理程序，首先必须取得一 个要操作的对象的引用</p>
<br>
<p>使用 DOM0 级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在 元素的作用域中运行；换句话说，程序中的 this 引用当前元素</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.onclick = function(){ 
alert(this.id); //&quot;myBtn&quot; 
};

btn.onclick = null; //删除事件处理程序
</code></pre>
<p>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理</p>
<p>将事件处理程序设置为 null 之后，再单击按钮将不会有任何动作发生。</p>
<br>
<br>
## DOM2 级事件处理程序
<p>“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：**addEventListener() **和 <strong>removeEventListener()</strong>。</p>
<p>它们都接受 3 个参数：要处 理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获 阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序</p>
<p>在按钮上为 click 事件添加事件处理程序</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.addEventListener(&quot;click&quot;, function(){ 
 alert(this.id); 
}, false); 
</code></pre>
<p>上面的代码为一个按钮添加了 onclick 事件处理程序，而且该事件会在冒泡阶段被触发</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.addEventListener(&quot;click&quot;, function(){ 
 alert(this.id); 
}, false); 
btn.addEventListener(&quot;click&quot;, function(){ 
 alert(&quot;Hello world!&quot;); 
}, false); 

</code></pre>
<p><strong>这里为按钮添加了两个事件处理程序。这两个事件处理程序会按照添加它们的顺序触发，因此首先 会显示元素的 ID，其次会显示&quot;Hello world!&quot;消息</strong></p>
<p>通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除，这也意味着通过 addEventListener()添加的匿 名函数将无法移除。</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.addEventListener(&quot;click&quot;, function(){ 
 alert(this.id)}, false); 
//这里省略了其他代码
btn.removeEventListener(&quot;click&quot;, function(){ //没有用！
 alert(this.id); 
}, false); 

</code></pre>
<p>传入 removeEventListener()中的事件处理程序函数必须与传入 addEventListener()中的<strong>相同</strong> ，因为一一对应，addEvenListener()可以给click或其他添加很多函数，所以removeEvenListener()也要一一去和它对应</p>
<p>大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段（f第三个参数为false），这样可以最大限度地兼容各种浏览器。<br>
<br></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图解HTTP第五章]]></title>
        <id>https://fanfankill.github.io/post/tu-jie-http-di-liu-zhang/</id>
        <link href="https://fanfankill.github.io/post/tu-jie-http-di-liu-zhang/">
        </link>
        <updated>2021-04-27T00:11:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="与http协助的web服务器">与HTTP协助的Web服务器</h1>
<h2 id="用单台虚拟主机实现多个域名">用单台虚拟主机实现多个域名</h2>
<p>允许一台HTTP服务器搭建多个Web站点。</p>
<p>即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器</p>
<p>在互联网上，域名通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站，所以，当请求发送到服务器时，已经是IP地址形式访问了</p>
<h2 id="通信数据转发程序代理-网关-隧道">通信数据转发程序：代理、网关、隧道</h2>
<ul>
<li>
<p>代理</p>
<p>扮演中间人，接收由客户端发送的请求并转发给服务器，同是，也接收服务器返回的响应并转发给客户端</p>
</li>
<li>
<p>网关</p>
<p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的服务器</p>
</li>
<li>
<p>隧道</p>
<p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序</p>
</li>
</ul>
<h3 id="代理"><strong>代理</strong></h3>
<p>利用代理服务器的理由：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的</p>
<p>代理按两种基准分类：一种是是否使用缓存，另一种是是否会修改报文</p>
<h4 id="缓存代理">缓存代理</h4>
<p>代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上</p>
<p>当代理再次接收对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回</p>
<h4 id="透明代理">透明代理</h4>
<p>转发请求或响应时，不对报文做任何加工的代理类型被称为<strong>透明代理</strong>，反之，称为非透明代理</p>
<hr>
<h2 id="网关">网关</h2>
<p>可以利用网关将HTTP请求转化为其他协议通信</p>
<p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。<br>
<img src="https://fanfankill.github.io/post-images/1619484447634.png" alt="" loading="lazy"></p>
<h2 id="隧道">隧道</h2>
<p>隧道可以按要求建立起一条与其他服务器的通信线路，可以使用SSL等加密手段进行通信。隧道的目的就是保住客户端与服务器能安全进行通信<br>
<img src="https://fanfankill.github.io/post-images/1619484421757.png" alt="" loading="lazy"></p>
<p>隧道本身不会去解析HTTP请求。请求保持原样中转给服务器。隧道会在双方通信断开连接的时候结束</p>
<hr>
<h2 id="保存资源的缓存">保存资源的缓存</h2>
<p>代理服务器会在服务器返回的响应时，保存一份资源副本<br>
<img src="https://fanfankill.github.io/post-images/1619484470802.png" alt="" loading="lazy"></p>
<h3 id="缓存有效期">缓存有效期</h3>
<p>存在资源更新等影响，需要去向源服务器确认</p>
<h3 id="客户端的缓存">客户端的缓存</h3>
<p>缓存也可以存在于客户端浏览器中，这种叫做<strong>临时网络文件</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图解HTTP第四章]]></title>
        <id>https://fanfankill.github.io/post/tu-jie-http-di-si-zhang/</id>
        <link href="https://fanfankill.github.io/post/tu-jie-http-di-si-zhang/">
        </link>
        <updated>2021-04-26T06:02:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="返回结果的http状态">返回结果的HTTP状态</h1>
<h2 id="状态码告知从服务器端返回的请求结果">状态码告知从服务器端返回的请求结果</h2>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1619419502006.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="2-xx成功"><strong>2 XX成功</strong></h2>
<p>响应结果表明请求被正常处理</p>
<ul>
<li>
<h3 id="200-ok">200 OK</h3>
<p>正常处理</p>
</li>
<li>
<h3 id="204-no-content">204 NO Content</h3>
<p>表示请求被成功处理，但在返回的响应报文中不含实体的主体部分。</p>
<p>应用于只需要客户端往服务器发送信息，而对客户端不需要发送新信息的情况下使用</p>
</li>
<li>
<h3 id="206-partial-content">206 Partial Content</h3>
<p>表示客户端进行了范围请求，而服务器成功执行这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容</p>
<hr>
</li>
</ul>
<h2 id="3-xx重定向"><strong>3 XX重定向</strong></h2>
<p>表明浏览器需要执行某些特殊的处理以正确处理请求</p>
<ul>
<li>
<h3 id="301-moved-permanently">301 Moved Permanently</h3>
<p>永久性重定向。表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI</p>
<p>例如当指定路径末尾未加&quot;/&quot;时，会产生301状态码</p>
</li>
<li>
<h3 id="302-found">302 Found</h3>
<p>临时性重定向。表示请求的资源已经被分配了新的URI，希望用户能使用新的URI访问</p>
</li>
<li>
<h3 id="303-see-other">303 See Other</h3>
<p>表示请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源</p>
</li>
<li>
<h3 id="304-not-modified">304 Not Modified</h3>
<p>表示客户端发送附带条件的请求时，服务器允许请求访问资源，但未找到满足条件的情况。</p>
</li>
<li>
<h3 id="307-temporary-redirect">307 Temporary Redirect</h3>
<p>临时冲顶先。与302相似。</p>
</li>
</ul>
<hr>
<h2 id="4-xx客户端错误"><strong>4 XX客户端错误</strong></h2>
<p>表明客户端发生错误的原因所在</p>
<ul>
<li>
<h3 id="400-bad-request">400 Bad Request</h3>
<p>该状态码表示请求报文中存在语法错误。需修改请求的内容后再次发送请求。</p>
</li>
<li>
<h3 id="401-unauthorized">401 Unauthorized</h3>
<p>表示发送的请求需要有通过HTTP认证的认证信息</p>
<p>当浏览器初次接收到401响应，会弹出认证用的对话窗口</p>
</li>
<li>
<h3 id="403-forbidden">403 Forbidden</h3>
<p>表明请求的资源的访问被服务器拒绝了</p>
<p>未获得文件系统的访问授权，访问权限出现某些问题等列举的情况都可能发生403的原因</p>
</li>
<li>
<h3 id="404-not-found">404 Not Found</h3>
<p>表明服务器上无法找到请求的资源。</p>
<hr>
</li>
</ul>
<h2 id="5-xx服务器错误"><strong>5 XX服务器错误</strong></h2>
<p>服务器本身的错误</p>
<ul>
<li>
<h3 id="500-internal-server-error">500 Internal Server Error</h3>
<p>表明服务器在执行请求时发生了错误。也有可能是WEB应用存在的bug或某些临时故障</p>
</li>
<li>
<h3 id="503-service-unavailable">503 Service Unavailable</h3>
<p>表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。</p>
</li>
</ul>
<p>​</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图解HTTP第三章]]></title>
        <id>https://fanfankill.github.io/post/tu-jie-http-di-san-zhang/</id>
        <link href="https://fanfankill.github.io/post/tu-jie-http-di-san-zhang/">
        </link>
        <updated>2021-04-25T06:01:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http报文内的http信息"><strong>HTTP报文内的HTTP信息</strong></h1>
<h2 id="http报文"><strong>HTTP报文</strong></h2>
<p>用于HTTP协议交互的信息被称为HTTP报文。请求端的HTTP报文叫做请求报文，响应端的叫做响应报文</p>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1619330989639.png" alt="" loading="lazy"></figure>
<hr>
<h3 id="请求行"><strong>请求行</strong></h3>
<p>请求行包括请求的方法，URI和HTTP的版本</p>
<hr>
<h3 id="状态行"><strong>状态行</strong></h3>
<p>包含响应结果的状态码，原因短语和HTTP版本</p>
<hr>
<h3 id="首部字段"><strong>首部字段</strong></h3>
<p>包含表示请求和响应的各种条件和属性的各类首部</p>
<hr>
<h1 id="编码提升传输速率"><strong>编码提升传输速率</strong></h1>
<h2 id="报文主体和实体主体的差异"><strong>报文主体和实体主体的差异</strong></h2>
<ul>
<li>
<p>报文</p>
<p><strong>是HTTP通信中的基本单位</strong>，有8个字节流组成，通过HTTP通信传输</p>
</li>
<li>
<p>实体</p>
<p>作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成</p>
</li>
</ul>
<p>HTTP报文的主体用于传输请求或响应的实体主体</p>
<hr>
<h2 id="压缩传输的内容编码"><strong>压缩传输的内容编码</strong></h2>
<figure data-type="image" tabindex="2"><img src="https://fanfankill.github.io/post-images/1619331895496.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="分割发送的分块传输编码">分割发送的分块传输编码</h2>
<p>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面</p>
<p><strong>分块传输编码</strong>会将实体主体分成多个部分。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用&quot;0(CR+LF)&quot;来标记</p>
<p>客户端复制解码，恢复到编码前的实体主体</p>
<hr>
<h1 id="发送多种数据的多部分对象集合">发送多种数据的多部分对象集合</h1>
<p>例如图片，文件的上传</p>
<p>在HTTP报文使用多部分对象集合时，需要在首部字段里加上Content-Type。</p>
<p>boundary字符串来划分多部分对象集合指明的各类实体</p>
<hr>
<h1 id="获取部分内容的范围请求">获取部分内容的范围请求</h1>
<p>指定范围发送的请求叫<strong>范围请求</strong><br>
<img src="https://fanfankill.github.io/post-images/1619332602950.png" alt="" loading="lazy"></p>
<hr>
<h1 id="内容协商返回最合适的内容">内容协商返回最合适的内容</h1>
<p>例网站的中英文版本，以下内容作为为判断标准</p>
<ul>
<li>Accept</li>
<li>Accept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language</li>
</ul>
<p>内容协商三种类型</p>
<h3 id="服务器驱动协商">服务器驱动协商</h3>
<h3 id="客户端驱动协商">客户端驱动协商</h3>
<h3 id="透明协商">透明协商</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图解HTTP 第二章]]></title>
        <id>https://fanfankill.github.io/post/tu-jie-http-di-er-zhang/</id>
        <link href="https://fanfankill.github.io/post/tu-jie-http-di-er-zhang/">
        </link>
        <updated>2021-04-23T02:19:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="http协议用于客户端和服务端之间的通信"><strong>HTTP协议用于客户端和服务端之间的通信</strong></h2>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1619145642116.png" alt="" loading="lazy"></figure>
<hr>
<br>
<figure data-type="image" tabindex="2"><img src="https://fanfankill.github.io/post-images/1619145670666.png" alt="" loading="lazy"></figure>
<hr>
<br>
<h2 id="http是不保存状态协议"><strong>HTTP是不保存状态协议</strong></h2>
<p>HTTP是不保存状态的协议，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。这样是为了更快的处理大量事务，确保协议的 可伸缩性</p>
<p>为了保证页面跳转时的状态保存，Cooike就被引入</p>
<br>
<p>## <em><strong>*请求URI定位资源*</strong></em></p>
<figure data-type="image" tabindex="3"><img src="https://fanfankill.github.io/post-images/1619145690268.png" alt="" loading="lazy"></figure>
<hr>
<br>
<h2 id="告知服务器意图的http方法"><strong>告知服务器意图的HTTP方法</strong></h2>
<p><strong>GET</strong>：获取资源</p>
<p>GET方法用来请求访问已被URI 识别的资源</p>
<figure data-type="image" tabindex="4"><img src="https://fanfankill.github.io/post-images/1619147700579.png" alt="" loading="lazy"></figure>
<hr>
<p><strong>POST</strong>：传输实体主体</p>
<p>POST传输更常用<br>
<img src="https://fanfankill.github.io/post-images/1619147796053.png" alt="" loading="lazy"></p>
<hr>
<p><strong>PUT</strong>：传输文件</p>
<p>PUT方法自身不带验证机制，在一般情况下不用<br>
<img src="https://fanfankill.github.io/post-images/1619147670212.png" alt="" loading="lazy"></p>
<hr>
<p><strong>HEAD</strong>：获得报文头部</p>
<p>HEAD方法和GET方法一样，只是不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等<br>
<img src="https://fanfankill.github.io/post-images/1619147639933.png" alt="" loading="lazy"></p>
<hr>
<p><strong>DELETE</strong>：删除文件</p>
<p>与PUT方法相反的方法，也是不带验证机制的方法<br>
<img src="https://fanfankill.github.io/post-images/1619147846458.png" alt="" loading="lazy"></p>
<hr>
<p><strong>OPTIONS</strong>：询问支持的方法</p>
<p>OPTIONS方法用来查询针对URI指定的资源支持的方法</p>
<hr>
<p><strong>TRACE</strong>：追踪路径<br>
TRACE方法是让WEB服务器端将之前的请求通信返回给客户端的方法<br>
客户端用于查询发送出去的请求怎样被加工的，但不常用</p>
<hr>
<h2 id="持久连接"><strong>持久连接</strong></h2>
<p>因为每进行一次HTTP通信就要断开一次TCP连接，对于网页的请求就要很多次的连接和断开操作，浪费通信量。</p>
<p>所以HTTP keep-alive的方法出现，只要任意一端没有明确提出断开连接，则保持TCP连接状态</p>
<hr>
<h2 id="使用cookie的状态管理"><strong>使用Cookie的状态管理</strong></h2>
<p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态</p>
<p>Cookie会根据从服务端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值发送出去</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图解HTTP 第一章]]></title>
        <id>https://fanfankill.github.io/post/tu-jie-http/</id>
        <link href="https://fanfankill.github.io/post/tu-jie-http/">
        </link>
        <updated>2021-04-22T03:03:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="http超文本传输协议">HTTP（超文本传输协议）</h2>
<br>
<h2 id="tcpip-分层">TCP/IP 分层</h2>
<ol>
<li>
<p><strong>应用层</strong></p>
<pre><code>  	     1. 决定向用户提供应用服务时通信的活动 (HTTP，FTP，DNS)  
</code></pre>
</li>
<li>
<p><strong>传输层</strong></p>
<pre><code>  	     1. 提供处于网络连接中两台计算机之间的数据传输
</code></pre>
</li>
<li>
<p><strong>网络层</strong></p>
<pre><code>  	     1. 处理网络上流动的数据包，为数据传输选择一条路线
</code></pre>
</li>
<li>
<p><strong>数据链路层</strong></p>
<pre><code>  	     1. 一些肉眼可见的硬件设施 网卡 光纤 等
</code></pre>
<br>
</li>
</ol>
<h2 id="tcpip通信传输流">TCP/IP通信传输流</h2>
<table>
<thead>
<tr>
<th>客户端</th>
<th style="text-align:center">过程</th>
<th style="text-align:right">服务器</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td style="text-align:center">HTTP数据</td>
<td style="text-align:right">应用层</td>
</tr>
<tr>
<td>传输层</td>
<td style="text-align:center">加/消去 TCP首部</td>
<td style="text-align:right">传输层</td>
</tr>
<tr>
<td>网络层</td>
<td style="text-align:center">加/消去 IP首部</td>
<td style="text-align:right">网络层</td>
</tr>
<tr>
<td>链路层</td>
<td style="text-align:center">加/消去 以太网首部</td>
<td style="text-align:right">链路层</td>
</tr>
</tbody>
</table>
<h1 id="与http关系紧密的协议"><strong>与HTTP关系紧密的协议</strong></h1>
<br>
<h3 id="负责传输的ip协议"><strong>负责传输的IP协议</strong></h3>
<p>IP(网际协议)处于网络层，IP协议的作用是把各种数据包传送给对方，而确保传送到对方那里，要满足各种条件。其中两个重要的条件就是<strong>IP地址</strong>和<strong>MAC地址</strong></p>
<p><strong>IP地址</strong>指明了节点被分配到的地址，<strong>Mac地址</strong>是指网卡所属的固定地址，IP地址可以和MAC地址进行匹配。IP地址可以变换，MAC地址基本不会更改</p>
<br>
<h3 id="arp协议"><strong>ARP协议</strong></h3>
<p>IP间的通信依赖MAC地址。在网络上，通信的双方在同一局域网（LAN）内的情况还是很少的，通常需要多台计算机和网络设备中转。而在进行中转时，<strong>会利用下一站中转设备的MAC地址来搜索下一个中转目标</strong>。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址<br>
<br></p>
<h3 id="tcp协议"><strong>TCP协议</strong></h3>
<p>TCP协议位于传输层，提供可靠的字节流服务。</p>
<p><strong>字节流服务</strong>指为了方便传输将大块数据分割成以报文段为单位的数据包进行管理</p>
<p><strong>可靠的服务</strong>指TCP协议能够确认数据最终是否送到对方</p>
<br>
<h4 id="确保数据能达到目标"><strong>确保数据能达到目标</strong></h4>
<p>TCP协议采用<strong>三次握手</strong>策略。用TCP协议把数据包送出去后，TCP一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN和——ACK。</p>
<p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后发送端再回传一个带ACK标志的数据包，代表“握手”结束</p>
<p>若在握手的过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包<br>
<br></p>
<h2 id="负责域名解析的dns服务"><strong>负责域名解析的DNS服务</strong></h2>
<p>DNS服务位于应用层的协议。它提供域名到IP地址之间的解析服务</p>
<p>DNS协议提供通过<strong>域名</strong>(例如 www.baidu.com)查找<strong>IP</strong>(14.215.177.39)，或逆向从IP反查域名的服务(cmd的nslookup 指令)</p>
<br>
<h2 id="各种协议与http协议的关系">各种协议与HTTP协议的关系</h2>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1619064689862.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正则表达式]]></title>
        <id>https://fanfankill.github.io/post/zheng-ze-biao-da-shi/</id>
        <link href="https://fanfankill.github.io/post/zheng-ze-biao-da-shi/">
        </link>
        <updated>2021-04-09T00:29:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="语法">语法</h1>
<p>runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。</p>
<p>runoo<em>b，可以匹配 runob、runoob、runoooooob 等，</em> 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</p>
<p>colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VUE 前置导航守卫]]></title>
        <id>https://fanfankill.github.io/post/vue-qian-zhi-dao-hang-shou-wei/</id>
        <link href="https://fanfankill.github.io/post/vue-qian-zhi-dao-hang-shou-wei/">
        </link>
        <updated>2021-04-07T11:48:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="路由守卫">路由守卫</h1>
<h2 id="当token不存在时-跳转到登陆界面">当token不存在时 跳转到登陆界面</h2>
<p><strong>只有登录界面时 (不考虑注册等其他界面)</strong></p>
<pre><code class="language-router.beforeEach((to,from,next)=&gt;{">  let token=localStorage.getItem(&quot;token&quot;);
  if(token){//判断是否登录
    next()
  }

  else{
    if(to.path!=='/login'){
      alert(&quot;请先登录&quot;)
      next({path:'/login'})
    }
    else{
      next()
    }
  }
});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛客]]></title>
        <id>https://fanfankill.github.io/post/niu-ke-cuo-ti/</id>
        <link href="https://fanfankill.github.io/post/niu-ke-cuo-ti/">
        </link>
        <updated>2021-04-06T01:50:43.000Z</updated>
        <content type="html"><![CDATA[<br>
<h1 id="3true">3==true</h1>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1617673888601.PNG" alt="" loading="lazy"></figure>
<br>
<br>
<br>
<h1 id="2tostring">2.toString()</h1>
<p><img src="https://fanfankill.github.io/post-images/1617673913588.PNG" alt="" loading="lazy"><br>
<br><br>
<br></p>
<h1 id="3-数组查重返回有重复的值">3 数组查重(返回有重复的值)</h1>
<pre><code>function(arr)
{
    let res=[];
    arr.forEach(function(val){
        //保证是重复项且新数组中没有存这项
        if(arr.indexOf(val)!=arr.lastIndexOf(val)&amp;&amp;res.indexOf(val)==-1)
        {
            res.push(val)
        }
    } )
    return res
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS基本数据类型]]></title>
        <id>https://fanfankill.github.io/post/js-ji-ben-shu-ju-lei-xing/</id>
        <link href="https://fanfankill.github.io/post/js-ji-ben-shu-ju-lei-xing/">
        </link>
        <updated>2021-04-05T14:10:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基本数据类型">基本数据类型</h1>
<p>ECMAScript中有5中简单数据类型（也称为基本数据类型）: Undefined、Null、Boolean、Number和String。还有1中复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。</p>
<br>
<h1 id="typeof-操作符">typeof 操作符</h1>
<p>由于js中的变量是松散类型的，所以它提供了一种检测当前变量的数据类型的方法，也就是typeof关键字.<br>
通过typeof关键字，对这5种数据类型会返回下面的值（以字符串形式显示)<br>
undefined ---------- 如果值未定义 Undefined</p>
<p>boolean ---------- 如果这个值是布尔值 Boolean</p>
<p>string ---------- 如果这个值是字符串 String</p>
<p>number ---------- 如果这个值是数值类型 Number</p>
<p>object ---------- 如果这个值是对象或null Object</p>
<p>需要注意的是typeof null返回为object,因为特殊值null被认为是一个空的对象引用。</p>
<br>
<h1 id="undefined">Undefined</h1>
<p>Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。不过，一般建议尽量给变量初始化，但是在早期的js版本中是没有规定undefined这个值的，所以在有些框架中为了兼容旧版浏览器，会给window对象添加undefined值。</p>
<pre><code>window['undefined'] = window['undefined'];  
//或者
window.undefined = window.undefined;  
</code></pre>
<br>
<h1 id="null">Null</h1>
<p>Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null时会返回object的原因。</p>
<pre><code> var car = null;
  console.log(typeof car); // &quot;object&quot;
</code></pre>
<p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检测null值就可以知道相应的变量是否已经保存了一个对象的引用了。<br>
例如：</p>
<pre><code>  if(car != null){
    //对car对象执行某些操作
  }
</code></pre>
<p>实际上，undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true。<br>
<code>console.log(undefined == null); //true</code><br>
尽管null和undefined有这样的关系，但它们的用途完全不同。无论在什么情况下都没有必要把一个变量的值显式地设置为undefined，可是同样的规则对null却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。</p>
  <br>
<h1 id="boolean">Boolean</h1>
<p>该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0。</p>
<p>虽然Boolean类型的字面值只有两个，但JavaScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean()，例如：</p>
<pre><code>var message = 'Hello World';
    var messageAsBoolean = Boolean(message);
</code></pre>
<p>在这个例子中，字符串message被转换成了一个Boolean值，该值被保存在messageAsBoolean变量中。可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值。至于返回的这个值是true还是false，取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对象的转换规则。</p>
<p>数据类型 转换为true的值	 转换为false的值<br>
Boolean	true	false<br>
String	任何非空的字符串	&quot;&quot;(空字符串)<br>
Number	任何非0数值（包括无穷大）	0和NAN<br>
Object	任何对象	null<br>
Undefined	不适用	undefined</p>
<br>
<h1 id="number">Number</h1>
<p>这种类型用来表示整数和浮点数值，还有一种特殊的数值，即NaN（非数值 Not a Number）。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在JavaScript中，任何数值除以0会返回NaN，因此不会影响其他代码的执行。</p>
<p>NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。例如，下面的代码会返回false。<br>
<code>alert(NaN == NaN); //false</code></p>
<p>#String<br>
String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由单引号(')或双引号(&quot;)表示。</p>
<h1 id="string类型的特殊性">String类型的特殊性</h1>
<p>string类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，我们希望JS只复制对字符串的引用，而不是字符串的内容。但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成行为与基本</p>
<h1 id="类型相似的不可变引用类型">类型相似的不可变引用类型</h1>
<p>Boolean、Number、String 这三个是Javascript中的基本包装类型，也就是这三个其实是一个构造函数，他们是Function的实例，是引用类型，至于这里的String与以上说的String是同名，是因为其实上文说的String是指字符串，这里的String指的是String这个构造函数，上面那么写，是为了更好的理解，因为Javascript是松散类型的。我们可以看下String实例化的例子：</p>
<pre><code>var name = String(&quot;jwy&quot;);
alert(typeof name);//&quot;string&quot;
var x=new String('12345')
typeof x //object
x='12345'
typeof x //string
var author = &quot;Tom&quot;;
alert(typeof name);//&quot;string&quot;
</code></pre>
<p>至于author这个会有length，substring等等这些方法，其实string只是String的一个实例，类似于C#中的String，和string.</p>
<p>注意，typeof 变量 如果值是&quot;string&quot; 的话，也就是这个变量是字符串，在Javascript中，字符串是基本类型，而在C#或Java中，字符串是引用类型，但是Javascript中的String是引用类型，因为它是Javascript中定义好的基本包装类型，在C#中，String跟string其实是一样的。</p>
<h1 id="es6新增">ES6新增</h1>
<p>es6中新增了let命令来声明变量、const命令声明一个只读的常量。</p>
<p>let的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<p>const一旦声明，常量的值就不能改变。</p>
<br>
<p><img src="https://fanfankill.github.io/post-images/1617632333308.JPG" alt="" loading="lazy"><br>
<img src="https://fanfankill.github.io/post-images/1617632362296.JPG" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>