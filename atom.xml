<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fanfankill.github.io</id>
    <title>fanfan</title>
    <updated>2021-07-19T03:53:28.865Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fanfankill.github.io"/>
    <link rel="self" href="https://fanfankill.github.io/atom.xml"/>
    <subtitle>&lt;strong&gt;前端小白&lt;/strong&gt;</subtitle>
    <logo>https://fanfankill.github.io/images/avatar.png</logo>
    <icon>https://fanfankill.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, fanfan</rights>
    <entry>
        <title type="html"><![CDATA[ Vue文档3]]></title>
        <id>https://fanfankill.github.io/post/vue-wen-dang-3/</id>
        <link href="https://fanfankill.github.io/post/vue-wen-dang-3/">
        </link>
        <updated>2021-07-18T06:14:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="prop">Prop</h2>
<p>字符串数组形式列出的 prop：</p>
<p><code>props: ['title', 'likes', 'isPublished', 'commentIds', 'author']</code></p>
<p>prop 各自的名称和类型</p>
<pre><code class="language-js">props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}
</code></pre>
<h2 id="传递静态或动态-prop">传递静态或动态 Prop</h2>
<p>给 prop 传入一个静态的值</p>
<p><code>&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</code></p>
<p>prop 可以通过 <code>v-bind</code> 动态赋值</p>
<pre><code class="language-js">&lt;!-- 动态赋予一个变量的值 --&gt;
&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;

&lt;!-- 动态赋予一个复杂表达式的值 --&gt;
&lt;blog-post
  v-bind:title=&quot;post.title + ' by ' + post.author.name&quot;
&gt;&lt;/blog-post&gt;
</code></pre>
<p>需要 <code>v-bind</code> 来告诉 Vue 这是一个 JavaScript 表达式而不是一个字符串。</p>
<ul>
<li>传入数字</li>
<li>传入布尔值</li>
<li>传入数组</li>
<li>传入对象</li>
</ul>
<h2 id="单向数据流">单向数据流</h2>
<p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行，这样会<strong>防止从子组件意外变更父级组件的状态</strong>，从而导致你的应用的数据流向难以理解。</p>
<p>每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop</p>
<p>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身<strong>将会</strong>影响到父组件的状态。</p>
<h2 id="prop-验证">Prop 验证</h2>
<p>例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你</p>
<pre><code class="language-js">Vue.component('my-component', {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
</code></pre>
<h2 id="替换合并已有的-attribute">替换/合并已有的 Attribute]</h2>
<p><code>class</code> 和 <code>style</code> attribute 值会被合并起来</p>
<h2 id="禁用-attribute-继承">禁用 Attribute 继承</h2>
<p>如果你<strong>不</strong>希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p>
<pre><code class="language-js">Vue.component('my-component', {
  inheritAttrs: false,
  // ...
})
</code></pre>
<h2 id="自定义事件"><strong>自定义事件</strong></h2>
<p>事件名不存在自动大小写转换，在<code>v-on</code>事件监听器DOM模板中会自动转化为小写</p>
<h2 id="自定义组件v-model">自定义组件<code>v-model</code></h2>
<p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件</p>
<p>但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于不同的目的</p>
<pre><code class="language-js">Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    &lt;input
      type=&quot;checkbox&quot;
      v-bind:checked=&quot;checked&quot;
      v-on:change=&quot;$emit('change', $event.target.checked)&quot;
    &gt;
  `
})
</code></pre>
<h2 id="将原生事件绑定到组件">将原生事件绑定到组件</h2>
<p>想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 <code>v-on</code> 的 <code>.native</code> 修饰符：</p>
<p>但元素实际上是一个 <code>&lt;label&gt;</code> 元素的时候监听不到：</p>
<p>包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定</p>
<p>$attrs可以接受上级传递过来的属性</p>
<pre><code class="language-js">&lt;label&gt;
  {{ label }}
  &lt;input
    v-bind=&quot;$attrs&quot;
    v-bind:value=&quot;value&quot;
    v-on:input=&quot;$emit('input', $event.target.value)&quot;
  &gt;
&lt;/label&gt;
</code></pre>
<p>Vue 提供了一个 <code>$listeners</code> property，它是一个对象，里面包含了作用在这个组件上的所有监听器</p>
<pre><code class="language-js">{
  focus: function (event) { /* ... */ }
  input: function (value) { /* ... */ },
}
</code></pre>
<p>就可以配合 <code>v-on=&quot;$listeners&quot;</code>将所有的事件监听器指向这个组件的某个特定的子元素</p>
<h2 id="sync-修饰符"><code>.sync</code> 修饰符</h2>
<p>真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件两侧都没有明显的变更来源</p>
<p>带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用</p>
<p>例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的</p>
<p>简写双向绑定的语法糖</p>
<p>父</p>
<p><code>&lt;child :title.sync=&quot;title&quot;&gt; &lt;/child&gt;</code></p>
<p>子</p>
<pre><code class="language-js"> &lt;input :value=&quot;title&quot; @input=&quot;abc&quot; type=&quot;text&quot;&gt;
    props: {
      title: {
        type: String,
        required: true
      }
    },
      methods: {
      abc(e) {
        console.log(e.target.value);
        this.$emit('update:title', e.target.value);
      }
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Vue文档2]]></title>
        <id>https://fanfankill.github.io/post/vue-wen-dang-2/</id>
        <link href="https://fanfankill.github.io/post/vue-wen-dang-2/">
        </link>
        <updated>2021-07-16T14:18:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="表单输入绑定">表单输入绑定</h2>
<p><code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定</p>
<p><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> attribute 的初始值而总是将 Vue 实例的数据作为数据来源</p>
<p><code>.lazy</code>    转为在 <code>change</code> 事件_之后_进行同步</p>
<p><code>&lt;input v-model.lazy=&quot;msg&quot;&gt;</code></p>
<br>
<p><code>.number</code>  自动将用户的输入值转为数值类型</p>
<p><code>.trim</code>   过滤用户输入的首尾空白字符</p>
<br>
<h2 id="组件基础">组件基础</h2>
<pre><code class="language-vue">// 定义一个名为 button-counter 的新组件
Vue.component('button-counter', {
  data: function () {
    return {
      count: 0
    }
  },
  template: '&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me {{ count }} times.&lt;/button&gt;'
})
</code></pre>
<pre><code class="language-vue">&lt;div id=&quot;components-demo&quot;&gt;
  &lt;button-counter&gt;&lt;/button-counter&gt;
&lt;/div&gt;
</code></pre>
<p><code>new Vue({ el: '#components-demo' })</code></p>
<br>
<h2 id="data-必须是一个函数"><code>data</code> 必须是一个函数</h2>
<p><strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，因此每个实例可以维护一份被返回对象的独立的拷贝：</p>
<h2 id="组件的组织">组件的组织</h2>
<p>两种组件的注册类型：<strong>全局注册</strong>和<strong>局部注册</strong></p>
<p>通过 <code>Vue.component</code> 全局注册</p>
<br>
<h2 id="prop向子组件传递数据">prop向子组件传递数据</h2>
<p>用<code>v-bind</code>来动态传递prop</p>
<h2 id="单个根元素">单个根元素</h2>
<p>将模板的内容包裹在一个父元素内(就是最外面的div)</p>
<h2 id="监听子组件事件">监听子组件事件</h2>
<p>通过 <code>v-on</code> 监听子组件实例的任意事件</p>
<p>同时子组件可以通过调用内建的 <strong><code>$emit</code></strong> 方法并传入事件名称来触发一个事件</p>
<h3 id="在组件上使用-v-model">在组件上使用 <code>v-model</code></h3>
<p><code>&lt;input v-model=&quot;searchText&quot;&gt;</code></p>
<p>等价于</p>
<pre><code class="language-js">&lt;input
  v-bind:value=&quot;searchText&quot;
  v-on:input=&quot;searchText = $event.target.value&quot;
&gt;
</code></pre>
<p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code> 必须：</p>
<ul>
<li>将其 **<code>value</code> **attribute 绑定到一个名叫 <code>value</code> 的 prop 上</li>
<li>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>input</code> 事件抛出</li>
</ul>
<pre><code class="language-vue">Vue.component('custom-input', {
  props: ['value'],
  template: `
    &lt;input
      v-bind:value=&quot;value&quot;
      v-on:input=&quot;$emit('input', $event.target.value)&quot;
    &gt;
  `
})
</code></pre>
<p>现在 <code>v-model</code> 就应该可以在这个组件上完美地工作起来了：</p>
<p><code>&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;</code></p>
<h2 id="通过插槽分发内容">通过插槽分发内容</h2>
<p>和 HTML 元素一样，我们经常需要向一个组件传递内容，像这样：</p>
<pre><code class="language-vue">&lt;alert-box&gt;
  Something bad happened.
&lt;/alert-box&gt;
</code></pre>
<pre><code class="language-vue">Vue.component('alert-box', {
  template: `
    &lt;div class=&quot;demo-alert-box&quot;&gt;
      &lt;strong&gt;Error!&lt;/strong&gt;
      &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
  `
})
</code></pre>
<h2 id="动态组件">动态组件</h2>
<p>上述内容可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> attribute 来实现：</p>
<pre><code class="language-js">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;
&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
</code></pre>
<p><code>currentTabComponent</code> 可以包括</p>
<ul>
<li>已注册组件的名字，或</li>
<li>一个组件的选项对象</li>
</ul>
<h2 id="全局注册">全局注册</h2>
<pre><code class="language-js">Vue.component('my-component-name', {
  // ... 选项 ...
})
</code></pre>
<h2 id="局部注册">局部注册</h2>
<p>全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。</p>
<pre><code class="language-js">var ComponentA = { /* ... */ }
</code></pre>
<p>然后在 <code>components</code> 选项中定义你想要使用的组件：</p>
<pre><code class="language-js">new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
  }
})
</code></pre>
<p>如果通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：</p>
<pre><code class="language-js">import ComponentA from './ComponentA.vue'

export default {
  components: {
    ComponentA
  },
  // ...
}
</code></pre>
<p>使用了诸如 Babel 和 webpack 的模块系统。在这些情况下我们推荐创建一个 <code>components</code> 目录，并将每个组件放置在其各自的文件中。</p>
<h2 id="基础组件的自动化全局注册">基础组件的自动化全局注册</h2>
<p>可以使用 <code>require.context</code> 只全局注册这些非常通用的基础组件</p>
<p><strong>全局注册的行为必须在根 Vue 实例 (通过 <code>new Vue</code>) 创建之前发生</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手写Promise]]></title>
        <id>https://fanfankill.github.io/post/shou-xie-promise/</id>
        <link href="https://fanfankill.github.io/post/shou-xie-promise/">
        </link>
        <updated>2021-07-16T05:00:42.000Z</updated>
        <content type="html"><![CDATA[<p>promise是用来解决两个问题的：</p>
<ul>
<li>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</li>
<li>promise可以支持多个并发的请求，获取并发请求中的数据</li>
<li>这个promise可以解决异步的问题，本身不能说promise是异步的</li>
</ul>
 <br>
<h2 id="实现代码"><strong>实现代码</strong></h2>
<pre><code class="language-js"> class mypromise {

        constructor(exeutor) {
            this.state = PENDING
            //成功的存储
            this.value = undefined
            //失败的存储
            this.reason = undefined

            //存放成功时候的回调函数
            this.ResolveCallbakc = []
            //存放失败时候的回调函数
            this.RejectCallback = []
            //要把这个值保存起来 调用then的时候还需要使用
            let resolve = (value) =&gt; {
                
                if (this.state == PENDING) {
                    //定时器用于then先注册才去改变状态 
                  setTimeout(()=&gt;{
                        //存起来
                    console.log('成功的构造');
                    this.value = value
                    //改变状态
                    this.state = FULFILLED
                    //全执行
                    this.ResolveCallbakc.forEach(fn =&gt; fn())  //发布过程
                  })
                }
            }
            let reject = (reason) =&gt; {

                if (this.state == PENDING) {
                setTimeout(()=&gt;{
                    console.log('失败的构造');
                    //也存起来
                    this.reason = reason

                    this.state = REJECTED

                    this.RejectCallback.forEach(fn =&gt; fn())
                })
                }
            }
            //传入两个参数 给用户来改变状态
            try {
                exeutor(resolve, reject)
            } catch (e) {
                //当前有异常
                reject(e)
            }
        }
        then(onfulfilled, onrejected) {
            if (this.state == FULFILLED) {
                onfulfilled(this.value)
               
            }
            if (this.state == REJECTED) {
                onrejected(this.reason)
             
            }
            if (this.state == PENDING) {
                console.log('推入函数');
                this.ResolveCallbakc.push(() =&gt; {
                    onfulfilled(this.value)
                })
                this.RejectCallback.push(() =&gt; {
                    onrejected(this.reason)
                })
                //链式调用
                return this;

            }

        }

    }
</code></pre>
<h2 id="实例"><strong>实例</strong></h2>
<pre><code class="language-js"> let fanfan = new mypromise((resolve, reject) =&gt; {
        console.log('?');
        resolve('fanfan')
    }).then(res =&gt; {
        setTimeout(()=&gt;{
            console.log('time');
        })
        console.log(res);

    }).then(res =&gt; {
        console.log('?');
        
    }).then(res=&gt;{
        console.log(res);
    })
 
 // 打印结果 可以看到先是then去注册完才去调用状态改变
 //先微后宏
 /**
 ?
promise2.html:78 推入函数
promise2.html:78 推入函数
promise2.html:78 推入函数
promise2.html:37 成功的构造
promise2.html:100 fanfan
promise2.html:103 ?
promise2.html:106 fanfan
promise2.html:98 time
 */
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS设计模式]]></title>
        <id>https://fanfankill.github.io/post/js-she-ji-mo-shi/</id>
        <link href="https://fanfankill.github.io/post/js-she-ji-mo-shi/">
        </link>
        <updated>2021-07-14T16:16:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="js的设计模式">JS的设计模式</h1>
<p><strong>什么是设计模式</strong></p>
<p>假设有一个空房间，我们要日复一日地往里 面放一些东西。最简单的办法当然是把这些东西 直接扔进去，但是时间久了，就会发现很难从这 个房子里找到自己想要的东西，要调整某几样东 西的位置也不容易。所以在房间里做一些柜子也 许是个更好的选择，虽然柜子会增加我们的成 本，但它可以在维护阶段为我们带来好处。使用 这些柜子存放东西的规则，或许就是一种模式</p>
<h2 id="单例模式">单例模式</h2>
<p>确保只有一个实例，并提供全局访问，类似闭包创建后都去访问一个。</p>
<h2 id="策略模式">策略模式</h2>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。表单验证用的多</p>
<h2 id="代理模式">代理模式</h2>
<p>为一个对象提供一个代用品或占位符，以便控制对它的访问，用于对数据进行处理后返回</p>
<h2 id="发布-订阅模式">发布-订阅模式</h2>
<p>也称作观察者模式（观察者模式子模式），定义了对象间的一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都将得到通知 。不直接建立关系，依靠一个中间商来建立</p>
<pre><code class="language-js">   // 观察者
var observer = {
    // 订阅集合
    subscribes: [],

    // 订阅 存放对应key
    subscribe: function(key, fn) {
        //不存在的情况下才默认为一个空数组
        if (!this.subscribes[key]) {
            this.subscribes[key] = [];
        }
      
        
        // 订阅者的处理  是函数就推进去
        typeof fn === 'function' &amp;&amp; this.subscribes[key].push(fn);
    },

    // 发布 
    publish: function() {
        
        var type =[].shift.call(arguments) // arguments[0]  去掉第一项 就是 key项 剩余项都是value项
        

            //调用对应key存的函数
            fns = this.subscribes[type];
           
        
        // 不存在的订阅类型，以及订阅时未传入处理回调的
        if (!fns || !fns.length) {
            return;
        }
        
        // 挨个处理调用 就是订阅同一个key很多次 然后一个个调用
        for (var i = 0; i &lt; fns.length; ++i) {
            fns[i].apply(this, arguments);
        }
    },
     
};


//实例


observer.subscribe('examinationA', function(score) {
    console.log(score);
});

observer.subscribe('examinationA', function(score) {
    console.log(score);
});

observer.publish('examinationA', 100); // 100  100  里面两个订阅都打印了出来
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-router]]></title>
        <id>https://fanfankill.github.io/post/vue-router/</id>
        <link href="https://fanfankill.github.io/post/vue-router/">
        </link>
        <updated>2021-07-13T08:55:32.000Z</updated>
        <content type="html"><![CDATA[<p><strong>这里的路由就是SPA（单页应用）的路径管理器</strong></p>
<p>路由用于设定访问路径，并将路径和组件映射起来</p>
<p><strong>单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面</strong></p>
<h4 id="1-hash模式">1、Hash模式：</h4>
<p><strong>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</strong></p>
<p>可以通过location.hast取得#后面的路由</p>
<p>window.onhashchange=functioin(){}    //当hash路由改变时候触发</p>
<h4 id="2-history模式">2、History模式：</h4>
<p>这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p>
<p>location.pathname 取得路由地址</p>
<p>onpopstate来监听history的路由变化</p>
<h4 id="3-使用路由模块来实现页面跳转的方式">3、使用路由模块来实现页面跳转的方式</h4>
<p>方式1：直接修改地址栏</p>
<p>方式2：this.$router.push(‘路由地址’)</p>
<p>方式3：<code>&lt;router-link to=&quot;路由地址&quot;&gt;&lt;/router-link&gt;</code></p>
<h4>4、实现方式</h4>
<p><code>Vue.use(VueRouter)</code></p>
<ol>
<li>执行VueRouter方法</li>
<li>如果这个方法有一个属性 install 并且这个属性是一个方法 就会执行install这个方法  例如 (VueRouter.install=function(){})</li>
<li>install这个方法的第一个参数 是vue</li>
</ol>
<p>​</p>
<h4>5、手写router</h4>
<pre><code class="language-js">//router的index文件

import  VueRouter from '../myrouter/index'
import  Vue from 'vue'

const register =() =&gt;import('../src/register')
const home =()=&gt;import('../src/home')

Vue.use(VueRouter)

const routes=[
    {
        path: '/register',
        name: '注册',
        component: register,
        title: '注册',
      }, {
        path: '/',
        name: '首页',
        component: home,
        title: '注册',
      },
   
   
]

const router = new VueRouter({
    routes
  })

export default router
</code></pre>
<pre><code class="language-js">//实现VueRouter实例 hash模式实现

let Vue

//注册一个类
class VueRouter{
    constructor(options)
    {
        console.log(options);

        let initPath='/' //默认值
        Vue.util.defineReactive(this,'current',initPath) //this指向VueRouter  响应式
        this.current='/' //当前路由
        this.routes=options.routes//用户路由规则
        this.mode=options.mode||'hash' //默认hash
        this.init() //监听路由改变
        
    }
    init()
    {
     
        if(this.mode=='hash'){
            console.log(location.hash); //拿到hash模式下的hash地址

            //监听第一次加载项目要加/#/
            window.addEventListener('load',()=&gt;{
                this.current=location.hash.slice(1)
    
            })
            //监听路由改变
            window.addEventListener('hashchange',()=&gt;{
                this.current=location.hash.slice(1)
            })
        }
    }
}

VueRouter.install=function(_Vue){
        Vue=_Vue

        //给调用组件添加一个属性  router
        Vue.mixin({  
            //全局添加数据和方法  vue3改为compostions api
            //每一个实例都是一个 $options api 例如app.vue 和main.js 里面的都是一个实例
            beforeCreate() {
                console.log(this.$options.name);
                if(this.$options.router)//根组件上才有的属性
                {
                    Vue.prototype.$router=this.$options.router //在Vue实例原生链上添加属性 实现全局添加this.$router属性
                }
            },
        })

        //创建全局组件
        //router-link 
        Vue.component('router-link',{
            //传参过来
            props:{
              to:{
                  type:String,
                  require:true
              }
            },
            render(h) {
                return h('a',{attrs:{
                    href:&quot;#&quot;+this.to
                }},this.$slots.default)//创建html的内容 就是插槽里面的内容
            },
        }),


        Vue.component('router-view',{
            //必须是响应式数据才能触发
            render(h) {

                //当前路由
                let current =this.$router.current
                console.log(current);
                //获取到了配置的路由数组  然后通过上面的取出对应的路由模块并且渲染出来
                let routers=this.$router.routes
                console.log(routers);

                //找出匹配的数组项
                let com=routers.find(item=&gt;{
                    return current==item.path
                })
                console.log(com);
                return h(com.component)//创建html
            },
        })
}


export default  VueRouter
</code></pre>
<pre><code class="language-js">//App.vue 文件

&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;


&lt;div class=&quot;tolink&quot;&gt;
    &lt;router-link to='/register'&gt;注册&lt;/router-link&gt;
    &lt;router-link to='/'&gt;home&lt;/router-link&gt;
   
&lt;/div&gt;
   &lt;div&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  name: 'App',
  beforeCreate() {
    console.log(this.$router);
  },
  data() {
    return {
  
    }
  },
 


}
&lt;/script&gt;

&lt;style&gt;
.tolink{
  width: 40%;
  margin: auto;
  display: flex;
  justify-content:space-between;
}
&lt;/style&gt;

</code></pre>
<p>实现效果</p>
<figure data-type="image" tabindex="1"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210713165156925.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210713165208681.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VUE文档]]></title>
        <id>https://fanfankill.github.io/post/vue-wen-dang/</id>
        <link href="https://fanfankill.github.io/post/vue-wen-dang/">
        </link>
        <updated>2021-07-11T11:20:09.000Z</updated>
        <content type="html"><![CDATA[<p>v-html :将模板字符串解析为html格式</p>
<p>split() 组成字符串数组</p>
<p>模板表达式都被放在沙盒中，只能访问<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9">全局变量的一个白名单</a>，如 <code>Math</code> 和 <code>Date</code> 。你不应该在模板表达式中试图访问用户定义的全局变量。</p>
<br>
<p>你可以使用动态参数为一个动态的事件名绑定处理函数：</p>
<pre><code class="language-js">&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;
</code></pre>
<p>当 <code>eventName</code> 的值为 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>。</p>
<h3 id="v-bind"><a href="https://cn.vuejs.org/v2/guide/syntax.html#v-bind-%E7%BC%A9%E5%86%99"><code>v-bind</code> 缩写</a></h3>
<pre><code class="language-js">&lt;!-- 完整语法 --&gt;
&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;

&lt;!-- 缩写 --&gt;
&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;

&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;
&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a&gt;
</code></pre>
<h3 id="v-on"><a href="https://cn.vuejs.org/v2/guide/syntax.html#v-on-%E7%BC%A9%E5%86%99"><code>v-on</code> 缩写</a></h3>
<pre><code class="language-js">&lt;!-- 完整语法 --&gt;
&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;

&lt;!-- 缩写 --&gt;
&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;

&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;
&lt;a @[event]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;
</code></pre>
<h2 id="计算属性和侦听器">计算属性和侦听器</h2>
<pre><code class="language-HTML">&lt;div id=&quot;example&quot;&gt;
  &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;
  &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-JS">var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
</code></pre>
<h3 id="计算属性缓存-vs-方法">计算属性缓存 vs 方法</h3>
<pre><code class="language-JS">&lt;p&gt;Reversed message: &quot;{{ reversedMessage() }}&quot;&lt;/p&gt;

// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
</code></pre>
<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。</p>
<p>这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
<p>所以计算属性要是响应试依赖</p>
<p>这也同样意味着下面的计算属性将不再更新，因为 <code>Date.now()</code> 不是响应式依赖：</p>
<pre><code class="language-js">computed: {
  now: function () {
    return Date.now()
  }
}
</code></pre>
<h2 id="计算属性-vs-侦听属性">计算属性 vs 侦听属性</h2>
<p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p>
<pre><code class="language-js">// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
</code></pre>
<p><strong>计算属性computed :</strong></p>
<ol>
<li>
<p>支持缓存，只有依赖数据发生改变，才会重新进行计算</p>
</li>
<li>
<p>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p>
</li>
</ol>
<p>​            3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行               缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p>
<ol start="4">
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li>
</ol>
<p>​           5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p>
<br>
<p><strong>侦听属性watch：</strong></p>
<ol>
<li>不支持缓存，数据变，直接会触发相应的操作；</li>
<li>watch支持异步；</li>
<li>当一个属性发生变化时，需要执行对应的操作；一对多；</li>
<li>监听数据必须是data中声明过或者父组件传递过来的props中的数据.函数有两个参数，
<ol>
<li>immediate：组件加载立即触发回调函数执行</li>
<li>deep: 深度监听，为了发现<strong>对象内部值</strong>的变化，复杂类型的数据时使用。deep无法监听到数组的变动和对象的新增</li>
</ol>
</li>
</ol>
<h2 id="条件渲染">条件渲染</h2>
<p>当 <code>v-if</code> 需要包裹多个元素时候 用 <code>&lt;template&gt;</code></p>
<p><code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</p>
<p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级</p>
<h2 id="事件处理方法">事件处理方法</h2>
<p>内联处理器中的方法</p>
<pre><code class="language-js">&lt;div id=&quot;example-3&quot;&gt; 
    &lt;button v-on:click=&quot;say('hi',$event)&quot;&gt;Say hi&lt;/button&gt;  
	&lt;button v-on:click=&quot;say('what')&quot;&gt;Say what&lt;/button&gt; &lt;/div&gt;

new Vue({
  el: '#example-3',
  methods: {
    say: function (message,event) {
      alert(message)
        // 现在我们可以访问原生事件对象
        if (event) {
          event.preventDefault()
        }
    }
  }
})
//有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：
</code></pre>
<h2 id="事情修饰符">事情修饰符</h2>
<p>原文博客(https://www.cnblogs.com/xiaoyaoxingchen/p/10405207.html)</p>
<ul>
<li>
<p><code>.stop</code>  阻止冒泡（通俗讲就是阻止事件向上级DOM元素传递）<br>
<img src="https://fanfankill.github.io/post-images/1626002759503.png" alt="" loading="lazy"></p>
</li>
<li>
<p><code>.prevent</code>  阻止默认事件的发生 例如a标签的跳转和表单的提交刷新</p>
</li>
<li></li>
<li>
<p><code>.capture</code> 捕获冒泡 即有冒泡发生时，有该修饰符的dom元素会先执行</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1626002752776.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><code>.self</code>  事件有自身才能触发，通常用于避免冒泡事件的影响<br>
<img src="https://fanfankill.github.io/post-images/1626002764276.png" alt="" loading="lazy"></p>
</li>
<li>
<p><code>.once</code>    只触发一次</p>
</li>
<li>
<p><code>.passive</code>   对DOM的默认事件进行性能优化</p>
</li>
<li>
<p><code>. native</code> 一般给组件绑定事件加的</p>
</li>
</ul>
<pre><code class="language-html">&lt;!-- 阻止单击事件继续传播 --&gt;
&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 修饰符可以串联 --&gt;
&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

&lt;!-- 只有修饰符 --&gt;
&lt;form v-on:submit.prevent&gt;&lt;/form&gt;

&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;
&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;
&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;
&lt;!-- 即事件不是从内部元素触发的 --&gt;
&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;
</code></pre>
<br>
<h2 id="按键修饰符">按键修饰符</h2>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“删除”和“退格”键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<pre><code class="language-js">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;
    &lt;input v-on:keyup.enter=&quot;submit&quot;&gt;
</code></pre>
<h2 id="系统修饰键">系统修饰键</h2>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<h2 id="exact"><code>.exact</code></h2>
<p>修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
<pre><code class="language-html">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;
&lt;button v-on:click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;
&lt;button v-on:click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;
&lt;button v-on:click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 媒体查询]]></title>
        <id>https://fanfankill.github.io/post/mei-ti-cha-xun/</id>
        <link href="https://fanfankill.github.io/post/mei-ti-cha-xun/">
        </link>
        <updated>2021-07-10T16:20:07.000Z</updated>
        <content type="html"><![CDATA[<p>媒体属性是CSS3新增的内容</p>
<p>媒体属性必须用括号()包起来</p>
<h5 id="media-媒体类型and-媒体特性你的样式">@media 媒体类型and （媒体特性）{你的样式}</h5>
<h2 id="最大宽度max-width">最大宽度max-width</h2>
<h5 id="意思是指媒体类型小于或等于指定的宽度时样式生效-如">意思是指媒体类型小于或等于指定的宽度时，样式生效。如：</h5>
<pre><code class="language-css">@media screen and (max-width:480px){
 body {
   display:none;
  }
}
</code></pre>
<h2 id="最小宽度min-width">最小宽度min-width</h2>
<pre><code class="language-css">@media screen and (min-width:600px) and (max-width:900px){
  body {background-color:#f5f5f5;}
}
</code></pre>
<h2 id="多个媒体特性使用"><strong>多个媒体特性使用</strong></h2>
<h5 id="media-query中可以包含0到多个表达式">Media Query中可以包含0到多个表达式</h5>
<pre><code class="language-css">/**当屏幕在600px~900px之间时，body的背景色渲染为“#f5f5f5”*/
@media screen and (min-width:600px) and (max-width:900px){
  body {background-color:#f5f5f5;}
}
</code></pre>
<h2 id="设备屏幕的输出宽度device-width"><strong>设备屏幕的输出宽度Device Width</strong></h2>
<h5 id="以根据屏幕设备的尺寸来设置相应的样式或者调用相应的样式文件">以根据屏幕设备的尺寸来设置相应的样式（或者调用相应的样式文件）</h5>
<pre><code class="language-xml">&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (max-device-width:480px)&quot; href=&quot;iphone.css&quot; /&gt;
</code></pre>
<h2 id="not关键词">not关键词</h2>
<h5 id="使用关键词not是用来排除某种制定的媒体类型">使用关键词“not”是用来排除某种制定的媒体类型</h5>
<pre><code class="language-css">@media not print and (max-width: 1200px){样式代码}
</code></pre>
<h2 id="only关键词">only关键词</h2>
<h5 id="only用来指定某种特定的媒体类型">only用来指定某种特定的媒体类型</h5>
<pre><code class="language-xml">&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (max-device-width:240px)&quot; href=&quot;android240.css&quot; /&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS度量单位 rem、em、vw、vh]]></title>
        <id>https://fanfankill.github.io/post/css-du-liang-dan-wei-rememvwvh/</id>
        <link href="https://fanfankill.github.io/post/css-du-liang-dan-wei-rememvwvh/">
        </link>
        <updated>2021-07-10T13:42:52.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1625924625206.png" alt="" loading="lazy"></figure>
<h2 id="em"><strong>em</strong></h2>
<p>继承父元素大小关系，2em 则为父元素大小的两倍  受自己上级节点影响</p>
<pre><code class="language-html">&lt;div class=&quot;div&quot; style=&quot;font-size:20px;&quot;&gt;div 标签中的文字大小为 20px
&lt;p class=&quot;p&quot; style=&quot;font-size:2em&quot;&gt;P 标签中的文字大小为 2em
&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>效果如下<br>
<br></p>
<style>
.div{font-size:20px;}
.p{font-size:2em;}
.span{font-size:0.5em;}
</style>
<div class="div" style="font-size:20px;">div 标签中的文字大小为 20px
<p class="p" style="font-size:2em">P 标签中的文字大小为 2em
    <span class="span" style="font-size:.5em">span标签中的文字大小为0.5em</span>
</p>
</div>
<br>
<h2 id="rem"><strong>rem</strong></h2>
<p>就是相对于根节点来进行缩放，如果有嵌套的关<br>
系，嵌套关系的元素的字体大小始终按照根节点的字体大小进行缩放</p>
<pre><code class="language-html">&lt;style&gt;
html{font-size:16px;}
.div{font-size:30px;background-color:pink;padding:50px;}
.p{font-size:1rem;}
.span{font-size:0.5rem;}
&lt;/style&gt;

&lt;div class=&quot;div&quot;&gt;div 标签中的文字大小为 30px
&lt;p class=&quot;p&quot;&gt;P 标签中的文字大小为 1rem
&lt;span class=&quot;span&quot;&gt;span 标 签 中 的 文 字 大 小 为
0.5rem&lt;/span&gt;
&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<div class="div" style="font-size:30px">div 标签中的文字大小为 30px
<p class="p" style="font-size:1rem;">P 标签中的文字大小为 1rem
<span class="span" style="font-size:.5rem">span 标 签 中 的 文 字 大 小 为
0.5rem</span>
</p>
</div>
<p><strong>这个rem继承的是html的font-size  默认为16px 这才是根节点</strong></p>
<br>
<br>
<h2 id="vw-和-vh"><strong>vw 和 vh</strong></h2>
<p>视窗的宽度和高度，相当于屏幕宽度和高度的 1%</p>
<p>处理宽度的时候%单位更合适，处理高度的话 vh 单位更好<br>
<br></p>
<h2 id="vmin-和-vmax"><strong>vmin 和 vmax</strong></h2>
<p>关于视口高度和宽度两者的最小值或者最大值。</p>
<p>如果你要让这个元素始终铺满整个视口的可见区域：</p>
<pre><code class="language-css">.box { 
height: 100vmax; 
width: 100vmax;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图片懒加载]]></title>
        <id>https://fanfankill.github.io/post/tu-pian-lan-jia-zai/</id>
        <link href="https://fanfankill.github.io/post/tu-pian-lan-jia-zai/">
        </link>
        <updated>2021-07-03T14:47:46.000Z</updated>
        <content type="html"><![CDATA[<p>实现图片懒加载先了解几个属性</p>
<ul>
<li>offsetWidth/offsetHeight</li>
</ul>
<p>对象的可见宽度</p>
<ul>
<li>clientWidth/clientHeight</li>
</ul>
<p>内容的可见宽度</p>
<ul>
<li>scrollWidth/scrollHeight</li>
</ul>
<p>元素完整的高度和宽度，overflow:hidden的部分也计算在内。</p>
<ul>
<li>offsetLeft/offsetTop</li>
</ul>
<p>当前元素距浏览器边界的偏移量，以像素为单位。</p>
<ul>
<li>clientTop/clientLeft</li>
</ul>
<p>这个属性测试下来的结果就是border。</p>
<ul>
<li>scrollLeft/scrollTop</li>
</ul>
<p>设置或返回已经滚动到元素的左边界或上边界的像素数。</p>
<h2 id="实现代码">实现代码</h2>
<pre><code class="language-js"> //显示器高度 window.innerHeight
    //图片到视窗上的距离 getBoundingClientRect().top
    let imgs=document.querySelectorAll('img')
    console.log(imgs);

    window.addEventListener('scroll',(e)=&gt;{
        imgs.forEach(v=&gt;{
            const imgtop=v.getBoundingClientRect().top
            console.log(imgtop);
            if(imgtop&lt;window.innerHeight)
            {
              
                let data_src=v.getAttribute('data-src')
                 v.setAttribute('src',data_src)
            }
            console.log('触发');
        })
    })

</code></pre>
<p>HTML</p>
<pre><code class="language-html">&lt;img  data-src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb1-q.mafengwo.net%2Fs7%2FM00%2F2E%2F37%2FwKgB6lSuHraAYMNtAAXF8ovILuk683.png&amp;refer=http%3A%2F%2Fb1-q.mafengwo.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1627892666&amp;t=953e6a19584b6772c33a1b84604fa63d&quot;&gt;
</code></pre>
<p><strong>感觉上面这样触发太频繁 加个节流吧</strong></p>
<pre><code class="language-JS">//节流写法
    window.onscroll = throttle(getscroll,200)
    



    //主体函数
    function getscroll() {
  
        let imgs = document.querySelectorAll('img')

        imgs.forEach(v=&gt;{
            const imgtop=v.getBoundingClientRect().top
            console.log(imgtop);
            if(imgtop&lt;window.innerHeight)
            {

                let data_src=v.getAttribute('data-src')
                 v.setAttribute('src',data_src)
            }
          
        })
    }

    //节流函数 过一段时间才触发
    function throttle(fn, delay) {
        let timer = true
        return function () {
            if (!timer) {
                return false
            }
  
            timer=false
            setTimeout(() =&gt; {
            fn()
            console.log('我是节流');
            timer = true;
        }, delay)

        }
    }

</code></pre>
<p><img src="https://fanfankill.github.io/post-images/1625323851326.png" alt="" loading="lazy"><br>
<img src="https://fanfankill.github.io/post-images/1625323855197.png" alt="" loading="lazy"></p>
<p>不节流效果</p>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1625323862788.png" alt="" loading="lazy"></figure>
<p>节流后的效果  200ms间隔</p>
<figure data-type="image" tabindex="2"><img src="https://fanfankill.github.io/post-images/1625323858842.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手写ajax]]></title>
        <id>https://fanfankill.github.io/post/shou-xie-axios/</id>
        <link href="https://fanfankill.github.io/post/shou-xie-axios/">
        </link>
        <updated>2021-06-26T13:00:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="axios">axios</h2>
<p>客户端  请求  服务端</p>
<ul>
<li>
<p>请求行</p>
<p>url</p>
<p>请求方式</p>
</li>
<li>
<p>多个请求头</p>
<p>域名，cooike，content-Type等</p>
</li>
<li>
<p>请求体</p>
</li>
</ul>
<p>post方法传的参数</p>
<p>服务端  响应  客户端</p>
<ul>
<li>
<p>响应行</p>
<p>status statusText</p>
</li>
<li>
<p>多个响应头</p>
<p>Content-Type:text/html</p>
</li>
<li>
<p>响应体</p>
<p>数据返回</p>
</li>
</ul>
<h2 id="xhr">XHR</h2>
<p>XMLHttpRequest对象可以和服务器交互 不会刷新网页</p>
<p>只有XHR和fetch发出的才是ajax请求</p>
<p>一般的请求就类似跳转和刷新页面</p>
<p>ajax只是调用监视回调函数并传入响应相关的数据</p>
<h2 id="api">API</h2>
<p>XMLHttpRequest() //创建XHR对象的构造函数</p>
<p>status：响应状态码</p>
<p>statusText：响应状态文本</p>
<p>onreadystatechange：绑定readyState改变的监听</p>
<p>open(method,url)：初始化请求</p>
<p>send(data)：发送请求</p>
<p>abort()：中断请求</p>
<br>
<br>
<h2 id="手写实现ajax">手写实现ajax</h2>
<pre><code class="language-js">&lt;script&gt;
    
    //接口在本地node.js实现
      function getdata()
    {
        console.log('发送get请求');
        ajax({
            url:'http://localhost:3000/getposition',
            parmas:{
               
            name:'fanfan',
            age:19,
            number:13142278876
            }
        }).then(res=&gt;{
            console.log(res);
        })
    }

    
    //ajax手写实现
     
    function ajax({
        //解构赋值  写好默认值
        url,
        method='GET',
        data={},
        parmas={},
    }){
        //返回promise对象
         return new Promise( (resolve,reject)=&gt;{
       
         //对url的处理  有些get请求参数需要拼接另外函数实现拼接
            url+='?'+pinjie(parmas)
    
             //创建xhr对象
             const request=new XMLHttpRequest()
            //打开连接
             request.open(method,url,true) 
            //转换为JSON对象 
            if(method=='GET')
            {
                request.send()
            }
           else if(method=='post')
           {
          
           //发送JSON格式的对象肯定要加请求头 告诉服务器请求体是JSON格式
            request.setRequestHeader('Content-Type','application/json;charset=uft-8')
            //转换为JSON发送
            request.send(JSON.stringify(data))
           }
    
           //绑定状态改变的监听 从发送变为成功或者失败调用的函数
           request.onreadystatechange=function(){
                //进入判断 如果请求没有完成 直接结束
                if(request.readyState!==4)
                {
                    return 
                }
                //如果响应状态码在 200~299为成功
                const {status,statusText} =request
                //自己加的属性
                let author='fanfan'
                
                if(status&gt;=200&amp;&amp;status&lt;=299)
                {
                    //准备结果对象response 的其中几条
                    const response={
                        //对应返回的数据可以知道这些东西是什么
                        data:JSON.parse(request.response),
                        status,
                        statusText,
                        //自己添加的属性
                        author
                      
                    }
                    resolve(response)
                }else{
                    //请求失败返回message信息和状态码
                    reject(new Error('requset error status is '+status))
                }
           }
              
         })
    }

    //拼接参数 for-in解决
    function pinjie(obj)
    {
        let  queryString=''
        for(let k in obj)
        {
            queryString+= k+'='+obj[k]+'&amp;'
        }
        //判断有没有值
        if(queryString)
        {
            queryString=queryString.slice(0,queryString.length-1)
        }
        //拼接到url上面
       return  queryString
    }
    
    
&lt;/script&gt;


</code></pre>
<br>
<br>
<h2 id="实现结果">实现结果</h2>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1624712565528.png" alt="" loading="lazy"></figure>
<h2 id="axios特点">axios特点</h2>
<ul>
<li>
<p>基本promise的异步ajax请求库</p>
</li>
<li>
<p>浏览器和node都可以使用</p>
</li>
<li>
<p>支持请求/响应数据转换</p>
</li>
<li>
<p>支持请求取消</p>
</li>
</ul>
<h2 id="多个请求响应拦截器-洋葱模型">多个请求/响应拦截器  （洋葱模型）</h2>
<p>请求拦截器 先添加后执行  响应拦截器 先添加先执行</p>
<pre><code class="language-js"> //添加请求拦截器
    axios.interceptors.request.use(
        config=&gt;{
            console.log('request interceptor1');
            return config
        },
        error=&gt;{
            return Promise.reject(error)
        }
    )

     //添加请求拦截器
     axios.interceptors.request.use(
        config=&gt;{
            console.log('request interceptor2');
            return config
        },
        error=&gt;{
            return Promise.reject(error)
        }
    )
    //添加响应拦截器
    axios.interceptors.response.use(
        response=&gt;{
            console.log('response interceptor1');
            return response
        },error=&gt;{
            return Promise.reject(error)
        }
    )
      //添加响应拦截器
      axios.interceptors.response.use(
        response=&gt;{
            console.log('response interceptor2');
            return response
        },error=&gt;{
            return Promise.reject(error)
        }
    )


 //config 就是传的配置文件 不返回的话就传不过去

//response return的结果会给下一个响应拦截器 最后执行.then(res) 将数据传给res


/*request interceptor2
request interceptor1
response interceptor1
response interceptor2*/

</code></pre>
]]></content>
    </entry>
</feed>