<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fanfankill.github.io</id>
    <title>fanfan</title>
    <updated>2021-04-24T06:26:15.934Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fanfankill.github.io"/>
    <link rel="self" href="https://fanfankill.github.io/atom.xml"/>
    <subtitle>前端小白</subtitle>
    <logo>https://fanfankill.github.io/images/avatar.png</logo>
    <icon>https://fanfankill.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, fanfan</rights>
    <entry>
        <title type="html"><![CDATA[图解HTTP 第二章]]></title>
        <id>https://fanfankill.github.io/post/tu-jie-http-di-er-zhang/</id>
        <link href="https://fanfankill.github.io/post/tu-jie-http-di-er-zhang/">
        </link>
        <updated>2021-04-23T02:19:27.000Z</updated>
        <content type="html"><![CDATA[<p>## <em><strong>*HTTP协议用于客户端和服务端之间的通信*</strong></em></p>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1619145642116.png" alt="" loading="lazy"></figure>
<hr>
<br>
<figure data-type="image" tabindex="2"><img src="https://fanfankill.github.io/post-images/1619145670666.png" alt="" loading="lazy"></figure>
<hr>
<br>
<p>## <em><strong>*HTTP是不保存状态协议*</strong></em></p>
<p>HTTP是不保存状态的协议，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。这样是为了更快的处理大量事务，确保协议的 可伸缩性</p>
<p>为了保证页面跳转时的状态保存，Cooike就被引入</p>
<br>
<p>## <em><strong>*请求URI定位资源*</strong></em></p>
<figure data-type="image" tabindex="3"><img src="https://fanfankill.github.io/post-images/1619145690268.png" alt="" loading="lazy"></figure>
<hr>
<br>
<h2 id="告知服务器意图的http方法"><strong>告知服务器意图的HTTP方法</strong></h2>
<p><strong>GET</strong>：获取资源</p>
<p>GET方法用来请求访问已被URI 识别的资源</p>
<figure data-type="image" tabindex="4"><img src="https://fanfankill.github.io/post-images/1619147700579.png" alt="" loading="lazy"></figure>
<hr>
<p><strong>POST</strong>：传输实体主体</p>
<p>POST传输更常用<br>
<img src="https://fanfankill.github.io/post-images/1619147796053.png" alt="" loading="lazy"></p>
<hr>
<p><strong>PUT</strong>：传输文件</p>
<p>PUT方法自身不带验证机制，在一般情况下不用<br>
<img src="https://fanfankill.github.io/post-images/1619147670212.png" alt="" loading="lazy"></p>
<hr>
<p><strong>HEAD</strong>：获得报文头部</p>
<p>HEAD方法和GET方法一样，只是不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等<br>
<img src="https://fanfankill.github.io/post-images/1619147639933.png" alt="" loading="lazy"></p>
<hr>
<p><strong>DELETE</strong>：删除文件</p>
<p>与PUT方法相反的方法，也是不带验证机制的方法<br>
<img src="https://fanfankill.github.io/post-images/1619147846458.png" alt="" loading="lazy"></p>
<hr>
<p><strong>OPTIONS</strong>：询问支持的方法</p>
<p>OPTIONS方法用来查询针对URI指定的资源支持的方法</p>
<hr>
<p><strong>TRACE</strong>：追踪路径<br>
TRACE方法是让WEB服务器端将之前的请求通信返回给客户端的方法<br>
客户端用于查询发送出去的请求怎样被加工的，但不常用</p>
<hr>
<h2 id="持久连接"><strong>持久连接</strong></h2>
<p>因为每进行一次HTTP通信就要断开一次TCP连接，对于网页的请求就要很多次的连接和断开操作，浪费通信量。</p>
<p>所以HTTP keep-alive的方法出现，只要任意一端没有明确提出断开连接，则保持TCP连接状态</p>
<hr>
<h2 id="使用cookie的状态管理"><strong>使用Cookie的状态管理</strong></h2>
<p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态</p>
<p>Cookie会根据从服务端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值发送出去</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图解HTTP 第一章]]></title>
        <id>https://fanfankill.github.io/post/tu-jie-http/</id>
        <link href="https://fanfankill.github.io/post/tu-jie-http/">
        </link>
        <updated>2021-04-22T03:03:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="http超文本传输协议">HTTP（超文本传输协议）</h2>
<br>
<h2 id="tcpip-分层">TCP/IP 分层</h2>
<ol>
<li>
<p><strong>应用层</strong></p>
<pre><code>  	     1. 决定向用户提供应用服务时通信的活动 (HTTP，FTP，DNS)  
</code></pre>
</li>
<li>
<p><strong>传输层</strong></p>
<pre><code>  	     1. 提供处于网络连接中两台计算机之间的数据传输
</code></pre>
</li>
<li>
<p><strong>网络层</strong></p>
<pre><code>  	     1. 处理网络上流动的数据包，为数据传输选择一条路线
</code></pre>
</li>
<li>
<p><strong>数据链路层</strong></p>
<pre><code>  	     1. 一些肉眼可见的硬件设施 网卡 光纤 等
</code></pre>
<br>
</li>
</ol>
<h2 id="tcpip通信传输流">TCP/IP通信传输流</h2>
<table>
<thead>
<tr>
<th>客户端</th>
<th style="text-align:center">过程</th>
<th style="text-align:right">服务器</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td style="text-align:center">HTTP数据</td>
<td style="text-align:right">应用层</td>
</tr>
<tr>
<td>传输层</td>
<td style="text-align:center">加/消去 TCP首部</td>
<td style="text-align:right">传输层</td>
</tr>
<tr>
<td>网络层</td>
<td style="text-align:center">加/消去 IP首部</td>
<td style="text-align:right">网络层</td>
</tr>
<tr>
<td>链路层</td>
<td style="text-align:center">加/消去 以太网首部</td>
<td style="text-align:right">链路层</td>
</tr>
</tbody>
</table>
<h1 id="与http关系紧密的协议"><strong>与HTTP关系紧密的协议</strong></h1>
<br>
<h3 id="负责传输的ip协议"><strong>负责传输的IP协议</strong></h3>
<p>IP(网际协议)处于网络层，IP协议的作用是把各种数据包传送给对方，而确保传送到对方那里，要满足各种条件。其中两个重要的条件就是<strong>IP地址</strong>和<strong>MAC地址</strong></p>
<p><strong>IP地址</strong>指明了节点被分配到的地址，<strong>Mac地址</strong>是指网卡所属的固定地址，IP地址可以和MAC地址进行匹配。IP地址可以变换，MAC地址基本不会更改</p>
<br>
<h3 id="arp协议"><strong>ARP协议</strong></h3>
<p>IP间的通信依赖MAC地址。在网络上，通信的双方在同一局域网（LAN）内的情况还是很少的，通常需要多台计算机和网络设备中转。而在进行中转时，<strong>会利用下一站中转设备的MAC地址来搜索下一个中转目标</strong>。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址<br>
<br></p>
<h3 id="tcp协议"><strong>TCP协议</strong></h3>
<p>TCP协议位于传输层，提供可靠的字节流服务。</p>
<p><strong>字节流服务</strong>指为了方便传输将大块数据分割成以报文段为单位的数据包进行管理</p>
<p><strong>可靠的服务</strong>指TCP协议能够确认数据最终是否送到对方</p>
<br>
<h4 id="确保数据能达到目标"><strong>确保数据能达到目标</strong></h4>
<p>TCP协议采用<strong>三次握手</strong>策略。用TCP协议把数据包送出去后，TCP一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN和——ACK。</p>
<p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后发送端再回传一个带ACK标志的数据包，代表“握手”结束</p>
<p>若在握手的过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包<br>
<br></p>
<h2 id="负责域名解析的dns服务"><strong>负责域名解析的DNS服务</strong></h2>
<p>DNS服务位于应用层的协议。它提供域名到IP地址之间的解析服务</p>
<p>DNS协议提供通过<strong>域名</strong>(例如 www.baidu.com)查找<strong>IP</strong>(14.215.177.39)，或逆向从IP反查域名的服务(cmd的nslookup 指令)</p>
<br>
<h2 id="各种协议与http协议的关系">各种协议与HTTP协议的关系</h2>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1619064689862.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正则表达式]]></title>
        <id>https://fanfankill.github.io/post/zheng-ze-biao-da-shi/</id>
        <link href="https://fanfankill.github.io/post/zheng-ze-biao-da-shi/">
        </link>
        <updated>2021-04-09T00:29:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="语法">语法</h1>
<p>runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。</p>
<p>runoo<em>b，可以匹配 runob、runoob、runoooooob 等，</em> 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</p>
<p>colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VUE 前置导航守卫]]></title>
        <id>https://fanfankill.github.io/post/vue-qian-zhi-dao-hang-shou-wei/</id>
        <link href="https://fanfankill.github.io/post/vue-qian-zhi-dao-hang-shou-wei/">
        </link>
        <updated>2021-04-07T11:48:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="路由守卫">路由守卫</h1>
<h2 id="当token不存在时-跳转到登陆界面">当token不存在时 跳转到登陆界面</h2>
<p><strong>只有登录界面时 (不考虑注册等其他界面)</strong></p>
<pre><code class="language-router.beforeEach((to,from,next)=&gt;{">  let token=localStorage.getItem(&quot;token&quot;);
  if(token){//判断是否登录
    next()
  }

  else{
    if(to.path!=='/login'){
      alert(&quot;请先登录&quot;)
      next({path:'/login'})
    }
    else{
      next()
    }
  }
});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛客]]></title>
        <id>https://fanfankill.github.io/post/niu-ke-cuo-ti/</id>
        <link href="https://fanfankill.github.io/post/niu-ke-cuo-ti/">
        </link>
        <updated>2021-04-06T01:50:43.000Z</updated>
        <content type="html"><![CDATA[<br>
<h1 id="3true">3==true</h1>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1617673888601.PNG" alt="" loading="lazy"></figure>
<br>
<br>
<br>
<h1 id="2tostring">2.toString()</h1>
<figure data-type="image" tabindex="2"><img src="https://fanfankill.github.io/post-images/1617673913588.PNG" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS基本数据类型]]></title>
        <id>https://fanfankill.github.io/post/js-ji-ben-shu-ju-lei-xing/</id>
        <link href="https://fanfankill.github.io/post/js-ji-ben-shu-ju-lei-xing/">
        </link>
        <updated>2021-04-05T14:10:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基本数据类型">基本数据类型</h1>
<p>ECMAScript中有5中简单数据类型（也称为基本数据类型）: Undefined、Null、Boolean、Number和String。还有1中复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。</p>
<br>
<h1 id="typeof-操作符">typeof 操作符</h1>
<p>由于js中的变量是松散类型的，所以它提供了一种检测当前变量的数据类型的方法，也就是typeof关键字.<br>
通过typeof关键字，对这5种数据类型会返回下面的值（以字符串形式显示)<br>
undefined ---------- 如果值未定义 Undefined</p>
<p>boolean ---------- 如果这个值是布尔值 Boolean</p>
<p>string ---------- 如果这个值是字符串 String</p>
<p>number ---------- 如果这个值是数值类型 Number</p>
<p>object ---------- 如果这个值是对象或null Object</p>
<p>需要注意的是typeof null返回为object,因为特殊值null被认为是一个空的对象引用。</p>
<br>
<h1 id="undefined">Undefined</h1>
<p>Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。不过，一般建议尽量给变量初始化，但是在早期的js版本中是没有规定undefined这个值的，所以在有些框架中为了兼容旧版浏览器，会给window对象添加undefined值。</p>
<pre><code>window['undefined'] = window['undefined'];  
//或者
window.undefined = window.undefined;  
</code></pre>
<br>
<h1 id="null">Null</h1>
<p>Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null时会返回object的原因。</p>
<pre><code> var car = null;
  console.log(typeof car); // &quot;object&quot;
</code></pre>
<p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检测null值就可以知道相应的变量是否已经保存了一个对象的引用了。<br>
例如：</p>
<pre><code>  if(car != null){
    //对car对象执行某些操作
  }
</code></pre>
<p>实际上，undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true。<br>
<code>console.log(undefined == null); //true</code><br>
尽管null和undefined有这样的关系，但它们的用途完全不同。无论在什么情况下都没有必要把一个变量的值显式地设置为undefined，可是同样的规则对null却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。</p>
  <br>
<h1 id="boolean">Boolean</h1>
<p>该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0。</p>
<p>虽然Boolean类型的字面值只有两个，但JavaScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean()，例如：</p>
<pre><code>var message = 'Hello World';
    var messageAsBoolean = Boolean(message);
</code></pre>
<p>在这个例子中，字符串message被转换成了一个Boolean值，该值被保存在messageAsBoolean变量中。可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值。至于返回的这个值是true还是false，取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对象的转换规则。</p>
<p>数据类型 转换为true的值	 转换为false的值<br>
Boolean	true	false<br>
String	任何非空的字符串	&quot;&quot;(空字符串)<br>
Number	任何非0数值（包括无穷大）	0和NAN<br>
Object	任何对象	null<br>
Undefined	不适用	undefined</p>
<br>
<h1 id="number">Number</h1>
<p>这种类型用来表示整数和浮点数值，还有一种特殊的数值，即NaN（非数值 Not a Number）。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在JavaScript中，任何数值除以0会返回NaN，因此不会影响其他代码的执行。</p>
<p>NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。例如，下面的代码会返回false。<br>
<code>alert(NaN == NaN); //false</code></p>
<p>#String<br>
String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由单引号(')或双引号(&quot;)表示。</p>
<h1 id="string类型的特殊性">String类型的特殊性</h1>
<p>string类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，我们希望JS只复制对字符串的引用，而不是字符串的内容。但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成行为与基本</p>
<h1 id="类型相似的不可变引用类型">类型相似的不可变引用类型</h1>
<p>Boolean、Number、String 这三个是Javascript中的基本包装类型，也就是这三个其实是一个构造函数，他们是Function的实例，是引用类型，至于这里的String与以上说的String是同名，是因为其实上文说的String是指字符串，这里的String指的是String这个构造函数，上面那么写，是为了更好的理解，因为Javascript是松散类型的。我们可以看下String实例化的例子：</p>
<pre><code>var name = String(&quot;jwy&quot;);
alert(typeof name);//&quot;string&quot;
var x=new String('12345')
typeof x //object
x='12345'
typeof x //string
var author = &quot;Tom&quot;;
alert(typeof name);//&quot;string&quot;
</code></pre>
<p>至于author这个会有length，substring等等这些方法，其实string只是String的一个实例，类似于C#中的String，和string.</p>
<p>注意，typeof 变量 如果值是&quot;string&quot; 的话，也就是这个变量是字符串，在Javascript中，字符串是基本类型，而在C#或Java中，字符串是引用类型，但是Javascript中的String是引用类型，因为它是Javascript中定义好的基本包装类型，在C#中，String跟string其实是一样的。</p>
<h1 id="es6新增">ES6新增</h1>
<p>es6中新增了let命令来声明变量、const命令声明一个只读的常量。</p>
<p>let的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<p>const一旦声明，常量的值就不能改变。</p>
<br>
<p><img src="https://fanfankill.github.io/post-images/1617632333308.JPG" alt="" loading="lazy"><br>
<img src="https://fanfankill.github.io/post-images/1617632362296.JPG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS3动画属性]]></title>
        <id>https://fanfankill.github.io/post/js/</id>
        <link href="https://fanfankill.github.io/post/js/">
        </link>
        <updated>2021-04-04T08:14:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="animation-属性"><strong>animation 属性</strong></h2>
<br>
<br>
<p><strong>animation-delay</strong></p>
<p>​       属性规定动画开始的延迟时间(2秒延时)</p>
<p>​            <code>animation-delay: 2s;</code></p>
<p>​        负值也是允许的。如果使用负值，则动画将开始播放，如同已播放 N 秒</p>
<p>​            <code>animation-delay: -2s;</code></p>
<br>
<br>
<p><strong>animation-iteration-count</strong></p>
<p>​		 属性指定动画应运行的次数</p>
<pre><code>		` animation-iteration-count: 3;`
</code></pre>
<p>​		使用值 &quot;infinite&quot; 使动画永远持续下去</p>
<br>
<br>
<p><strong>animation-direction</strong></p>
<p>​		属性指定是向前播放、向后播放还是交替播放动画</p>
<ul>
<li>normal - 动画正常播放（向前）。默认值</li>
<li>reverse - 动画以反方向播放（向后）</li>
<li>alternate - 动画先向前播放，然后向后</li>
<li>alternate-reverse - 动画先向后播放，然后向前</li>
</ul>
<br>
<br>
<p><strong>animation-timing-function</strong></p>
<p>​		属性规定动画的速度曲线</p>
<ul>
<li>ease - 指定从慢速开始，然后加快，然后缓慢结束的动画（默认）</li>
<li>linear - 规定从开始到结束的速度相同的动画</li>
<li>ease-in - 规定慢速开始的动画</li>
<li>ease-out - 规定慢速结束的动画</li>
<li>ease-in-out - 指定开始和结束较慢的动画</li>
<li>cubic-bezier(n,n,n,n) - 运行您在三次贝塞尔函数中定义自己的值</li>
</ul>
<br>
<br>
<p><strong>animation-fill-mode</strong></p>
<p>​		CSS 动画不会在第一个关键帧播放之前或在最后一个关键帧播放之后影响元素</p>
<ul>
<li>none - 默认值。动画在执行之前或之后不会对元素应用任何样式。</li>
<li>forwards - 元素将保留由最后一个关键帧设置的样式值（依赖 animation-direction 和 animation-iteration-count）。</li>
<li>backwards - 元素将获取由第一个关键帧设置的样式值（取决于 animation-direction），并在动画延迟期间保留该值。</li>
<li>both - 动画会同时遵循向前和向后的规则，从而在两个方向上扩展动画属性。</li>
</ul>
<br>
<br>
<pre><code>
//使用简写属性，将动画与 div 元素绑定：

div

{

animation:mymove 5s infinite;

-webkit-animation:mymove 5s infinite; /* Safari 和 Chrome */

}



//动画帧

 @keyframes mymove {

​          50% {transform-origin: 0 0 0;transform: rotate(360deg);background-color: rgb(83, 83, 90);}

​        

​        }

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1617525832441.png" alt="" loading="lazy"></figure>
<p>## <strong>动画可用属性</strong></p>
<figure data-type="image" tabindex="2"><img src="https://fanfankill.github.io/post-images/1617524085576.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目cooike实现保存账号密码功能]]></title>
        <id>https://fanfankill.github.io/post/xiang-mu-cooike-dai-ma/</id>
        <link href="https://fanfankill.github.io/post/xiang-mu-cooike-dai-ma/">
        </link>
        <updated>2021-04-04T06:15:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cooike详细介绍">cooike详细介绍</h1>
<p><a href="https://blog.csdn.net/qq_37002901/article/details/86601904"><strong>原文博客</strong></a></p>
<h1 id="cooike储存机制">cooike储存机制</h1>
<p><code>Set-Cookie: name=value[; expires=GMTDate][; domain=domain][; path=path][; secure]</code></p>
<h1 id="项目实现代码">项目实现代码</h1>
<pre><code>    //获取储存的cooike
getCookie(name) {
     var reg=RegExp(name+'=([^;]+)');
     var arr=document.cookie.match(reg);
     if(arr)
     {
       return arr[1];
     }else{
       return '';
     }
}
</code></pre>
<pre><code>/**存放cookie */

  setCookie(name, value, day) {

   let data = new Date();

   data.setDate(data.getDate() + day);

   document.cookie = name + &quot;=&quot; + value + &quot;;expires=&quot; + data;

  },
</code></pre>
<pre><code>/**删除cooike*/
delCookie(name) {

   this.setCookie(name, '', -1);

  },
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[markdown基本语法]]></title>
        <id>https://fanfankill.github.io/post/markdown-ji-ben-yu-fa/</id>
        <link href="https://fanfankill.github.io/post/markdown-ji-ben-yu-fa/">
        </link>
        <updated>2021-04-03T15:16:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="对必要语法的摘记">对必要语法的摘记</h1>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1617462999416.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://fanfankill.github.io/post/hello-gridea/</id>
        <link href="https://fanfankill.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://4399.com">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a><br>
<img src="https://fanfankill.github.io/post-images/1617460798662.jpg" alt="" loading="lazy"></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力<br>
sdsd<br>
🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>