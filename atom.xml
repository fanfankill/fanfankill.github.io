<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fanfankill.github.io</id>
    <title>fanfan</title>
    <updated>2021-04-08T13:11:11.610Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fanfankill.github.io"/>
    <link rel="self" href="https://fanfankill.github.io/atom.xml"/>
    <subtitle>前端小白</subtitle>
    <logo>https://fanfankill.github.io/images/avatar.png</logo>
    <icon>https://fanfankill.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, fanfan</rights>
    <entry>
        <title type="html"><![CDATA[VUE 前置导航守卫]]></title>
        <id>https://fanfankill.github.io/post/vue-qian-zhi-dao-hang-shou-wei/</id>
        <link href="https://fanfankill.github.io/post/vue-qian-zhi-dao-hang-shou-wei/">
        </link>
        <updated>2021-04-07T11:48:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="路由守卫">路由守卫</h1>
<h2 id="当token不存在时-跳转到登陆界面">当token不存在时 跳转到登陆界面</h2>
<p><strong>只有登录界面时 (不考虑注册等其他界面)</strong></p>
<pre><code class="language-router.beforeEach((to,from,next)=&gt;{">  let token=localStorage.getItem(&quot;token&quot;);
  if(token){//判断是否登录
    next()
  }

  else{
    if(to.path!=='/login'){
      alert(&quot;请先登录&quot;)
      next({path:'/login'})
    }
    else{
      next()
    }
  }
});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛客]]></title>
        <id>https://fanfankill.github.io/post/niu-ke-cuo-ti/</id>
        <link href="https://fanfankill.github.io/post/niu-ke-cuo-ti/">
        </link>
        <updated>2021-04-06T01:50:43.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<br>
<h1 id="3true">3==true</h1>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1617673888601.PNG" alt="" loading="lazy"></figure>
<br>
<br>
<br>
<h1 id="2tostring">2.toString()</h1>
<figure data-type="image" tabindex="2"><img src="https://fanfankill.github.io/post-images/1617673913588.PNG" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS基本数据类型]]></title>
        <id>https://fanfankill.github.io/post/js-ji-ben-shu-ju-lei-xing/</id>
        <link href="https://fanfankill.github.io/post/js-ji-ben-shu-ju-lei-xing/">
        </link>
        <updated>2021-04-05T14:10:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基本数据类型">基本数据类型</h1>
<p>ECMAScript中有5中简单数据类型（也称为基本数据类型）: Undefined、Null、Boolean、Number和String。还有1中复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。</p>
<br>
<h1 id="typeof-操作符">typeof 操作符</h1>
<p>由于js中的变量是松散类型的，所以它提供了一种检测当前变量的数据类型的方法，也就是typeof关键字.<br>
通过typeof关键字，对这5种数据类型会返回下面的值（以字符串形式显示)<br>
undefined ---------- 如果值未定义 Undefined</p>
<p>boolean ---------- 如果这个值是布尔值 Boolean</p>
<p>string ---------- 如果这个值是字符串 String</p>
<p>number ---------- 如果这个值是数值类型 Number</p>
<p>object ---------- 如果这个值是对象或null Object</p>
<p>需要注意的是typeof null返回为object,因为特殊值null被认为是一个空的对象引用。</p>
<br>
<h1 id="undefined">Undefined</h1>
<p>Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。不过，一般建议尽量给变量初始化，但是在早期的js版本中是没有规定undefined这个值的，所以在有些框架中为了兼容旧版浏览器，会给window对象添加undefined值。</p>
<pre><code>window['undefined'] = window['undefined'];  
//或者
window.undefined = window.undefined;  
</code></pre>
<br>
<h1 id="null">Null</h1>
<p>Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null时会返回object的原因。</p>
<pre><code> var car = null;
  console.log(typeof car); // &quot;object&quot;
</code></pre>
<p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检测null值就可以知道相应的变量是否已经保存了一个对象的引用了。<br>
例如：</p>
<pre><code>  if(car != null){
    //对car对象执行某些操作
  }
</code></pre>
<p>实际上，undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true。<br>
<code>console.log(undefined == null); //true</code><br>
尽管null和undefined有这样的关系，但它们的用途完全不同。无论在什么情况下都没有必要把一个变量的值显式地设置为undefined，可是同样的规则对null却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。</p>
  <br>
<h1 id="boolean">Boolean</h1>
<p>该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0。</p>
<p>虽然Boolean类型的字面值只有两个，但JavaScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean()，例如：</p>
<pre><code>var message = 'Hello World';
    var messageAsBoolean = Boolean(message);
</code></pre>
<p>在这个例子中，字符串message被转换成了一个Boolean值，该值被保存在messageAsBoolean变量中。可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值。至于返回的这个值是true还是false，取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对象的转换规则。</p>
<p>数据类型 转换为true的值	 转换为false的值<br>
Boolean	true	false<br>
String	任何非空的字符串	&quot;&quot;(空字符串)<br>
Number	任何非0数值（包括无穷大）	0和NAN<br>
Object	任何对象	null<br>
Undefined	不适用	undefined</p>
<br>
<h1 id="number">Number</h1>
<p>这种类型用来表示整数和浮点数值，还有一种特殊的数值，即NaN（非数值 Not a Number）。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在JavaScript中，任何数值除以0会返回NaN，因此不会影响其他代码的执行。</p>
<p>NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。例如，下面的代码会返回false。<br>
<code>alert(NaN == NaN); //false</code></p>
<p>#String<br>
String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由单引号(')或双引号(&quot;)表示。</p>
<h1 id="string类型的特殊性">String类型的特殊性</h1>
<p>string类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，我们希望JS只复制对字符串的引用，而不是字符串的内容。但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成行为与基本</p>
<h1 id="类型相似的不可变引用类型">类型相似的不可变引用类型</h1>
<p>Boolean、Number、String 这三个是Javascript中的基本包装类型，也就是这三个其实是一个构造函数，他们是Function的实例，是引用类型，至于这里的String与以上说的String是同名，是因为其实上文说的String是指字符串，这里的String指的是String这个构造函数，上面那么写，是为了更好的理解，因为Javascript是松散类型的。我们可以看下String实例化的例子：</p>
<pre><code>var name = String(&quot;jwy&quot;);
alert(typeof name);//&quot;string&quot;
var x=new String('12345')
typeof x //object
x='12345'
typeof x //string
var author = &quot;Tom&quot;;
alert(typeof name);//&quot;string&quot;
</code></pre>
<p>至于author这个会有length，substring等等这些方法，其实string只是String的一个实例，类似于C#中的String，和string.</p>
<p>注意，typeof 变量 如果值是&quot;string&quot; 的话，也就是这个变量是字符串，在Javascript中，字符串是基本类型，而在C#或Java中，字符串是引用类型，但是Javascript中的String是引用类型，因为它是Javascript中定义好的基本包装类型，在C#中，String跟string其实是一样的。</p>
<h1 id="es6新增">ES6新增</h1>
<p>es6中新增了let命令来声明变量、const命令声明一个只读的常量。</p>
<p>let的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<p>const一旦声明，常量的值就不能改变。</p>
<br>
<p><img src="https://fanfankill.github.io/post-images/1617632333308.JPG" alt="" loading="lazy"><br>
<img src="https://fanfankill.github.io/post-images/1617632362296.JPG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS3动画属性]]></title>
        <id>https://fanfankill.github.io/post/js/</id>
        <link href="https://fanfankill.github.io/post/js/">
        </link>
        <updated>2021-04-04T08:14:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="animation-属性"><strong>animation 属性</strong></h2>
<br>
<br>
<p><strong>animation-delay</strong></p>
<p>​       属性规定动画开始的延迟时间(2秒延时)</p>
<p>​            <code>animation-delay: 2s;</code></p>
<p>​        负值也是允许的。如果使用负值，则动画将开始播放，如同已播放 N 秒</p>
<p>​            <code>animation-delay: -2s;</code></p>
<br>
<br>
<p><strong>animation-iteration-count</strong></p>
<p>​		 属性指定动画应运行的次数</p>
<pre><code>		` animation-iteration-count: 3;`
</code></pre>
<p>​		使用值 &quot;infinite&quot; 使动画永远持续下去</p>
<br>
<br>
<p><strong>animation-direction</strong></p>
<p>​		属性指定是向前播放、向后播放还是交替播放动画</p>
<ul>
<li>normal - 动画正常播放（向前）。默认值</li>
<li>reverse - 动画以反方向播放（向后）</li>
<li>alternate - 动画先向前播放，然后向后</li>
<li>alternate-reverse - 动画先向后播放，然后向前</li>
</ul>
<br>
<br>
<p><strong>animation-timing-function</strong></p>
<p>​		属性规定动画的速度曲线</p>
<ul>
<li>ease - 指定从慢速开始，然后加快，然后缓慢结束的动画（默认）</li>
<li>linear - 规定从开始到结束的速度相同的动画</li>
<li>ease-in - 规定慢速开始的动画</li>
<li>ease-out - 规定慢速结束的动画</li>
<li>ease-in-out - 指定开始和结束较慢的动画</li>
<li>cubic-bezier(n,n,n,n) - 运行您在三次贝塞尔函数中定义自己的值</li>
</ul>
<br>
<br>
<p><strong>animation-fill-mode</strong></p>
<p>​		CSS 动画不会在第一个关键帧播放之前或在最后一个关键帧播放之后影响元素</p>
<ul>
<li>none - 默认值。动画在执行之前或之后不会对元素应用任何样式。</li>
<li>forwards - 元素将保留由最后一个关键帧设置的样式值（依赖 animation-direction 和 animation-iteration-count）。</li>
<li>backwards - 元素将获取由第一个关键帧设置的样式值（取决于 animation-direction），并在动画延迟期间保留该值。</li>
<li>both - 动画会同时遵循向前和向后的规则，从而在两个方向上扩展动画属性。</li>
</ul>
<br>
<br>
<pre><code>
//使用简写属性，将动画与 div 元素绑定：

div

{

animation:mymove 5s infinite;

-webkit-animation:mymove 5s infinite; /* Safari 和 Chrome */

}



//动画帧

 @keyframes mymove {

​          50% {transform-origin: 0 0 0;transform: rotate(360deg);background-color: rgb(83, 83, 90);}

​        

​        }

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1617525832441.png" alt="" loading="lazy"></figure>
<p>## <strong>动画可用属性</strong></p>
<figure data-type="image" tabindex="2"><img src="https://fanfankill.github.io/post-images/1617524085576.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目cooike实现保存账号密码功能]]></title>
        <id>https://fanfankill.github.io/post/xiang-mu-cooike-dai-ma/</id>
        <link href="https://fanfankill.github.io/post/xiang-mu-cooike-dai-ma/">
        </link>
        <updated>2021-04-04T06:15:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cooike详细介绍">cooike详细介绍</h1>
<p><a href="https://blog.csdn.net/qq_37002901/article/details/86601904"><strong>原文博客</strong></a></p>
<h1 id="cooike储存机制">cooike储存机制</h1>
<p><code>Set-Cookie: name=value[; expires=GMTDate][; domain=domain][; path=path][; secure]</code></p>
<h1 id="项目实现代码">项目实现代码</h1>
<pre><code>    //获取储存的cooike
getCookie(name) {
     var reg=RegExp(name+'=([^;]+)');
     var arr=document.cookie.match(reg);
     if(arr)
     {
       return arr[1];
     }else{
       return '';
     }
}
</code></pre>
<pre><code>/**存放cookie */

  setCookie(name, value, day) {

   let data = new Date();

   data.setDate(data.getDate() + day);

   document.cookie = name + &quot;=&quot; + value + &quot;;expires=&quot; + data;

  },
</code></pre>
<pre><code>/**删除cooike*/
delCookie(name) {

   this.setCookie(name, '', -1);

  },
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[markdown基本语法]]></title>
        <id>https://fanfankill.github.io/post/markdown-ji-ben-yu-fa/</id>
        <link href="https://fanfankill.github.io/post/markdown-ji-ben-yu-fa/">
        </link>
        <updated>2021-04-03T15:16:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="对必要语法的摘记">对必要语法的摘记</h1>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1617462999416.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://fanfankill.github.io/post/hello-gridea/</id>
        <link href="https://fanfankill.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://4399.com">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a><br>
<img src="https://fanfankill.github.io/post-images/1617460798662.jpg" alt="" loading="lazy"></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力<br>
sdsd<br>
🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>