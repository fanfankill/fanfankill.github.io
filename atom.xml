<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fanfankill.github.io</id>
    <title>fanfan</title>
    <updated>2021-07-16T05:03:27.979Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fanfankill.github.io"/>
    <link rel="self" href="https://fanfankill.github.io/atom.xml"/>
    <subtitle>&lt;strong&gt;前端小白&lt;/strong&gt;</subtitle>
    <logo>https://fanfankill.github.io/images/avatar.png</logo>
    <icon>https://fanfankill.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, fanfan</rights>
    <entry>
        <title type="html"><![CDATA[手写Promise]]></title>
        <id>https://fanfankill.github.io/post/shou-xie-promise/</id>
        <link href="https://fanfankill.github.io/post/shou-xie-promise/">
        </link>
        <updated>2021-07-16T05:00:42.000Z</updated>
        <content type="html"><![CDATA[<p>promise是用来解决两个问题的：</p>
<ul>
<li>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</li>
<li>promise可以支持多个并发的请求，获取并发请求中的数据</li>
<li>这个promise可以解决异步的问题，本身不能说promise是异步的</li>
</ul>
 <br>
<h2 id="实现代码"><strong>实现代码</strong></h2>
<pre><code class="language-js"> class mypromise {

        constructor(exeutor) {
            this.state = PENDING
            //成功的存储
            this.value = undefined
            //失败的存储
            this.reason = undefined

            //存放成功时候的回调函数
            this.ResolveCallbakc = []
            //存放失败时候的回调函数
            this.RejectCallback = []
            //要把这个值保存起来 调用then的时候还需要使用
            let resolve = (value) =&gt; {
                
                if (this.state == PENDING) {
                    //定时器用于then先注册才去改变状态 
                  setTimeout(()=&gt;{
                        //存起来
                    console.log('成功的构造');
                    this.value = value
                    //改变状态
                    this.state = FULFILLED
                    //全执行
                    this.ResolveCallbakc.forEach(fn =&gt; fn())  //发布过程
                  })
                }
            }
            let reject = (reason) =&gt; {

                if (this.state == PENDING) {
                setTimeout(()=&gt;{
                    console.log('失败的构造');
                    //也存起来
                    this.reason = reason

                    this.state = REJECTED

                    this.RejectCallback.forEach(fn =&gt; fn())
                })
                }
            }
            //传入两个参数 给用户来改变状态
            try {
                exeutor(resolve, reject)
            } catch (e) {
                //当前有异常
                reject(e)
            }
        }
        then(onfulfilled, onrejected) {
            if (this.state == FULFILLED) {
                onfulfilled(this.value)
               
            }
            if (this.state == REJECTED) {
                onrejected(this.reason)
             
            }
            if (this.state == PENDING) {
                console.log('推入函数');
                this.ResolveCallbakc.push(() =&gt; {
                    onfulfilled(this.value)
                })
                this.RejectCallback.push(() =&gt; {
                    onrejected(this.reason)
                })
                //链式调用
                return this;

            }

        }

    }
</code></pre>
<h2 id="实例"><strong>实例</strong></h2>
<pre><code class="language-js"> let fanfan = new mypromise((resolve, reject) =&gt; {
        console.log('?');
        resolve('fanfan')
    }).then(res =&gt; {
        setTimeout(()=&gt;{
            console.log('time');
        })
        console.log(res);

    }).then(res =&gt; {
        console.log('?');
        
    }).then(res=&gt;{
        console.log(res);
    })
 
 // 打印结果 可以看到先是then去注册完才去调用状态改变
 //先微后宏
 /**
 ?
promise2.html:78 推入函数
promise2.html:78 推入函数
promise2.html:78 推入函数
promise2.html:37 成功的构造
promise2.html:100 fanfan
promise2.html:103 ?
promise2.html:106 fanfan
promise2.html:98 time
 */
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS设计模式]]></title>
        <id>https://fanfankill.github.io/post/js-she-ji-mo-shi/</id>
        <link href="https://fanfankill.github.io/post/js-she-ji-mo-shi/">
        </link>
        <updated>2021-07-14T16:16:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="js的设计模式">JS的设计模式</h1>
<p><strong>什么是设计模式</strong></p>
<p>假设有一个空房间，我们要日复一日地往里 面放一些东西。最简单的办法当然是把这些东西 直接扔进去，但是时间久了，就会发现很难从这 个房子里找到自己想要的东西，要调整某几样东 西的位置也不容易。所以在房间里做一些柜子也 许是个更好的选择，虽然柜子会增加我们的成 本，但它可以在维护阶段为我们带来好处。使用 这些柜子存放东西的规则，或许就是一种模式</p>
<h2 id="单例模式">单例模式</h2>
<p>确保只有一个实例，并提供全局访问，类似闭包创建后都去访问一个。</p>
<h2 id="策略模式">策略模式</h2>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。表单验证用的多</p>
<h2 id="代理模式">代理模式</h2>
<p>为一个对象提供一个代用品或占位符，以便控制对它的访问，用于对数据进行处理后返回</p>
<h2 id="发布-订阅模式">发布-订阅模式</h2>
<p>也称作观察者模式（观察者模式子模式），定义了对象间的一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都将得到通知 。不直接建立关系，依靠一个中间商来建立</p>
<pre><code class="language-js">   // 观察者
var observer = {
    // 订阅集合
    subscribes: [],

    // 订阅 存放对应key
    subscribe: function(key, fn) {
        //不存在的情况下才默认为一个空数组
        if (!this.subscribes[key]) {
            this.subscribes[key] = [];
        }
      
        
        // 订阅者的处理  是函数就推进去
        typeof fn === 'function' &amp;&amp; this.subscribes[key].push(fn);
    },

    // 发布 
    publish: function() {
        
        var type =[].shift.call(arguments) // arguments[0]  去掉第一项 就是 key项 剩余项都是value项
        

            //调用对应key存的函数
            fns = this.subscribes[type];
           
        
        // 不存在的订阅类型，以及订阅时未传入处理回调的
        if (!fns || !fns.length) {
            return;
        }
        
        // 挨个处理调用 就是订阅同一个key很多次 然后一个个调用
        for (var i = 0; i &lt; fns.length; ++i) {
            fns[i].apply(this, arguments);
        }
    },
     
};


//实例


observer.subscribe('examinationA', function(score) {
    console.log(score);
});

observer.subscribe('examinationA', function(score) {
    console.log(score);
});

observer.publish('examinationA', 100); // 100  100  里面两个订阅都打印了出来
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-router]]></title>
        <id>https://fanfankill.github.io/post/vue-router/</id>
        <link href="https://fanfankill.github.io/post/vue-router/">
        </link>
        <updated>2021-07-13T08:55:32.000Z</updated>
        <content type="html"><![CDATA[<p><strong>这里的路由就是SPA（单页应用）的路径管理器</strong></p>
<p>路由用于设定访问路径，并将路径和组件映射起来</p>
<p><strong>单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面</strong></p>
<h4 id="1-hash模式">1、Hash模式：</h4>
<p><strong>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</strong></p>
<p>可以通过location.hast取得#后面的路由</p>
<p>window.onhashchange=functioin(){}    //当hash路由改变时候触发</p>
<h4 id="2-history模式">2、History模式：</h4>
<p>这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p>
<p>location.pathname 取得路由地址</p>
<p>onpopstate来监听history的路由变化</p>
<h4 id="3-使用路由模块来实现页面跳转的方式">3、使用路由模块来实现页面跳转的方式</h4>
<p>方式1：直接修改地址栏</p>
<p>方式2：this.$router.push(‘路由地址’)</p>
<p>方式3：<code>&lt;router-link to=&quot;路由地址&quot;&gt;&lt;/router-link&gt;</code></p>
<h4>4、实现方式</h4>
<p><code>Vue.use(VueRouter)</code></p>
<ol>
<li>执行VueRouter方法</li>
<li>如果这个方法有一个属性 install 并且这个属性是一个方法 就会执行install这个方法  例如 (VueRouter.install=function(){})</li>
<li>install这个方法的第一个参数 是vue</li>
</ol>
<p>​</p>
<h4>5、手写router</h4>
<pre><code class="language-js">//router的index文件

import  VueRouter from '../myrouter/index'
import  Vue from 'vue'

const register =() =&gt;import('../src/register')
const home =()=&gt;import('../src/home')

Vue.use(VueRouter)

const routes=[
    {
        path: '/register',
        name: '注册',
        component: register,
        title: '注册',
      }, {
        path: '/',
        name: '首页',
        component: home,
        title: '注册',
      },
   
   
]

const router = new VueRouter({
    routes
  })

export default router
</code></pre>
<pre><code class="language-js">//实现VueRouter实例 hash模式实现

let Vue

//注册一个类
class VueRouter{
    constructor(options)
    {
        console.log(options);

        let initPath='/' //默认值
        Vue.util.defineReactive(this,'current',initPath) //this指向VueRouter  响应式
        this.current='/' //当前路由
        this.routes=options.routes//用户路由规则
        this.mode=options.mode||'hash' //默认hash
        this.init() //监听路由改变
        
    }
    init()
    {
     
        if(this.mode=='hash'){
            console.log(location.hash); //拿到hash模式下的hash地址

            //监听第一次加载项目要加/#/
            window.addEventListener('load',()=&gt;{
                this.current=location.hash.slice(1)
    
            })
            //监听路由改变
            window.addEventListener('hashchange',()=&gt;{
                this.current=location.hash.slice(1)
            })
        }
    }
}

VueRouter.install=function(_Vue){
        Vue=_Vue

        //给调用组件添加一个属性  router
        Vue.mixin({  
            //全局添加数据和方法  vue3改为compostions api
            //每一个实例都是一个 $options api 例如app.vue 和main.js 里面的都是一个实例
            beforeCreate() {
                console.log(this.$options.name);
                if(this.$options.router)//根组件上才有的属性
                {
                    Vue.prototype.$router=this.$options.router //在Vue实例原生链上添加属性 实现全局添加this.$router属性
                }
            },
        })

        //创建全局组件
        //router-link 
        Vue.component('router-link',{
            //传参过来
            props:{
              to:{
                  type:String,
                  require:true
              }
            },
            render(h) {
                return h('a',{attrs:{
                    href:&quot;#&quot;+this.to
                }},this.$slots.default)//创建html的内容 就是插槽里面的内容
            },
        }),


        Vue.component('router-view',{
            //必须是响应式数据才能触发
            render(h) {

                //当前路由
                let current =this.$router.current
                console.log(current);
                //获取到了配置的路由数组  然后通过上面的取出对应的路由模块并且渲染出来
                let routers=this.$router.routes
                console.log(routers);

                //找出匹配的数组项
                let com=routers.find(item=&gt;{
                    return current==item.path
                })
                console.log(com);
                return h(com.component)//创建html
            },
        })
}


export default  VueRouter
</code></pre>
<pre><code class="language-js">//App.vue 文件

&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;


&lt;div class=&quot;tolink&quot;&gt;
    &lt;router-link to='/register'&gt;注册&lt;/router-link&gt;
    &lt;router-link to='/'&gt;home&lt;/router-link&gt;
   
&lt;/div&gt;
   &lt;div&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  name: 'App',
  beforeCreate() {
    console.log(this.$router);
  },
  data() {
    return {
  
    }
  },
 


}
&lt;/script&gt;

&lt;style&gt;
.tolink{
  width: 40%;
  margin: auto;
  display: flex;
  justify-content:space-between;
}
&lt;/style&gt;

</code></pre>
<p>实现效果</p>
<figure data-type="image" tabindex="1"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210713165156925.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210713165208681.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VUE文档]]></title>
        <id>https://fanfankill.github.io/post/vue-wen-dang/</id>
        <link href="https://fanfankill.github.io/post/vue-wen-dang/">
        </link>
        <updated>2021-07-11T11:20:09.000Z</updated>
        <content type="html"><![CDATA[<p>v-html :将模板字符串解析为html格式</p>
<p>split() 组成字符串数组</p>
<p>模板表达式都被放在沙盒中，只能访问<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9">全局变量的一个白名单</a>，如 <code>Math</code> 和 <code>Date</code> 。你不应该在模板表达式中试图访问用户定义的全局变量。</p>
<br>
<p>你可以使用动态参数为一个动态的事件名绑定处理函数：</p>
<pre><code class="language-js">&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;
</code></pre>
<p>当 <code>eventName</code> 的值为 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>。</p>
<h3 id="v-bind"><a href="https://cn.vuejs.org/v2/guide/syntax.html#v-bind-%E7%BC%A9%E5%86%99"><code>v-bind</code> 缩写</a></h3>
<pre><code class="language-js">&lt;!-- 完整语法 --&gt;
&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;

&lt;!-- 缩写 --&gt;
&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;

&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;
&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a&gt;
</code></pre>
<h3 id="v-on"><a href="https://cn.vuejs.org/v2/guide/syntax.html#v-on-%E7%BC%A9%E5%86%99"><code>v-on</code> 缩写</a></h3>
<pre><code class="language-js">&lt;!-- 完整语法 --&gt;
&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;

&lt;!-- 缩写 --&gt;
&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;

&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;
&lt;a @[event]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;
</code></pre>
<h2 id="计算属性和侦听器">计算属性和侦听器</h2>
<pre><code class="language-HTML">&lt;div id=&quot;example&quot;&gt;
  &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;
  &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-JS">var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
</code></pre>
<h3 id="计算属性缓存-vs-方法">计算属性缓存 vs 方法</h3>
<pre><code class="language-JS">&lt;p&gt;Reversed message: &quot;{{ reversedMessage() }}&quot;&lt;/p&gt;

// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
</code></pre>
<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。</p>
<p>这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
<p>所以计算属性要是响应试依赖</p>
<p>这也同样意味着下面的计算属性将不再更新，因为 <code>Date.now()</code> 不是响应式依赖：</p>
<pre><code class="language-js">computed: {
  now: function () {
    return Date.now()
  }
}
</code></pre>
<h2 id="计算属性-vs-侦听属性">计算属性 vs 侦听属性</h2>
<p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p>
<pre><code class="language-js">// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
</code></pre>
<p><strong>计算属性computed :</strong></p>
<ol>
<li>
<p>支持缓存，只有依赖数据发生改变，才会重新进行计算</p>
</li>
<li>
<p>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p>
</li>
</ol>
<p>​            3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行               缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p>
<ol start="4">
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li>
</ol>
<p>​           5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p>
<br>
<p><strong>侦听属性watch：</strong></p>
<ol>
<li>不支持缓存，数据变，直接会触发相应的操作；</li>
<li>watch支持异步；</li>
<li>当一个属性发生变化时，需要执行对应的操作；一对多；</li>
<li>监听数据必须是data中声明过或者父组件传递过来的props中的数据.函数有两个参数，
<ol>
<li>immediate：组件加载立即触发回调函数执行</li>
<li>deep: 深度监听，为了发现<strong>对象内部值</strong>的变化，复杂类型的数据时使用。deep无法监听到数组的变动和对象的新增</li>
</ol>
</li>
</ol>
<h2 id="条件渲染">条件渲染</h2>
<p>当 <code>v-if</code> 需要包裹多个元素时候 用 <code>&lt;template&gt;</code></p>
<p><code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</p>
<p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级</p>
<h2 id="事件处理方法">事件处理方法</h2>
<p>内联处理器中的方法</p>
<pre><code class="language-js">&lt;div id=&quot;example-3&quot;&gt; 
    &lt;button v-on:click=&quot;say('hi',$event)&quot;&gt;Say hi&lt;/button&gt;  
	&lt;button v-on:click=&quot;say('what')&quot;&gt;Say what&lt;/button&gt; &lt;/div&gt;

new Vue({
  el: '#example-3',
  methods: {
    say: function (message,event) {
      alert(message)
        // 现在我们可以访问原生事件对象
        if (event) {
          event.preventDefault()
        }
    }
  }
})
//有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：
</code></pre>
<h2 id="事情修饰符">事情修饰符</h2>
<p>原文博客(https://www.cnblogs.com/xiaoyaoxingchen/p/10405207.html)</p>
<ul>
<li>
<p><code>.stop</code>  阻止冒泡（通俗讲就是阻止事件向上级DOM元素传递）<br>
<img src="https://fanfankill.github.io/post-images/1626002759503.png" alt="" loading="lazy"></p>
</li>
<li>
<p><code>.prevent</code>  阻止默认事件的发生 例如a标签的跳转和表单的提交刷新</p>
</li>
<li></li>
<li>
<p><code>.capture</code> 捕获冒泡 即有冒泡发生时，有该修饰符的dom元素会先执行</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1626002752776.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><code>.self</code>  事件有自身才能触发，通常用于避免冒泡事件的影响<br>
<img src="https://fanfankill.github.io/post-images/1626002764276.png" alt="" loading="lazy"></p>
</li>
<li>
<p><code>.once</code>    只触发一次</p>
</li>
<li>
<p><code>.passive</code>   对DOM的默认事件进行性能优化</p>
</li>
<li>
<p><code>. native</code> 一般给组件绑定事件加的</p>
</li>
</ul>
<pre><code class="language-html">&lt;!-- 阻止单击事件继续传播 --&gt;
&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 修饰符可以串联 --&gt;
&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

&lt;!-- 只有修饰符 --&gt;
&lt;form v-on:submit.prevent&gt;&lt;/form&gt;

&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;
&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;
&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;
&lt;!-- 即事件不是从内部元素触发的 --&gt;
&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;
</code></pre>
<br>
<h2 id="按键修饰符">按键修饰符</h2>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“删除”和“退格”键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<pre><code class="language-js">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;
    &lt;input v-on:keyup.enter=&quot;submit&quot;&gt;
</code></pre>
<h2 id="系统修饰键">系统修饰键</h2>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<h2 id="exact"><code>.exact</code></h2>
<p>修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
<pre><code class="language-html">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;
&lt;button v-on:click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;
&lt;button v-on:click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;
&lt;button v-on:click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 媒体查询]]></title>
        <id>https://fanfankill.github.io/post/mei-ti-cha-xun/</id>
        <link href="https://fanfankill.github.io/post/mei-ti-cha-xun/">
        </link>
        <updated>2021-07-10T16:20:07.000Z</updated>
        <content type="html"><![CDATA[<p>媒体属性是CSS3新增的内容</p>
<p>媒体属性必须用括号()包起来</p>
<h5 id="media-媒体类型and-媒体特性你的样式">@media 媒体类型and （媒体特性）{你的样式}</h5>
<h2 id="最大宽度max-width">最大宽度max-width</h2>
<h5 id="意思是指媒体类型小于或等于指定的宽度时样式生效-如">意思是指媒体类型小于或等于指定的宽度时，样式生效。如：</h5>
<pre><code class="language-css">@media screen and (max-width:480px){
 body {
   display:none;
  }
}
</code></pre>
<h2 id="最小宽度min-width">最小宽度min-width</h2>
<pre><code class="language-css">@media screen and (min-width:600px) and (max-width:900px){
  body {background-color:#f5f5f5;}
}
</code></pre>
<h2 id="多个媒体特性使用"><strong>多个媒体特性使用</strong></h2>
<h5 id="media-query中可以包含0到多个表达式">Media Query中可以包含0到多个表达式</h5>
<pre><code class="language-css">/**当屏幕在600px~900px之间时，body的背景色渲染为“#f5f5f5”*/
@media screen and (min-width:600px) and (max-width:900px){
  body {background-color:#f5f5f5;}
}
</code></pre>
<h2 id="设备屏幕的输出宽度device-width"><strong>设备屏幕的输出宽度Device Width</strong></h2>
<h5 id="以根据屏幕设备的尺寸来设置相应的样式或者调用相应的样式文件">以根据屏幕设备的尺寸来设置相应的样式（或者调用相应的样式文件）</h5>
<pre><code class="language-xml">&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (max-device-width:480px)&quot; href=&quot;iphone.css&quot; /&gt;
</code></pre>
<h2 id="not关键词">not关键词</h2>
<h5 id="使用关键词not是用来排除某种制定的媒体类型">使用关键词“not”是用来排除某种制定的媒体类型</h5>
<pre><code class="language-css">@media not print and (max-width: 1200px){样式代码}
</code></pre>
<h2 id="only关键词">only关键词</h2>
<h5 id="only用来指定某种特定的媒体类型">only用来指定某种特定的媒体类型</h5>
<pre><code class="language-xml">&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (max-device-width:240px)&quot; href=&quot;android240.css&quot; /&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS度量单位 rem、em、vw、vh]]></title>
        <id>https://fanfankill.github.io/post/css-du-liang-dan-wei-rememvwvh/</id>
        <link href="https://fanfankill.github.io/post/css-du-liang-dan-wei-rememvwvh/">
        </link>
        <updated>2021-07-10T13:42:52.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1625924625206.png" alt="" loading="lazy"></figure>
<h2 id="em"><strong>em</strong></h2>
<p>继承父元素大小关系，2em 则为父元素大小的两倍  受自己上级节点影响</p>
<pre><code class="language-html">&lt;div class=&quot;div&quot; style=&quot;font-size:20px;&quot;&gt;div 标签中的文字大小为 20px
&lt;p class=&quot;p&quot; style=&quot;font-size:2em&quot;&gt;P 标签中的文字大小为 2em
&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>效果如下<br>
<br></p>
<style>
.div{font-size:20px;}
.p{font-size:2em;}
.span{font-size:0.5em;}
</style>
<div class="div" style="font-size:20px;">div 标签中的文字大小为 20px
<p class="p" style="font-size:2em">P 标签中的文字大小为 2em
    <span class="span" style="font-size:.5em">span标签中的文字大小为0.5em</span>
</p>
</div>
<br>
<h2 id="rem"><strong>rem</strong></h2>
<p>就是相对于根节点来进行缩放，如果有嵌套的关<br>
系，嵌套关系的元素的字体大小始终按照根节点的字体大小进行缩放</p>
<pre><code class="language-html">&lt;style&gt;
html{font-size:16px;}
.div{font-size:30px;background-color:pink;padding:50px;}
.p{font-size:1rem;}
.span{font-size:0.5rem;}
&lt;/style&gt;

&lt;div class=&quot;div&quot;&gt;div 标签中的文字大小为 30px
&lt;p class=&quot;p&quot;&gt;P 标签中的文字大小为 1rem
&lt;span class=&quot;span&quot;&gt;span 标 签 中 的 文 字 大 小 为
0.5rem&lt;/span&gt;
&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<div class="div" style="font-size:30px">div 标签中的文字大小为 30px
<p class="p" style="font-size:1rem;">P 标签中的文字大小为 1rem
<span class="span" style="font-size:.5rem">span 标 签 中 的 文 字 大 小 为
0.5rem</span>
</p>
</div>
<p><strong>这个rem继承的是html的font-size  默认为16px 这才是根节点</strong></p>
<br>
<br>
<h2 id="vw-和-vh"><strong>vw 和 vh</strong></h2>
<p>视窗的宽度和高度，相当于屏幕宽度和高度的 1%</p>
<p>处理宽度的时候%单位更合适，处理高度的话 vh 单位更好<br>
<br></p>
<h2 id="vmin-和-vmax"><strong>vmin 和 vmax</strong></h2>
<p>关于视口高度和宽度两者的最小值或者最大值。</p>
<p>如果你要让这个元素始终铺满整个视口的可见区域：</p>
<pre><code class="language-css">.box { 
height: 100vmax; 
width: 100vmax;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图片懒加载]]></title>
        <id>https://fanfankill.github.io/post/tu-pian-lan-jia-zai/</id>
        <link href="https://fanfankill.github.io/post/tu-pian-lan-jia-zai/">
        </link>
        <updated>2021-07-03T14:47:46.000Z</updated>
        <content type="html"><![CDATA[<p>实现图片懒加载先了解几个属性</p>
<ul>
<li>offsetWidth/offsetHeight</li>
</ul>
<p>对象的可见宽度</p>
<ul>
<li>clientWidth/clientHeight</li>
</ul>
<p>内容的可见宽度</p>
<ul>
<li>scrollWidth/scrollHeight</li>
</ul>
<p>元素完整的高度和宽度，overflow:hidden的部分也计算在内。</p>
<ul>
<li>offsetLeft/offsetTop</li>
</ul>
<p>当前元素距浏览器边界的偏移量，以像素为单位。</p>
<ul>
<li>clientTop/clientLeft</li>
</ul>
<p>这个属性测试下来的结果就是border。</p>
<ul>
<li>scrollLeft/scrollTop</li>
</ul>
<p>设置或返回已经滚动到元素的左边界或上边界的像素数。</p>
<h2 id="实现代码">实现代码</h2>
<pre><code class="language-js"> //显示器高度 window.innerHeight
    //图片到视窗上的距离 getBoundingClientRect().top
    let imgs=document.querySelectorAll('img')
    console.log(imgs);

    window.addEventListener('scroll',(e)=&gt;{
        imgs.forEach(v=&gt;{
            const imgtop=v.getBoundingClientRect().top
            console.log(imgtop);
            if(imgtop&lt;window.innerHeight)
            {
              
                let data_src=v.getAttribute('data-src')
                 v.setAttribute('src',data_src)
            }
            console.log('触发');
        })
    })

</code></pre>
<p>HTML</p>
<pre><code class="language-html">&lt;img  data-src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb1-q.mafengwo.net%2Fs7%2FM00%2F2E%2F37%2FwKgB6lSuHraAYMNtAAXF8ovILuk683.png&amp;refer=http%3A%2F%2Fb1-q.mafengwo.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1627892666&amp;t=953e6a19584b6772c33a1b84604fa63d&quot;&gt;
</code></pre>
<p><strong>感觉上面这样触发太频繁 加个节流吧</strong></p>
<pre><code class="language-JS">//节流写法
    window.onscroll = throttle(getscroll,200)
    



    //主体函数
    function getscroll() {
  
        let imgs = document.querySelectorAll('img')

        imgs.forEach(v=&gt;{
            const imgtop=v.getBoundingClientRect().top
            console.log(imgtop);
            if(imgtop&lt;window.innerHeight)
            {

                let data_src=v.getAttribute('data-src')
                 v.setAttribute('src',data_src)
            }
          
        })
    }

    //节流函数 过一段时间才触发
    function throttle(fn, delay) {
        let timer = true
        return function () {
            if (!timer) {
                return false
            }
  
            timer=false
            setTimeout(() =&gt; {
            fn()
            console.log('我是节流');
            timer = true;
        }, delay)

        }
    }

</code></pre>
<p><img src="https://fanfankill.github.io/post-images/1625323851326.png" alt="" loading="lazy"><br>
<img src="https://fanfankill.github.io/post-images/1625323855197.png" alt="" loading="lazy"></p>
<p>不节流效果</p>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1625323862788.png" alt="" loading="lazy"></figure>
<p>节流后的效果  200ms间隔</p>
<figure data-type="image" tabindex="2"><img src="https://fanfankill.github.io/post-images/1625323858842.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手写ajax]]></title>
        <id>https://fanfankill.github.io/post/shou-xie-axios/</id>
        <link href="https://fanfankill.github.io/post/shou-xie-axios/">
        </link>
        <updated>2021-06-26T13:00:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="axios">axios</h2>
<p>客户端  请求  服务端</p>
<ul>
<li>
<p>请求行</p>
<p>url</p>
<p>请求方式</p>
</li>
<li>
<p>多个请求头</p>
<p>域名，cooike，content-Type等</p>
</li>
<li>
<p>请求体</p>
</li>
</ul>
<p>post方法传的参数</p>
<p>服务端  响应  客户端</p>
<ul>
<li>
<p>响应行</p>
<p>status statusText</p>
</li>
<li>
<p>多个响应头</p>
<p>Content-Type:text/html</p>
</li>
<li>
<p>响应体</p>
<p>数据返回</p>
</li>
</ul>
<h2 id="xhr">XHR</h2>
<p>XMLHttpRequest对象可以和服务器交互 不会刷新网页</p>
<p>只有XHR和fetch发出的才是ajax请求</p>
<p>一般的请求就类似跳转和刷新页面</p>
<p>ajax只是调用监视回调函数并传入响应相关的数据</p>
<h2 id="api">API</h2>
<p>XMLHttpRequest() //创建XHR对象的构造函数</p>
<p>status：响应状态码</p>
<p>statusText：响应状态文本</p>
<p>onreadystatechange：绑定readyState改变的监听</p>
<p>open(method,url)：初始化请求</p>
<p>send(data)：发送请求</p>
<p>abort()：中断请求</p>
<br>
<br>
<h2 id="手写实现ajax">手写实现ajax</h2>
<pre><code class="language-js">&lt;script&gt;
    
    //接口在本地node.js实现
      function getdata()
    {
        console.log('发送get请求');
        ajax({
            url:'http://localhost:3000/getposition',
            parmas:{
               
            name:'fanfan',
            age:19,
            number:13142278876
            }
        }).then(res=&gt;{
            console.log(res);
        })
    }

    
    //ajax手写实现
     
    function ajax({
        //解构赋值  写好默认值
        url,
        method='GET',
        data={},
        parmas={},
    }){
        //返回promise对象
         return new Promise( (resolve,reject)=&gt;{
       
         //对url的处理  有些get请求参数需要拼接另外函数实现拼接
            url+='?'+pinjie(parmas)
    
             //创建xhr对象
             const request=new XMLHttpRequest()
            //打开连接
             request.open(method,url,true) 
            //转换为JSON对象 
            if(method=='GET')
            {
                request.send()
            }
           else if(method=='post')
           {
          
           //发送JSON格式的对象肯定要加请求头 告诉服务器请求体是JSON格式
            request.setRequestHeader('Content-Type','application/json;charset=uft-8')
            //转换为JSON发送
            request.send(JSON.stringify(data))
           }
    
           //绑定状态改变的监听 从发送变为成功或者失败调用的函数
           request.onreadystatechange=function(){
                //进入判断 如果请求没有完成 直接结束
                if(request.readyState!==4)
                {
                    return 
                }
                //如果响应状态码在 200~299为成功
                const {status,statusText} =request
                //自己加的属性
                let author='fanfan'
                
                if(status&gt;=200&amp;&amp;status&lt;=299)
                {
                    //准备结果对象response 的其中几条
                    const response={
                        //对应返回的数据可以知道这些东西是什么
                        data:JSON.parse(request.response),
                        status,
                        statusText,
                        //自己添加的属性
                        author
                      
                    }
                    resolve(response)
                }else{
                    //请求失败返回message信息和状态码
                    reject(new Error('requset error status is '+status))
                }
           }
              
         })
    }

    //拼接参数 for-in解决
    function pinjie(obj)
    {
        let  queryString=''
        for(let k in obj)
        {
            queryString+= k+'='+obj[k]+'&amp;'
        }
        //判断有没有值
        if(queryString)
        {
            queryString=queryString.slice(0,queryString.length-1)
        }
        //拼接到url上面
       return  queryString
    }
    
    
&lt;/script&gt;


</code></pre>
<br>
<br>
<h2 id="实现结果">实现结果</h2>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1624712565528.png" alt="" loading="lazy"></figure>
<h2 id="axios特点">axios特点</h2>
<ul>
<li>
<p>基本promise的异步ajax请求库</p>
</li>
<li>
<p>浏览器和node都可以使用</p>
</li>
<li>
<p>支持请求/响应数据转换</p>
</li>
<li>
<p>支持请求取消</p>
</li>
</ul>
<h2 id="多个请求响应拦截器-洋葱模型">多个请求/响应拦截器  （洋葱模型）</h2>
<p>请求拦截器 先添加后执行  响应拦截器 先添加先执行</p>
<pre><code class="language-js"> //添加请求拦截器
    axios.interceptors.request.use(
        config=&gt;{
            console.log('request interceptor1');
            return config
        },
        error=&gt;{
            return Promise.reject(error)
        }
    )

     //添加请求拦截器
     axios.interceptors.request.use(
        config=&gt;{
            console.log('request interceptor2');
            return config
        },
        error=&gt;{
            return Promise.reject(error)
        }
    )
    //添加响应拦截器
    axios.interceptors.response.use(
        response=&gt;{
            console.log('response interceptor1');
            return response
        },error=&gt;{
            return Promise.reject(error)
        }
    )
      //添加响应拦截器
      axios.interceptors.response.use(
        response=&gt;{
            console.log('response interceptor2');
            return response
        },error=&gt;{
            return Promise.reject(error)
        }
    )


 //config 就是传的配置文件 不返回的话就传不过去

//response return的结果会给下一个响应拦截器 最后执行.then(res) 将数据传给res


/*request interceptor2
request interceptor1
response interceptor1
response interceptor2*/

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mustache]]></title>
        <id>https://fanfankill.github.io/post/mustache/</id>
        <link href="https://fanfankill.github.io/post/mustache/">
        </link>
        <updated>2021-06-26T05:50:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vue源码学习">vue源码学习</h1>
<h2 id="什么是模板引擎">什么是模板引擎</h2>
<p><strong>将数据要变为试图最优雅的解决方案</strong></p>
<p>历史上出现过数据变为视图的方法</p>
<ul>
<li>
<p>纯DOM</p>
</li>
<li>
<p>数组join法</p>
</li>
<li>
<p>ES6的反引号法</p>
<p>新增的 <code>${a}</code>的语法糖</p>
</li>
<li>
<p>模板引擎</p>
</li>
</ul>
<p><strong>数组join法</strong></p>
<pre><code class="language-js">//换行一样
var message='fanfan'
var str=[
    '&lt;li&gt;',
    '&lt;div&gt;'+message+'&lt;/div&gt;',
    '&lt;/li&gt;'
].join()
</code></pre>
<p>ES6的语法糖</p>
<pre><code class="language-js">let a='fanfan'
list.innerHTTML+=`
	&lt;li&gt;
		&lt;div class=&quot;fanfan&quot;&gt;
				${a}的信息
		&lt;/div&gt;
	&lt;/li&gt;
`
</code></pre>
<h2 id="mustache库">mustache库</h2>
<p>{{ }} 像胡子  所以取名叫胡子</p>
<pre><code class="language-js">  var user = { name: &quot;Olive&quot;, age: 23, sex: &quot;girl&quot; };
        var template = &quot;My name is  {{name}} ,I'm  {{age}} ,Sex is {{sex}}&quot;;
        var view = Mustache.render(template, user)

   console.log(view);
</code></pre>
<p><strong>简单模式下正则表达式可以实现</strong></p>
<pre><code class="language-js"> var template = &quot;My name is  {{name}} ,I'm  {{age}} ,Sex is {{sex}}&quot;;
    
            console.log(template.replace(/\{\{(\w+)\}\}/g,function(a,b,c){
                console.log(a,b,c);
                return '❤'
            }));

/**
	b 找出了里面的内容 可以用来替换
	{{name}} name 12
	{{age}} age 27
	{{sex}} sex 43
 	My name is  ❤ ,I'm  ❤ ,Sex is ❤*/
</code></pre>
<pre><code class="language-js"> 
//进行函数封装
function likerender(template,data)
            {
                return template.replace(/\{\{(\w+)\}\}/g,function(findstr,$1){
                //匹配data对象里面的属性
                return data[$1]
                     });
            }

            var data={
                name:'fanfan',
                age:18,
                sex:'man'
            }

            console.log(likerender(template,data));
		
//My name is  fanfan ,I'm  18 ,Sex is man
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 微信小程序开发记录]]></title>
        <id>https://fanfankill.github.io/post/xiao-cheng-xu-kai-fa-ji-lu/</id>
        <link href="https://fanfankill.github.io/post/xiao-cheng-xu-kai-fa-ji-lu/">
        </link>
        <updated>2021-06-20T07:51:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="es6-map函数-选择作用">ES6 map()函数 (选择作用)</h2>
<pre><code>var users = [
{name: &quot;张含韵&quot;, &quot;email&quot;: &quot;zhang@email.com&quot;},
{name: &quot;江一燕&quot;, &quot;email&quot;: &quot;jiang@email.com&quot;},
{name: &quot;李小璐&quot;, &quot;email&quot;: &quot;li@email.com&quot;}
];

var emails = users.map(function (user) { return user.email; });

console.log(emails.join(&quot;, &quot;)); 

// zhang@email.com, jiang@email.com, li@email.com
</code></pre>
<p>此方法用于我对于获取总数据中选择data里面的数组去选择我需要的部分<br>
<br></p>
<h2 id="小程序本地储存">小程序本地储存</h2>
<p>wx.setStorageSync('key','value);</p>
<p>wx.getStorageSync( 'key');</p>
<p>web中存数据会先调用toString() 把数据变为字符串 再进行储存</p>
<p>小程序存的数据什么类型 获取的就是什么类型</p>
<br>
<h2 id="onloadoption">onload(option)</h2>
<p>{</p>
<p>​	//option里面包含我从其他页面跳转url带参的参数</p>
<p>}<br>
<br></p>
<h2 id="组件的子传父-父传子">组件的子传父 父传子</h2>
<pre><code class="language-html">&lt;!-- 监听自定义事件 bindtabsitemchange是子组件向父组件传值加bind --&gt;
&lt;tab tabs=&quot;{{tabs}}&quot; bindtabsitemchange=&quot;handitemchange&quot;&gt;&lt;/tab&gt;
</code></pre>
<p>子组件接受参数</p>
<pre><code class="language-js"> properties: {
    tabs:{
      type:Array,
      value:[]
    }
  },
</code></pre>
<p>子组件向父组件传值</p>
<pre><code class="language-js">  methods: {
      //点击事件
      handleitemtap(e)
      {
        const {index}=e.currentTarget.dataset
        this.triggerEvent(&quot;tabsitemchange&quot;,{index} )
      }
  }
</code></pre>
<p>父组件对传值的处理</p>
<pre><code class="language-js">//tab子组件点击事件
handitemchange(e)
{
  console.log(e);
  //获取被点击的标题索引
  const {index}=e.detail;
  let {tabs}=this.data
  tabs.forEach((value,i)=&gt;i==index?value.isactive=true:value.isactive=false)
  this.setData({
      //更新父组件的内容
    tabs
  })
  
},
</code></pre>
<br>
## 用到的周期函数
<pre><code class="language-js">//只用加载该页面才调用  
  onLoad: function (options) {
      console.log(options);
      this.qureyparams.cid=options.cid
      console.log(this.qureyparams);
      this.getgoodslist()
  },

       //每次回到该页面就会调用
     onShow(){
         ...
     },
      
//页面滚动条触底事件 要判断是否有下一页数据 总页数 页码   页码*获取条数&gt;=总数据 没有下一页
  onReachBottom()
  {
      //判断是否还有下一页
      if(this.qureyparams.pagenum&gt;=this.totalpagesize)
      {
        //给个提示
        wx.showToast({
          title:'',
          icon:'none',
          duration:1500,
         
        })
      }
      else{
     
         this.qureyparams.pagenum++
        console.log(this.qureyparams.pagenum);
        this.getgoodslist()
      }
  },
	
//下拉刷新触发函数 
  onPullDownRefresh(){
      //1 重置数组
      this.setData({
        goodslist:[]
      })
      //重置页数
      this.qureyparams.pagenum=1
      //重新发请求
      this.getgoodslist()
      //在方法里面手动关闭下拉刷新等待效果
      //（ wx.stopPullDownRefresh()）
  },
      
      
</code></pre>
<p>对于下拉刷新可以在需要的文件下加<code>&quot;enablePullDownRefresh&quot;: true</code></p>
<p>也可以在app.json全局加刷新效果 包括下拉刷新的样式也是可以添加的</p>
<pre><code class="language-js">  &quot;window&quot;:{
    &quot;backgroundTextStyle&quot;:&quot;light&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#eb4450&quot;,
    &quot;navigationBarTitleText&quot;: &quot;fanfan&quot;,
    &quot;navigationBarTextStyle&quot;:&quot;white&quot;,

    &quot;backgroundColor&quot;: &quot;#0094ff&quot;

  },
</code></pre>
<br>
<h2 id="对于下拉加载新数据的方法">对于下拉加载新数据的方法</h2>
<p>先对原先数据进行解构后，把新数据加进去，而不是刷新数组</p>
<pre><code class="language-js"> this.setData({
      goodslist:[...this.data.goodslist,...res.data.message.goods]
    })
</code></pre>
<br>
<br>
<h2 id="小程序对于用户权限调用以及获取">小程序对于用户权限调用以及获取</h2>
<pre><code class="language-js">//权限给与设置  ***
  //调用小程序内置api 获取用户的收货地址 追踪授权状态 SCOPE
  //增加收货地址
  handleaddress() {

    //打印授权的状态
    wx.getSetting({
      success: (res) =&gt; { 
        console.log(res);
        //判断用户是否给权限
        const scopeaddress = res.authSetting[&quot;scope.address&quot;]
        //用户同意权限 直接调用
        if (scopeaddress || scopeaddress == undefined) {
          wx.chooseAddress({
            success: (result) =&gt; {
              //存地址到缓存
              wx.setStorageSync('address', result);
              console.log(result);
            },
          });
        }
        //如果没给 调用接口让用户同意  打开授权页面
        else {
          wx.openSetting({
            success: (result) =&gt; {
              console.log(result);
              //调用用户同意权限接口
              wx.chooseAddress({
                success: (res) =&gt; {
                  wx.setStorageSync('address', res);
                  console.log(res);

                },

              });
            },

          });
        }
      },
    });
  },

</code></pre>
]]></content>
    </entry>
</feed>