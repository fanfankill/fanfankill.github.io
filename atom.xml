<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fanfankill.github.io</id>
    <title>fanfan</title>
    <updated>2021-06-26T13:20:58.066Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fanfankill.github.io"/>
    <link rel="self" href="https://fanfankill.github.io/atom.xml"/>
    <subtitle>&lt;strong&gt;前端小白&lt;/strong&gt;</subtitle>
    <logo>https://fanfankill.github.io/images/avatar.png</logo>
    <icon>https://fanfankill.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, fanfan</rights>
    <entry>
        <title type="html"><![CDATA[手写axios]]></title>
        <id>https://fanfankill.github.io/post/shou-xie-axios/</id>
        <link href="https://fanfankill.github.io/post/shou-xie-axios/">
        </link>
        <updated>2021-06-26T13:00:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="axios">axios</h2>
<p>客户端  请求  服务端</p>
<ul>
<li>
<p>请求行</p>
<p>url</p>
<p>请求方式</p>
</li>
<li>
<p>多个请求头</p>
<p>域名，cooike，content-Type等</p>
</li>
<li>
<p>请求体</p>
</li>
</ul>
<p>post方法传的参数</p>
<p>服务端  响应  客户端</p>
<ul>
<li>
<p>响应行</p>
<p>status statusText</p>
</li>
<li>
<p>多个响应头</p>
<p>Content-Type:text/html</p>
</li>
<li>
<p>响应体</p>
<p>数据返回</p>
</li>
</ul>
<h2 id="xhr">XHR</h2>
<p>XMLHttpRequest对象可以和服务器交互 不会刷新网页</p>
<p>只有XHR和fetch发出的才是ajax请求</p>
<p>一般的请求就类似跳转和刷新页面</p>
<p>ajax只是调用监视回调函数并传入响应相关的数据</p>
<h2 id="api">API</h2>
<p>XMLHttpRequest() //创建XHR对象的构造函数</p>
<p>status：响应状态码</p>
<p>statusText：响应状态文本</p>
<p>onreadystatechange：绑定readyState改变的监听</p>
<p>open(method,url)：初始化请求</p>
<p>send(data)：发送请求</p>
<p>abort()：中断请求</p>
<br>
<br>
<h2 id="手写实现axios">手写实现axios</h2>
<pre><code class="language-js">&lt;script&gt;
    
    //接口在本地node.js实现
      function getdata()
    {
        console.log('发送get请求');
        axios({
            url:'http://localhost:3000/getposition',
            parmas:{
               
            name:'fanfan',
            age:19,
            number:13142278876
            }
        }).then(res=&gt;{
            console.log(res);
        })
    }

    
    //axios手写实现
     
    function axios({
        //解构赋值  写好默认值
        url,
        method='GET',
        data={},
        parmas={},
    }){
        //返回promise对象
         return new Promise( (resolve,reject)=&gt;{
       
         //对url的处理  有些get请求参数需要拼接另外函数实现拼接
            url+='?'+pinjie(parmas)
    
             //创建xhr对象
             const request=new XMLHttpRequest()
            //打开连接
             request.open(method,url,true) 
            //转换为JSON对象 
            if(method=='GET')
            {
                request.send()
            }
           else if(method=='post')
           {
          
           //发送JSON格式的对象肯定要加请求头 告诉服务器请求体是JSON格式
            request.setRequestHeader('Content-Type','application/json;charset=uft-8')
            //转换为JSON发送
            request.send(JSON.stringify(data))
           }
    
           //绑定状态改变的监听 从发送变为成功或者失败调用的函数
           request.onreadystatechange=function(){
                //进入判断 如果请求没有完成 直接结束
                if(request.readyState!==4)
                {
                    return 
                }
                //如果响应状态码在 200~299为成功
                const {status,statusText} =request
                //自己加的属性
                let author='fanfan'
                
                if(status&gt;=200&amp;&amp;status&lt;=299)
                {
                    //准备结果对象response 的其中几条
                    const response={
                        //对应返回的数据可以知道这些东西是什么
                        data:JSON.parse(request.response),
                        status,
                        statusText,
                        //自己添加的属性
                        author
                      
                    }
                    resolve(response)
                }else{
                    //请求失败返回message信息和状态码
                    reject(new Error('requset error status is '+status))
                }
           }
              
         })
    }

    //拼接参数 for-in解决
    function pinjie(obj)
    {
        let  queryString=''
        for(let k in obj)
        {
            queryString+= k+'='+obj[k]+'&amp;'
        }
        //判断有没有值
        if(queryString)
        {
            queryString=queryString.slice(0,queryString.length-1)
        }
        //拼接到url上面
       return  queryString
    }
    
    
&lt;/script&gt;


</code></pre>
<br>
<br>
<h2 id="实现结果">实现结果</h2>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1624712565528.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mustache]]></title>
        <id>https://fanfankill.github.io/post/mustache/</id>
        <link href="https://fanfankill.github.io/post/mustache/">
        </link>
        <updated>2021-06-26T05:50:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vue源码学习">vue源码学习</h1>
<h2 id="什么是模板引擎">什么是模板引擎</h2>
<p><strong>将数据要变为试图最优雅的解决方案</strong></p>
<p>历史上出现过数据变为视图的方法</p>
<ul>
<li>
<p>纯DOM</p>
</li>
<li>
<p>数组join法</p>
</li>
<li>
<p>ES6的反引号法</p>
<p>新增的 <code>${a}</code>的语法糖</p>
</li>
<li>
<p>模板引擎</p>
</li>
</ul>
<p><strong>数组join法</strong></p>
<pre><code class="language-js">//换行一样
var message='fanfan'
var str=[
    '&lt;li&gt;',
    '&lt;div&gt;'+message+'&lt;/div&gt;',
    '&lt;/li&gt;'
].join()
</code></pre>
<p>ES6的语法糖</p>
<pre><code class="language-js">let a='fanfan'
list.innerHTTML+=`
	&lt;li&gt;
		&lt;div class=&quot;fanfan&quot;&gt;
				${a}的信息
		&lt;/div&gt;
	&lt;/li&gt;
`
</code></pre>
<h2 id="mustache库">mustache库</h2>
<p>{{ }} 像胡子  所以取名叫胡子</p>
<pre><code class="language-js">  var user = { name: &quot;Olive&quot;, age: 23, sex: &quot;girl&quot; };
        var template = &quot;My name is  {{name}} ,I'm  {{age}} ,Sex is {{sex}}&quot;;
        var view = Mustache.render(template, user)

   console.log(view);
</code></pre>
<p><strong>简单模式下正则表达式可以实现</strong></p>
<pre><code class="language-js"> var template = &quot;My name is  {{name}} ,I'm  {{age}} ,Sex is {{sex}}&quot;;
    
            console.log(template.replace(/\{\{(\w+)\}\}/g,function(a,b,c){
                console.log(a,b,c);
                return '❤'
            }));

/**
	b 找出了里面的内容 可以用来替换
	{{name}} name 12
	{{age}} age 27
	{{sex}} sex 43
 	My name is  ❤ ,I'm  ❤ ,Sex is ❤*/
</code></pre>
<pre><code class="language-js"> 
//进行函数封装
function likerender(template,data)
            {
                return template.replace(/\{\{(\w+)\}\}/g,function(findstr,$1){
                //匹配data对象里面的属性
                return data[$1]
                     });
            }

            var data={
                name:'fanfan',
                age:18,
                sex:'man'
            }

            console.log(likerender(template,data));
		
//My name is  fanfan ,I'm  18 ,Sex is man
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 微信小程序开发记录]]></title>
        <id>https://fanfankill.github.io/post/xiao-cheng-xu-kai-fa-ji-lu/</id>
        <link href="https://fanfankill.github.io/post/xiao-cheng-xu-kai-fa-ji-lu/">
        </link>
        <updated>2021-06-20T07:51:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="es6-map函数-选择作用">ES6 map()函数 (选择作用)</h2>
<pre><code>var users = [
{name: &quot;张含韵&quot;, &quot;email&quot;: &quot;zhang@email.com&quot;},
{name: &quot;江一燕&quot;, &quot;email&quot;: &quot;jiang@email.com&quot;},
{name: &quot;李小璐&quot;, &quot;email&quot;: &quot;li@email.com&quot;}
];

var emails = users.map(function (user) { return user.email; });

console.log(emails.join(&quot;, &quot;)); 

// zhang@email.com, jiang@email.com, li@email.com
</code></pre>
<p>此方法用于我对于获取总数据中选择data里面的数组去选择我需要的部分<br>
<br></p>
<h2 id="小程序本地储存">小程序本地储存</h2>
<p>wx.setStorageSync('key','value);</p>
<p>wx.getStorageSync( 'key');</p>
<p>web中存数据会先调用toString() 把数据变为字符串 再进行储存</p>
<p>小程序存的数据什么类型 获取的就是什么类型</p>
<br>
<h2 id="onloadoption">onload(option)</h2>
<p>{</p>
<p>​	//option里面包含我从其他页面跳转url带参的参数</p>
<p>}<br>
<br></p>
<h2 id="组件的子传父-父传子">组件的子传父 父传子</h2>
<pre><code class="language-html">&lt;!-- 监听自定义事件 bindtabsitemchange是子组件向父组件传值加bind --&gt;
&lt;tab tabs=&quot;{{tabs}}&quot; bindtabsitemchange=&quot;handitemchange&quot;&gt;&lt;/tab&gt;
</code></pre>
<p>子组件接受参数</p>
<pre><code class="language-js"> properties: {
    tabs:{
      type:Array,
      value:[]
    }
  },
</code></pre>
<p>子组件向父组件传值</p>
<pre><code class="language-js">  methods: {
      //点击事件
      handleitemtap(e)
      {
        const {index}=e.currentTarget.dataset
        this.triggerEvent(&quot;tabsitemchange&quot;,{index} )
      }
  }
</code></pre>
<p>父组件对传值的处理</p>
<pre><code class="language-js">//tab子组件点击事件
handitemchange(e)
{
  console.log(e);
  //获取被点击的标题索引
  const {index}=e.detail;
  let {tabs}=this.data
  tabs.forEach((value,i)=&gt;i==index?value.isactive=true:value.isactive=false)
  this.setData({
      //更新父组件的内容
    tabs
  })
  
},
</code></pre>
<br>
## 用到的周期函数
<pre><code class="language-js">//只用加载该页面才调用  
  onLoad: function (options) {
      console.log(options);
      this.qureyparams.cid=options.cid
      console.log(this.qureyparams);
      this.getgoodslist()
  },

       //每次回到该页面就会调用
     onShow(){
         ...
     },
      
//页面滚动条触底事件 要判断是否有下一页数据 总页数 页码   页码*获取条数&gt;=总数据 没有下一页
  onReachBottom()
  {
      //判断是否还有下一页
      if(this.qureyparams.pagenum&gt;=this.totalpagesize)
      {
        //给个提示
        wx.showToast({
          title:'',
          icon:'none',
          duration:1500,
         
        })
      }
      else{
     
         this.qureyparams.pagenum++
        console.log(this.qureyparams.pagenum);
        this.getgoodslist()
      }
  },
	
//下拉刷新触发函数 
  onPullDownRefresh(){
      //1 重置数组
      this.setData({
        goodslist:[]
      })
      //重置页数
      this.qureyparams.pagenum=1
      //重新发请求
      this.getgoodslist()
      //在方法里面手动关闭下拉刷新等待效果
      //（ wx.stopPullDownRefresh()）
  },
      
      
</code></pre>
<p>对于下拉刷新可以在需要的文件下加<code>&quot;enablePullDownRefresh&quot;: true</code></p>
<p>也可以在app.json全局加刷新效果 包括下拉刷新的样式也是可以添加的</p>
<pre><code class="language-js">  &quot;window&quot;:{
    &quot;backgroundTextStyle&quot;:&quot;light&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#eb4450&quot;,
    &quot;navigationBarTitleText&quot;: &quot;fanfan&quot;,
    &quot;navigationBarTextStyle&quot;:&quot;white&quot;,

    &quot;backgroundColor&quot;: &quot;#0094ff&quot;

  },
</code></pre>
<br>
<h2 id="对于下拉加载新数据的方法">对于下拉加载新数据的方法</h2>
<p>先对原先数据进行解构后，把新数据加进去，而不是刷新数组</p>
<pre><code class="language-js"> this.setData({
      goodslist:[...this.data.goodslist,...res.data.message.goods]
    })
</code></pre>
<br>
<br>
<h2 id="小程序对于用户权限调用以及获取">小程序对于用户权限调用以及获取</h2>
<pre><code class="language-js">//权限给与设置  ***
  //调用小程序内置api 获取用户的收货地址 追踪授权状态 SCOPE
  //增加收货地址
  handleaddress() {

    //打印授权的状态
    wx.getSetting({
      success: (res) =&gt; { 
        console.log(res);
        //判断用户是否给权限
        const scopeaddress = res.authSetting[&quot;scope.address&quot;]
        //用户同意权限 直接调用
        if (scopeaddress || scopeaddress == undefined) {
          wx.chooseAddress({
            success: (result) =&gt; {
              //存地址到缓存
              wx.setStorageSync('address', result);
              console.log(result);
            },
          });
        }
        //如果没给 调用接口让用户同意  打开授权页面
        else {
          wx.openSetting({
            success: (result) =&gt; {
              console.log(result);
              //调用用户同意权限接口
              wx.chooseAddress({
                success: (res) =&gt; {
                  wx.setStorageSync('address', res);
                  console.log(res);

                },

              });
            },

          });
        }
      },
    });
  },

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[socket.io实现实时聊天室]]></title>
        <id>https://fanfankill.github.io/post/socketio-shi-xian-shi-shi-liao-tian-shi/</id>
        <link href="https://fanfankill.github.io/post/socketio-shi-xian-shi-shi-liao-tian-shi/">
        </link>
        <updated>2021-06-15T17:55:30.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Node.js</strong>部分（服务端）</p>
<pre><code class="language-js">  var express=require('express')
var app=express()
var server=require('http').createServer(app)
var io=require('socket.io')(server)

app.use(express.static(__dirname+'/public'))

//设置允许跨域
app.all('*', function (req, res, next) {
      res.header(&quot;Access-Control-Allow-Credentials&quot;, true)
      res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)
      res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;)
      res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;)
      res.header(&quot;X-Powered-By&quot;, ' 3.2.1')
      res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;)
      next()
})

//放用户
const users=[]

io.on('connection',function(socket){
    console.log(&quot;新用户加入房间&quot;);

    //监听Login事件
    socket.on('login',(data)=&gt;{
            console.log(data);
        //放数据,顺便增加唯一id
        users.push({...data,id:socket.id})

        console.log('id是'+socket.id);
        //所有人广播
        io.emit('loginback',{...data,id:socket.id})
    })

    socket.on('client',data2=&gt;{
        console.log(data2.value);
        data2.users=users.find(u=&gt;u.id==socket.id)
        console.log(data2.users);
        socket.broadcast.emit('sendmes',data2)
    })
    
})

server.listen(3000,()=&gt;{
    console.log('http://127.0.0.1:3000');
})

</code></pre>
<h2 id="前端部分">前端部分</h2>
<pre><code class="language-js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;Socket聊天室&lt;/title&gt;
  &lt;style type=&quot;text/css&quot;&gt;
    /**输入框样式*/
    .text * {
      margin: 0;
      padding: 0;
    }

    #main {
      text-align: center;
    }

    #showmes {
      position: relative;
      background: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fcdn.duitang.com%2Fuploads%2Fitem%2F201209%2F08%2F20120908134318_YVAwx.jpeg&amp;refer=http%3A%2F%2Fcdn.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1626261869&amp;t=964bbb79e059f74901698cdd5f6de691) no-repeat;
      background-size: 100% 110%;
      margin: auto;
      width: 600px;
      height: 600px;
      overflow: hidden;
      overflow-y: scroll;
    }

    /**别人气泡*/
    .leftspan2 {
      float: left;
      color: grey;
      font-weight: 1000;
      position: absolute;
      top: -18px;
      font-size: 3px;
      left: 25px;
    }

    .leftspan {
      color: white;
      background-color: #635f5fec;
      padding: 5px 8px;
      font-size: 14px;
      float: left;
      position: relative;
      border-radius: 4px;
      margin-left: 25px;
      margin-right: 5px;

    }

    .leftspan::after {
      content: '';
      border: 8px solid #ffffff00;
      border-right: 8px solid #635f5fec;
      ;
      position: absolute;
      top: 6px;
      left: -16px;
    }

    /*自己气泡**/
    .pp {
      width: 100%;
      position: relative;
      min-height: 20px;
      float: right;
      margin-bottom: 15px;
    }

    .rightspan2 {
      float: right;
      color: grey;
      font-weight: 1000;
      position: absolute;
      top: -18px;
      font-size: 3px;
      right: 15px;
    }

    .rightspan {
      float: right;
      position: relative;
      color: rgb(2, 2, 2);
      font-weight: 500;
      background-color: #88e99d;
      padding: 5px 8px;
      font-size: 14px;
      border-radius: 4px;
      margin-left: 5px;
      margin-right: 15px;

    }

    .rightspan::after {
      content: '';
      border: 8px solid #ffffff00;
      border-left: 8px solid #88e99d;
      ;
      position: absolute;
      top: 6px;
      right: -13px;

    }

    /**输入框*/
    #text {
      width: 500px;
      height: 25px;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;

  &lt;div id=&quot;joinname&quot;&gt;
    &lt;span&gt;请输入加入的姓名&lt;/span&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;&lt;button onclick=&quot;joinchat()&quot;&gt;提交&lt;/button&gt;
  &lt;/div&gt;
  &lt;div id=&quot;main&quot; style=&quot;display: none;&quot;&gt;
    
    &lt;h1&gt;fanfan的聊天室&lt;/h1&gt;
    &lt;div id=&quot;showmes&quot;&gt;

    &lt;/div&gt;
    &lt;div class=&quot;inputtxt&quot;&gt;
      &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt;&lt;/input&gt;
      &lt;button id=&quot;btn&quot; onclick=&quot;sendmes()&quot;&gt;发送&lt;/button&gt;
    &lt;/div&gt;

  &lt;/div&gt;

  &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    //全局变量
    name = ''
    var socket = io(); //连接聊天室的io服务器 io服务器的根地址
    //连接进聊天室
    function firstjoin() {

      socket.on('hello', data =&gt; {
        console.log('服务端发送的东西为：' + data);
      })
    }

    function notnull() {
      if (document.getElementById('text').value != '') {
        return 1;
      }
      else {
        return 0;
      }
    }
    //自己发信息
    function sendmes() {
      if (notnull()) {
        var mes = document.getElementById('text').value
        var p = document.createElement('p');
        var span = document.createElement('span')
        var span2 = document.createElement('span')
        span.innerHTML = mes;
        span2.innerHTML = name;
        span2.className = 'rightspan2'
        span.className = 'rightspan'
        p.className = 'pp'
        p.appendChild(span2)
        p.appendChild(span)
        document.getElementById('showmes').appendChild(p)
        socket.emit('client', {'value':document.getElementById('text').value,'name':name})
        document.getElementById('text').value = ''

        document.getElementById(&quot;showmes&quot;).scrollTop += document.getElementById(&quot;showmes&quot;).offsetHeight;
      }

    }
    //收到别人发的信息
    socket.on('sendmes', data =&gt; {
      console.log(data);
      var p = document.createElement('p');
      var span = document.createElement('span');
      var span2 = document.createElement('span');
      span.className = 'leftspan'
      console.log('姓名是'+data.users.name);
      span2.innerHTML = data.users.name
      span2.className = 'leftspan2'
      span.innerHTML = data.value;
      p.appendChild(span2)
      p.appendChild(span)
      p.className = 'pp'

      document.getElementById('showmes').appendChild(p)

      document.getElementById(&quot;showmes&quot;).scrollTop += document.getElementById(&quot;showmes&quot;).offsetHeight;
    })

    //加入聊天室提醒
    function joinchat() {
      if (document.getElementById('name').value.length &gt;= 1 &amp;&amp; document.getElementById('name').value.length &lt;= 6) {
        //加入盒子隐藏 聊天盒子显示
        document.getElementById('main').style.display='block'
        document.getElementById('joinname').style.display='none'
        name=document.getElementById('name').value
        socket.emit('login', { 'name': document.getElementById('name').value })
      }

    }
    socket.on('loginback', data =&gt; {
      var p = document.createElement('p');
      p.innerHTML = data.name + '加入了房间';
      p.style.color = 'grey'
      p.style.fontWeight = '1000'
      p.style.textAlign = 'center'
      p.style.fontSize = '6px'
      document.getElementById('showmes').appendChild(p)
    })
    //回车发送消息
    document.onkeydown = function (e) {
      console.log('1');
      var ev = document.all ? window.event : e;
      if (ev.keyCode == 13) {
        sendmes();
      }
    }
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;

</code></pre>
<br>
<br>
<br>
每次进入页面先输入自己的姓名才能进入聊天室
每个客户端对应自己独特的socket id来获取发送消息的名称
给回车绑定事件，每次回车发送 可以实现多人在线实时聊天，且有自己对应的名称 自己发送的消息和收到的消息进行区分
<figure data-type="image" tabindex="1"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015910759.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015915621.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015921537.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015925385.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015929804.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015931812.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/mage-20210616015934765.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事件循环]]></title>
        <id>https://fanfankill.github.io/post/shi-jian-xun-huan/</id>
        <link href="https://fanfankill.github.io/post/shi-jian-xun-huan/">
        </link>
        <updated>2021-06-09T16:10:14.000Z</updated>
        <content type="html"><![CDATA[<p>JS为单线程<br>
宏任务主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)</p>
<p>微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)<br>
<img src="https://fanfankill.github.io/post-images/1623256115003.webp" alt="" loading="lazy"></p>
<p>例子1</p>
<pre><code class="language-js">console.log('script start');

setTimeout(function() {
  console.log('timeout1');
}, 10);

new Promise(resolve =&gt; {
    console.log('promise1');
    resolve();
    setTimeout(() =&gt; console.log('timeout2'), 10);
}).then(function() {
    console.log('then1')
})

console.log('script end');
</code></pre>
<p><img src="https://fanfankill.github.io/post-images/1623255042505.png" alt="" loading="lazy"><br>
先执行第一个log</p>
<p>setTimeout推入宏队列hong1</p>
<p>遇到promise马上执行打印然后将它所有的then推入微队列后把setTimeout推入宏队列hong2</p>
<p>先执行微队列，所以先打印then里面的。然后宏队列再打印<br>
<br><br>
<br><br>
<br><br>
例子2</p>
<pre><code class="language-js">  console.log('1');

setTimeout(function() {
    console.log('2');
  
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})

new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
   
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})
</code></pre>
<p><img src="https://fanfankill.github.io/post-images/1623255137440.png" alt="" loading="lazy"><br>
当在只剩两个宏任务的setTimeout时候执行第一个时，Promise压入了then的微任务，让第二个宏任务又排到微任务后等待</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS知识点]]></title>
        <id>https://fanfankill.github.io/post/js-zhi-shi-dian/</id>
        <link href="https://fanfankill.github.io/post/js-zhi-shi-dian/">
        </link>
        <updated>2021-06-05T12:44:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="节流和防抖">节流和防抖</h2>
<p><strong>防抖</strong></p>
<pre><code class="language-js"> //防抖 在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms  用于停止动作后才开始触发的
    function debounce(fn,delay){
        let timer=null;
        return function(){
            if(timer){
                clearTimeout(timer)//存在即重新计时
                
            }
              timer=setTimeout(fn,delay)
            
        }
    }
</code></pre>
<p><strong>节流</strong></p>
<pre><code class="language-js">//节流 适合一直不给机会触发防抖的
    function throttle(fn,delay){
       
    let valid = true
    return function() {
        
        //闭包函数内的vaild为同一个
       if(!valid){
           
           return false 
       }
       
        valid = false//防止多次触发
        
        setTimeout(() =&gt; {
            fn()
            valid = true;
        }, delay)
    }
}
</code></pre>
<br>
<br>
<br>
<h2 id="判断是不是数组">判断是不是数组</h2>
<pre><code class="language-js">var a=new Array()
var b=new Object()

console.log(Array instanceof Object); //true   js数组可以看作对象

console.log(Array.isArray(a)); //true   数组方法

//误区
typeof(a) //object  typeof运算符用于判断对象的类型，但是对于一些创建的对象，它们都会返回'object'  返回的类型 undefined' 'boolean' 'string' 'number' 'object'  'function'

Object.prototype.toString.call(a) //Object Array 用来判断类型

Object.prototype.toString.call(b) //object Object

//Array 和 Function都是Object的实例 都重写了toString()方法 所以直接调用的话是重写后的方法 调用原型上的方法返回类型

//对toString()方法重写的证明
console.log(Array.prototype.hasOwnProperty(&quot;toString&quot;));//true

delete Array.prototype.toString;//delete操作符可以删除实例属性

console.log(arr.toString());//&quot;[object Array]&quot;


//  prototype 和__proto__    一般来说 __proto__==constructor.prototype


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DOM]]></title>
        <id>https://fanfankill.github.io/post/dom/</id>
        <link href="https://fanfankill.github.io/post/dom/">
        </link>
        <updated>2021-06-01T13:01:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="节点层次">节点层次</h2>
<h2 id="nodename-和-nodevalue-属性">nodeName 和 nodeValue 属性</h2>
<p>if(someNode.nodeType == 1)</p>
<p>{</p>
<p>//先确定是个元素</p>
<p>value = someNode.nodeName;   //nodeName 的值是元素的标签名</p>
<p>}</p>
<p>对于元素节点，nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null。</p>
<hr>
<h2 id="节点关系">节点关系</h2>
<p>每个节点都有一个 **childNodes **属性，其中保存着一个 **NodeList **对象。**NodeList **是一种类数组 对象，用于保存一组有序的节点</p>
<p>val.childNodes[0]   //如果是标签之间有空隙 默认为文字  打印出  #text</p>
<p><strong>子节点</strong></p>
<p>nextSibling</p>
<p>previousSibling</p>
<p><strong>父节点</strong></p>
<p>firstChild</p>
<p>lastChild</p>
<p><strong>查看是否有子节点</strong></p>
<p>val.hasChildNodes()  //boolean</p>
<h2 id="操作节点">操作节点</h2>
<p>**appendChild()**和 **insertBefore()**方法都只插入节点</p>
<p>**replaceChild()**方法接受的两个参数是：要插入的节点和要替换的节点。尽管从技术上讲，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置</p>
<p><strong>removeChild()</strong> 即要移除 的节点。被移除的节点将成为方法的返回值</p>
<p><strong>cloneNode()</strong> 用于创建调用这个方法的节点 的一个完全相同的副本，接受一个布尔值参数，表示是否执行深复制</p>
<h2 id="document类型">Document类型</h2>
<p> nodeType 的值为 9；</p>
<p> nodeName 的值为&quot;#document&quot;；、</p>
<p> nodeValue 的值为 null；</p>
<p> parentNode 的值为 null；</p>
<p> ownerDocument 的值为 null；</p>
<p> 其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment。</p>
<p>//设置文档标题</p>
<p>document.title = &quot;New page title&quot;;</p>
<p>//取得完整的 URL</p>
<p>var url = document.URL;</p>
<p>//取得域名</p>
<p>var domain = document.domain;</p>
<p>//取得来源页面的 URL</p>
<p>var referrer = document.referrer;</p>
<br>
<p>星号（*）通常表示“全部”。</p>
<pre><code class="language-js">var allElements = document.getElementsByTagName(&quot;*&quot;); 
</code></pre>
<p>在 IE 中调用getElementsByTagName(&quot;*&quot;)将会返回所有注释节点</p>
<h2 id="element类型">Element类型</h2>
<p> nodeType 的值为 1；</p>
<p> nodeName 的值为元素的标签名；</p>
<p> nodeValue 的值为 null；</p>
<p> parentNode 可能是 Document 或 Element；</p>
<p> 其子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。</p>
<p>访问元素的标签名<strong>nodeName</strong> 和<strong>tagName</strong> 这两个属性会返回 相同的值</p>
<p>在 HTML 中，标签名始终都以全部大写表示</p>
<pre><code class="language-js">if (element.tagName.toLowerCase() == &quot;div&quot;) //这样最好（适用于任何文档） //在此执行某些操作 
</code></pre>
<h2 id="取得特性">取得特性</h2>
<p><em><strong>getAttribute()</strong></em></p>
<p>div.getAttribute(&quot;id&quot;) //取得这个元素的特征值</p>
<p>特性的名称是不区分大小写的</p>
<p>自定义特性应该加上 data-前缀以便验证(用轮播图的时候自定义特性)</p>
<h2 id="设置特性">设置特性</h2>
<p><em><strong>setAttribute()</strong></em></p>
<p>这个方法接受两个参数：要设置的特性名和 值。如果特性已经存在，setAttribute()会以指定的值替换现有的值</p>
<p>通过这个方法设置的 特性名会被统一转换为小写形式，即&quot;ID&quot;最终会变成&quot;id&quot;</p>
<pre><code class="language-js">div.mycolor = &quot;red&quot;; 

 alert(div.getAttribute(&quot;mycolor&quot;)); //null（IE 除外） 因此想通过 getAttribute()取得同名特性的值，结果会返回 null
</code></pre>
<p>***removeAttribute()***用于彻底删除元素的特性</p>
<p>div.removeAttribute(&quot;class&quot;);</p>
<h2 id="attributes-属性">attributes 属性</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue+node.js+mysql开发停车场管理系统]]></title>
        <id>https://fanfankill.github.io/post/vuenodejsmysql-kai-fa-ting-che-chang-guan-li-xi-tong/</id>
        <link href="https://fanfankill.github.io/post/vuenodejsmysql-kai-fa-ting-che-chang-guan-li-xi-tong/">
        </link>
        <updated>2021-05-29T06:25:43.000Z</updated>
        <content type="html"><![CDATA[<p>前端github  <strong>https://github.com/fanfankill/depotsystem</strong><br>
服务端node  <strong>https://github.com/fanfankill/depotsystem_nodejs</strong></p>
<h2 id="522-529"><strong>5.22-5.29</strong></h2>
<p>对于车位管理页面完成了以下功能</p>
<ul>
<li>
<p>对所有车位信息的获取，总条数的获取以及分页操作<br>
<img src="https://fanfankill.github.io/post-images/1622270278948.png" alt="" loading="lazy"></p>
</li>
<li>
<p>新增车位信息（暂时以车位编号为主键 且按自动递增处理，所有其他信息都是在,未要求自己填入）<br>
<img src="https://fanfankill.github.io/post-images/1622270324356.png" alt="" loading="lazy"></p>
</li>
<li>
<p>删除车位信息</p>
</li>
<li>
<p>搜索车位信息<br>
<img src="https://fanfankill.github.io/post-images/1622270252631.png" alt="" loading="lazy"></p>
</li>
<li>
<p>修改车位信息（两个1 0 的修改和对车位所属区域的修改，车位价格和车位区域绑定一起，修改区域自动修改价格）<br>
<img src="https://fanfankill.github.io/post-images/1622270469346.png" alt="" loading="lazy"></p>
</li>
<li>
<p>添加车位区域（车位名称（主键）车位区域价格 对车位区域的描述）<br>
<img src="https://fanfankill.github.io/post-images/1622270291881.png" alt="" loading="lazy"></p>
<h2 id="530"><strong>5.30</strong></h2>
<p>进出车辆登记</p>
</li>
</ul>
<ol>
<li>暂时登记车牌号码 选择停车区域 node获取当前进入时间<br>
<img src="https://fanfankill.github.io/post-images/1622391426393.png" alt="" loading="lazy"><br>
<img src="https://fanfankill.github.io/post-images/1622391499326.png" alt="" loading="lazy"></li>
<li>当获取停车区域时候，使用watch属性，确保每次切换不同区域能够获取相应区域空闲车位<br>
<img src="https://fanfankill.github.io/post-images/1622391514068.png" alt="" loading="lazy"><br>
<img src="https://fanfankill.github.io/post-images/1622391521639.png" alt="" loading="lazy"></li>
<li>保证每个车辆只能进入时候被登记一次<br>
<img src="https://fanfankill.github.io/post-images/1622391560153.png" alt="" loading="lazy"></li>
<li>进出管理表与车位管理表相连接，每次登记一个，车位管理也会更新车位状态和车牌信息<br>
<img src="https://fanfankill.github.io/post-images/1622391622553.png" alt="" loading="lazy"></li>
<li>每次完成添加后立马更新车位空闲状态，防止多次更新同一个车位<br>
<br><br>
<br><br>
<br></li>
</ol>
<h2 id="531-66"><strong>5.31-6.6</strong></h2>
<p>车辆入库出库记录<br>
(与车位管理相关 每次记录一个后会修改选中的车位状态)<br>
1.按已出库和未出库来获取数据 点击直接获取（wacth属性）<br>
<img src="https://fanfankill.github.io/post-images/1622973621842.png" alt="" loading="lazy"><br>
<img src="https://fanfankill.github.io/post-images/1622973626404.png" alt="" loading="lazy"><br>
2.对于不同情况下的按钮和驶出时间进行区别设计，当为已驶出状态的按钮点击为已经记录过的详细信息<br>
<img src="https://fanfankill.github.io/post-images/1622973728852.png" alt="" loading="lazy"><br>
当为未出库状态下点击为预计算的信息()，若再次点击驶出按钮后则会修改该车位状态和进出状态并记录数据库<br>
<img src="https://fanfankill.github.io/post-images/1622973813093.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS事件]]></title>
        <id>https://fanfankill.github.io/post/js-shi-jian/</id>
        <link href="https://fanfankill.github.io/post/js-shi-jian/">
        </link>
        <updated>2021-04-28T07:09:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="事件">事件</h1>
<p>通过<strong>侦听器</strong>来预定事件</p>
<h2 id="事件流">事件流</h2>
<p><strong>事件流</strong>描述的是从页面中接收事件的顺序<br>
事件例图：<br>
<img src="https://fanfankill.github.io/post-images/1619594865905.png" alt="" loading="lazy"></p>
<p>IE 的事件流是事件冒泡流<br>
<img src="https://fanfankill.github.io/post-images/1619594715319.png" alt="" loading="lazy"></p>
<p>Netscape Communicator 的事件流是事件捕获流<br>
<img src="https://fanfankill.github.io/post-images/1619594736001.png" alt="" loading="lazy"><br>
<br></p>
<h2 id="事件冒泡">事件冒泡</h2>
<p>IE 的事件流叫做<strong>事件冒泡</strong>，即事件开始时由最具体的元素（文档中嵌套层次最深 的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。<br>
<br></p>
<h2 id="事件捕捉">事件捕捉</h2>
<p><strong>事件捕获</strong>的思想 是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。<br>
<br></p>
<h2 id="dom事件流">DOM事件流</h2>
<p>DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。<br>
<img src="https://fanfankill.github.io/post-images/1619594960277.png" alt="" loading="lazy"><br>
在 DOM 事件流中，实际的目标（元素）在捕获阶段不会接收到事件。这意味着在捕获阶段， 事件从 document 到再到后就停止了。下一个阶段是“处于目标”阶段，于是事件在上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生， 事件又传播回文档。</p>
<br>
## 事件处理程序
<p>事件就是用户或浏览器自身执行的某种动作。诸如 click、load 和 mouseover，都是事件的名字。 而响应某个事件的函数就叫做事件处理程序（或事件侦听器）</p>
<p>事件处理程序的名字以&quot;on&quot;开头（onclick，onload）<br>
<br></p>
<h2 id="html事件处理程序">HTML事件处理程序</h2>
<p>这个操作是通过指定 onclick 特性并将一些 JavaScript 代码作为它的值来定义的</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert('Clicked')&quot; /&gt; 
</code></pre>
<p>为了避免使用 HTML 实体，这里使用了单 引号。如果想要使用双引号，那么就要将代码改写成如下所示：</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&amp;quot;Clicked&amp;quot;)&quot; /&gt; 
</code></pre>
<p>事件处理程序中的代码在执行时，有权访问全局作用 域中的任何代码</p>
<pre><code class="language-html">&lt;!-- 输出 &quot;click&quot; --&gt; 
&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;&gt; 
</code></pre>
<p>这样指定事件处理程序具有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。这个 函数中有一个局部变量 event</p>
<br>
<p>通过 event 变量，可以直接访问事件对象，你不用自己定义它，也不用从函数的参数列表中读取。 在这个函数内部，this 值等于事件的目标元素</p>
<pre><code class="language-html">&lt;!-- 输出 &quot;Click Me&quot; --&gt; 
&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(this.value)&quot;&gt; 
</code></pre>
<br>
 ##  HTML 中指定事件处理程序的缺点
<p>1.存在一个时差问题。因为用户可能会在 HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件。以前面的例子来说明，假设 showMessage()函数是在按钮下方、页面的最底部定义的。如果用户在页面解 析 showMessage()函数之前就单击了按钮就会引发错误。为此，很多 HTML 事件处理程序都会被封 装在一个 try-catch 块中，以便错误不会浮出水面，如下面的例子所示：</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;try{showMessage();}catch(ex){}&quot;&gt;
</code></pre>
<p>2.这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同 JavaScript 引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。</p>
<p>3.是 HTML 与 JavaScript 代码紧密耦合。如果要更换事 件处理程序，就要改动两个地方：HTML 代码和 JavaScript 代码<br>
<br></p>
<h2 id="dom0-级事件处理程序">DOM0 级事件处理程序</h2>
<p>通过 JavaScript 指定事件处理程序的传统方式</p>
<p>原因一是简单，二是具有跨浏览器的优势</p>
<p>要使用 JavaScript 指定事件处理程序，首先必须取得一 个要操作的对象的引用</p>
<br>
<p>使用 DOM0 级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在 元素的作用域中运行；换句话说，程序中的 this 引用当前元素</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.onclick = function(){ 
alert(this.id); //&quot;myBtn&quot; 
};

btn.onclick = null; //删除事件处理程序
</code></pre>
<p>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理</p>
<p>将事件处理程序设置为 null 之后，再单击按钮将不会有任何动作发生。</p>
<br>
<br>
## DOM2 级事件处理程序
<p>“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：**addEventListener() **和 <strong>removeEventListener()</strong>。</p>
<p>它们都接受 3 个参数：要处 理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获 阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序</p>
<p>在按钮上为 click 事件添加事件处理程序</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.addEventListener(&quot;click&quot;, function(){ 
 alert(this.id); 
}, false); 
</code></pre>
<p>上面的代码为一个按钮添加了 onclick 事件处理程序，而且该事件会在冒泡阶段被触发</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.addEventListener(&quot;click&quot;, function(){ 
 alert(this.id); 
}, false); 
btn.addEventListener(&quot;click&quot;, function(){ 
 alert(&quot;Hello world!&quot;); 
}, false); 

</code></pre>
<p><strong>这里为按钮添加了两个事件处理程序。这两个事件处理程序会按照添加它们的顺序触发，因此首先 会显示元素的 ID，其次会显示&quot;Hello world!&quot;消息</strong></p>
<p>通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除，这也意味着通过 addEventListener()添加的匿 名函数将无法移除。</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.addEventListener(&quot;click&quot;, function(){ 
 alert(this.id)}, false); 
//这里省略了其他代码
btn.removeEventListener(&quot;click&quot;, function(){ //没有用！
 alert(this.id); 
}, false); 

</code></pre>
<p>传入 removeEventListener()中的事件处理程序函数必须与传入 addEventListener()中的<strong>相同</strong> ，因为一一对应，addEvenListener()可以给click或其他添加很多函数，所以removeEvenListener()也要一一去和它对应</p>
<p>大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段（f第三个参数为false），这样可以最大限度地兼容各种浏览器。<br>
<br></p>
<h2 id="事件对象">事件对象</h2>
<p>在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的 信息。</p>
<h2 id="dom中的事件对象">DOM中的事件对象</h2>
<p>兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.onclick = function(event){ 
 alert(event.type); //&quot;click&quot; 
}; 
btn.addEventListener(&quot;click&quot;, function(event){ 
 alert(event.type); //&quot;click&quot; 
}, false);
</code></pre>
<p>要阻止特定事件的默认行为，可以使用 preventDefault()方法</p>
<p>链接的默认行为就是在 被单击时会导航到其 href 特性指定的 URL。如果你想阻止链接导航这一默认行为，那么通过链接的 onclick 事件处理程序可以取消它</p>
<pre><code class="language-js">var link = document.getElementById(&quot;myLink&quot;); 
link.onclick = function(event){ 
 event.preventDefault(); 
};
</code></pre>
<p>stopPropagation()方法用于立即停止事件在 DOM 层次中的传播</p>
<p>从而避免触 发注册在 document.body 上面的事件处理程序</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.onclick = function(event){ 
 alert(&quot;Clicked&quot;); 
 event.stopPropagation(); 
}; 
document.body.onclick = function(event){ 
 alert(&quot;Body clicked&quot;); 
}; 
</code></pre>
<h2 id="事件类型">事件类型</h2>
<br>
<h3 id="load事件"><strong>load事件</strong></h3>
<p>当页面完全加载后（包括所有图像、JavaScript 文件、 CSS 文件等外部资源），就会触发 window 上面的 load 事件。</p>
<pre><code class="language-js">&lt;body onload=&quot;alert('Loaded!')&quot;&gt; 
&lt;/body&gt;

//对图像的load事件
&lt;img src=&quot;smile.gif&quot; onload=&quot;alert('Image loaded.')&quot;&gt; 
</code></pre>
<br>
<h3 id="unload-事件"><strong>unload 事件</strong></h3>
<p>利用这个事件最多的情况是清除引用，以避免内存泄漏<br>
<br></p>
<h3 id="resize-事件"><strong>resize 事件</strong></h3>
<p>当浏览器窗口被调整到一个新的高度或宽度时，就会触发 resize 事件</p>
<p>IE、Safari、Chrome 和 Opera 会在浏览 器窗口变化了 1 像素时就触发 resize 事件，然后随着变化不断重复触发。Firefox 则只会在用户停止调 整窗口大小时才会触发 resize 事件</p>
<p>浏览器窗口最小化或最大化时也会触发 resize 事件<br>
<br></p>
<h3 id="scroll-事件"><strong>scroll 事件</strong></h3>
<p>scroll 事件也会在文档被滚动期间重复被触发，所以有必要尽量保持事件 处理程序的代码简单<br>
<br></p>
<h3 id="焦点事件"><strong>焦点事件</strong></h3>
<p>焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与 document.hasFocus()方法及 document.activeElement 属性配合，可以知晓用户在页面上的行踪</p>
<ul>
<li>
<p><strong>blur</strong></p>
<p>在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它</p>
</li>
<li>
<p>DOMFocusIn</p>
<p>在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它冒泡</p>
</li>
<li>
<p>DOMFoucusOut</p>
<p>在元素失去焦点时触发，兼容性不强</p>
</li>
<li>
<p><strong>focus</strong></p>
<p>在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。</p>
</li>
<li>
<p>focusin</p>
<p>这个事件与 HTML 事件 focus 等价，但它冒泡</p>
</li>
<li>
<p>focusout</p>
<p>这个事件是 HTML 事件 blur 的通用版本<br>
<br></p>
</li>
</ul>
<h3 id="鼠标与滚轮事件"><strong>鼠标与滚轮事件</strong></h3>
<ul>
<li>
<p>click</p>
<p>在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。</p>
</li>
<li>
<p>dblclick</p>
<p>在用户双击主鼠标按钮（一般是左边的按钮）时触发。</p>
</li>
<li>
<p>mousedown</p>
<p>在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。</p>
</li>
<li>
<p>mouseenter</p>
<p>在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且 在光标移动到后代元素上不会触发。</p>
</li>
<li>
<p>mouseleave</p>
<p>在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且 在光标移动到后代元素上不会触发。</p>
</li>
<li>
<p>mousemove</p>
<p>当鼠标指针在元素内部移动时重复地触发。</p>
</li>
<li>
<p>mouseout</p>
<p>在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。</p>
</li>
<li>
<p>mouseover<br>
在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触 发。</p>
</li>
<li>
<p>mouseup</p>
<p>在用户释放鼠标按钮时触发。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图解HTTP第五章]]></title>
        <id>https://fanfankill.github.io/post/tu-jie-http-di-liu-zhang/</id>
        <link href="https://fanfankill.github.io/post/tu-jie-http-di-liu-zhang/">
        </link>
        <updated>2021-04-27T00:11:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="与http协助的web服务器">与HTTP协助的Web服务器</h1>
<h2 id="用单台虚拟主机实现多个域名">用单台虚拟主机实现多个域名</h2>
<p>允许一台HTTP服务器搭建多个Web站点。</p>
<p>即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器</p>
<p>在互联网上，域名通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站，所以，当请求发送到服务器时，已经是IP地址形式访问了</p>
<h2 id="通信数据转发程序代理-网关-隧道">通信数据转发程序：代理、网关、隧道</h2>
<ul>
<li>
<p>代理</p>
<p>扮演中间人，接收由客户端发送的请求并转发给服务器，同是，也接收服务器返回的响应并转发给客户端</p>
</li>
<li>
<p>网关</p>
<p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的服务器</p>
</li>
<li>
<p>隧道</p>
<p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序</p>
</li>
</ul>
<h3 id="代理"><strong>代理</strong></h3>
<p>利用代理服务器的理由：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的</p>
<p>代理按两种基准分类：一种是是否使用缓存，另一种是是否会修改报文</p>
<h4 id="缓存代理">缓存代理</h4>
<p>代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上</p>
<p>当代理再次接收对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回</p>
<h4 id="透明代理">透明代理</h4>
<p>转发请求或响应时，不对报文做任何加工的代理类型被称为<strong>透明代理</strong>，反之，称为非透明代理</p>
<hr>
<h2 id="网关">网关</h2>
<p>可以利用网关将HTTP请求转化为其他协议通信</p>
<p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。<br>
<img src="https://fanfankill.github.io/post-images/1619484447634.png" alt="" loading="lazy"></p>
<h2 id="隧道">隧道</h2>
<p>隧道可以按要求建立起一条与其他服务器的通信线路，可以使用SSL等加密手段进行通信。隧道的目的就是保住客户端与服务器能安全进行通信<br>
<img src="https://fanfankill.github.io/post-images/1619484421757.png" alt="" loading="lazy"></p>
<p>隧道本身不会去解析HTTP请求。请求保持原样中转给服务器。隧道会在双方通信断开连接的时候结束</p>
<hr>
<h2 id="保存资源的缓存">保存资源的缓存</h2>
<p>代理服务器会在服务器返回的响应时，保存一份资源副本<br>
<img src="https://fanfankill.github.io/post-images/1619484470802.png" alt="" loading="lazy"></p>
<h3 id="缓存有效期">缓存有效期</h3>
<p>存在资源更新等影响，需要去向源服务器确认</p>
<h3 id="客户端的缓存">客户端的缓存</h3>
<p>缓存也可以存在于客户端浏览器中，这种叫做<strong>临时网络文件</strong></p>
]]></content>
    </entry>
</feed>