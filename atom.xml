<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fanfankill.github.io</id>
    <title>fanfan</title>
    <updated>2021-05-30T16:21:24.015Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fanfankill.github.io"/>
    <link rel="self" href="https://fanfankill.github.io/atom.xml"/>
    <subtitle>&lt;strong&gt;前端小白&lt;/strong&gt;</subtitle>
    <logo>https://fanfankill.github.io/images/avatar.png</logo>
    <icon>https://fanfankill.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, fanfan</rights>
    <entry>
        <title type="html"><![CDATA[vue+node.js+mysql开发停车场管理系统]]></title>
        <id>https://fanfankill.github.io/post/vuenodejsmysql-kai-fa-ting-che-chang-guan-li-xi-tong/</id>
        <link href="https://fanfankill.github.io/post/vuenodejsmysql-kai-fa-ting-che-chang-guan-li-xi-tong/">
        </link>
        <updated>2021-05-29T06:25:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="522-529"><strong>5.22-5.29</strong></h2>
<p>对于车位管理页面完成了以下功能</p>
<ul>
<li>
<p>对所有车位信息的获取，总条数的获取以及分页操作<br>
<img src="https://fanfankill.github.io/post-images/1622270278948.png" alt="" loading="lazy"></p>
</li>
<li>
<p>新增车位信息（暂时以车位编号为主键 且按自动递增处理，所有其他信息都是在,未要求自己填入）<br>
<img src="https://fanfankill.github.io/post-images/1622270324356.png" alt="" loading="lazy"></p>
</li>
<li>
<p>删除车位信息</p>
</li>
<li>
<p>搜索车位信息<br>
<img src="https://fanfankill.github.io/post-images/1622270252631.png" alt="" loading="lazy"></p>
</li>
<li>
<p>修改车位信息（两个1 0 的修改和对车位所属区域的修改，车位价格和车位区域绑定一起，修改区域自动修改价格）<br>
<img src="https://fanfankill.github.io/post-images/1622270469346.png" alt="" loading="lazy"></p>
</li>
<li>
<p>添加车位区域（车位名称（主键）车位区域价格 对车位区域的描述）<br>
<img src="https://fanfankill.github.io/post-images/1622270291881.png" alt="" loading="lazy"></p>
<h2 id="530">5.30</h2>
<p>进出车辆登记</p>
</li>
</ul>
<ol>
<li>暂时登记车牌号码 选择停车区域 node获取当前进入时间<br>
<img src="https://fanfankill.github.io/post-images/1622391426393.png" alt="" loading="lazy"><br>
<img src="https://fanfankill.github.io/post-images/1622391499326.png" alt="" loading="lazy"></li>
<li>当获取停车区域时候，使用watch属性，确保每次切换不同区域能够获取相应区域空闲车位<br>
<img src="https://fanfankill.github.io/post-images/1622391514068.png" alt="" loading="lazy"><br>
<img src="https://fanfankill.github.io/post-images/1622391521639.png" alt="" loading="lazy"></li>
<li>保证每个车辆只能进入时候被登记一次<br>
<img src="https://fanfankill.github.io/post-images/1622391560153.png" alt="" loading="lazy"></li>
<li>进出管理表与车位管理表相连接，每次登记一个，车位管理也会更新车位状态和车牌信息<br>
<img src="https://fanfankill.github.io/post-images/1622391622553.png" alt="" loading="lazy"></li>
<li>每次完成添加后立马更新车位空闲状态，防止多次更新同一个车位</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS事件]]></title>
        <id>https://fanfankill.github.io/post/js-shi-jian/</id>
        <link href="https://fanfankill.github.io/post/js-shi-jian/">
        </link>
        <updated>2021-04-28T07:09:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="事件">事件</h1>
<p>通过<strong>侦听器</strong>来预定事件</p>
<h2 id="事件流">事件流</h2>
<p><strong>事件流</strong>描述的是从页面中接收事件的顺序<br>
事件例图：<br>
<img src="https://fanfankill.github.io/post-images/1619594865905.png" alt="" loading="lazy"></p>
<p>IE 的事件流是事件冒泡流<br>
<img src="https://fanfankill.github.io/post-images/1619594715319.png" alt="" loading="lazy"></p>
<p>Netscape Communicator 的事件流是事件捕获流<br>
<img src="https://fanfankill.github.io/post-images/1619594736001.png" alt="" loading="lazy"><br>
<br></p>
<h2 id="事件冒泡">事件冒泡</h2>
<p>IE 的事件流叫做<strong>事件冒泡</strong>，即事件开始时由最具体的元素（文档中嵌套层次最深 的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。<br>
<br></p>
<h2 id="事件捕捉">事件捕捉</h2>
<p><strong>事件捕获</strong>的思想 是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。<br>
<br></p>
<h2 id="dom事件流">DOM事件流</h2>
<p>DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。<br>
<img src="https://fanfankill.github.io/post-images/1619594960277.png" alt="" loading="lazy"><br>
在 DOM 事件流中，实际的目标（元素）在捕获阶段不会接收到事件。这意味着在捕获阶段， 事件从 document 到再到后就停止了。下一个阶段是“处于目标”阶段，于是事件在上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生， 事件又传播回文档。</p>
<br>
## 事件处理程序
<p>事件就是用户或浏览器自身执行的某种动作。诸如 click、load 和 mouseover，都是事件的名字。 而响应某个事件的函数就叫做事件处理程序（或事件侦听器）</p>
<p>事件处理程序的名字以&quot;on&quot;开头（onclick，onload）<br>
<br></p>
<h2 id="html事件处理程序">HTML事件处理程序</h2>
<p>这个操作是通过指定 onclick 特性并将一些 JavaScript 代码作为它的值来定义的</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert('Clicked')&quot; /&gt; 
</code></pre>
<p>为了避免使用 HTML 实体，这里使用了单 引号。如果想要使用双引号，那么就要将代码改写成如下所示：</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&amp;quot;Clicked&amp;quot;)&quot; /&gt; 
</code></pre>
<p>事件处理程序中的代码在执行时，有权访问全局作用 域中的任何代码</p>
<pre><code class="language-html">&lt;!-- 输出 &quot;click&quot; --&gt; 
&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;&gt; 
</code></pre>
<p>这样指定事件处理程序具有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。这个 函数中有一个局部变量 event</p>
<br>
<p>通过 event 变量，可以直接访问事件对象，你不用自己定义它，也不用从函数的参数列表中读取。 在这个函数内部，this 值等于事件的目标元素</p>
<pre><code class="language-html">&lt;!-- 输出 &quot;Click Me&quot; --&gt; 
&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(this.value)&quot;&gt; 
</code></pre>
<br>
 ##  HTML 中指定事件处理程序的缺点
<p>1.存在一个时差问题。因为用户可能会在 HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件。以前面的例子来说明，假设 showMessage()函数是在按钮下方、页面的最底部定义的。如果用户在页面解 析 showMessage()函数之前就单击了按钮就会引发错误。为此，很多 HTML 事件处理程序都会被封 装在一个 try-catch 块中，以便错误不会浮出水面，如下面的例子所示：</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;try{showMessage();}catch(ex){}&quot;&gt;
</code></pre>
<p>2.这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同 JavaScript 引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。</p>
<p>3.是 HTML 与 JavaScript 代码紧密耦合。如果要更换事 件处理程序，就要改动两个地方：HTML 代码和 JavaScript 代码<br>
<br></p>
<h2 id="dom0-级事件处理程序">DOM0 级事件处理程序</h2>
<p>通过 JavaScript 指定事件处理程序的传统方式</p>
<p>原因一是简单，二是具有跨浏览器的优势</p>
<p>要使用 JavaScript 指定事件处理程序，首先必须取得一 个要操作的对象的引用</p>
<br>
<p>使用 DOM0 级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在 元素的作用域中运行；换句话说，程序中的 this 引用当前元素</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.onclick = function(){ 
alert(this.id); //&quot;myBtn&quot; 
};

btn.onclick = null; //删除事件处理程序
</code></pre>
<p>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理</p>
<p>将事件处理程序设置为 null 之后，再单击按钮将不会有任何动作发生。</p>
<br>
<br>
## DOM2 级事件处理程序
<p>“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：**addEventListener() **和 <strong>removeEventListener()</strong>。</p>
<p>它们都接受 3 个参数：要处 理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获 阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序</p>
<p>在按钮上为 click 事件添加事件处理程序</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.addEventListener(&quot;click&quot;, function(){ 
 alert(this.id); 
}, false); 
</code></pre>
<p>上面的代码为一个按钮添加了 onclick 事件处理程序，而且该事件会在冒泡阶段被触发</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.addEventListener(&quot;click&quot;, function(){ 
 alert(this.id); 
}, false); 
btn.addEventListener(&quot;click&quot;, function(){ 
 alert(&quot;Hello world!&quot;); 
}, false); 

</code></pre>
<p><strong>这里为按钮添加了两个事件处理程序。这两个事件处理程序会按照添加它们的顺序触发，因此首先 会显示元素的 ID，其次会显示&quot;Hello world!&quot;消息</strong></p>
<p>通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除，这也意味着通过 addEventListener()添加的匿 名函数将无法移除。</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.addEventListener(&quot;click&quot;, function(){ 
 alert(this.id)}, false); 
//这里省略了其他代码
btn.removeEventListener(&quot;click&quot;, function(){ //没有用！
 alert(this.id); 
}, false); 

</code></pre>
<p>传入 removeEventListener()中的事件处理程序函数必须与传入 addEventListener()中的<strong>相同</strong> ，因为一一对应，addEvenListener()可以给click或其他添加很多函数，所以removeEvenListener()也要一一去和它对应</p>
<p>大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段（f第三个参数为false），这样可以最大限度地兼容各种浏览器。<br>
<br></p>
<h2 id="事件对象">事件对象</h2>
<p>在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的 信息。</p>
<h2 id="dom中的事件对象">DOM中的事件对象</h2>
<p>兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.onclick = function(event){ 
 alert(event.type); //&quot;click&quot; 
}; 
btn.addEventListener(&quot;click&quot;, function(event){ 
 alert(event.type); //&quot;click&quot; 
}, false);
</code></pre>
<p>要阻止特定事件的默认行为，可以使用 preventDefault()方法</p>
<p>链接的默认行为就是在 被单击时会导航到其 href 特性指定的 URL。如果你想阻止链接导航这一默认行为，那么通过链接的 onclick 事件处理程序可以取消它</p>
<pre><code class="language-js">var link = document.getElementById(&quot;myLink&quot;); 
link.onclick = function(event){ 
 event.preventDefault(); 
};
</code></pre>
<p>stopPropagation()方法用于立即停止事件在 DOM 层次中的传播</p>
<p>从而避免触 发注册在 document.body 上面的事件处理程序</p>
<pre><code class="language-js">var btn = document.getElementById(&quot;myBtn&quot;); 
btn.onclick = function(event){ 
 alert(&quot;Clicked&quot;); 
 event.stopPropagation(); 
}; 
document.body.onclick = function(event){ 
 alert(&quot;Body clicked&quot;); 
}; 
</code></pre>
<h2 id="事件类型">事件类型</h2>
<br>
<h3 id="load事件"><strong>load事件</strong></h3>
<p>当页面完全加载后（包括所有图像、JavaScript 文件、 CSS 文件等外部资源），就会触发 window 上面的 load 事件。</p>
<pre><code class="language-js">&lt;body onload=&quot;alert('Loaded!')&quot;&gt; 
&lt;/body&gt;

//对图像的load事件
&lt;img src=&quot;smile.gif&quot; onload=&quot;alert('Image loaded.')&quot;&gt; 
</code></pre>
<br>
<h3 id="unload-事件"><strong>unload 事件</strong></h3>
<p>利用这个事件最多的情况是清除引用，以避免内存泄漏<br>
<br></p>
<h3 id="resize-事件"><strong>resize 事件</strong></h3>
<p>当浏览器窗口被调整到一个新的高度或宽度时，就会触发 resize 事件</p>
<p>IE、Safari、Chrome 和 Opera 会在浏览 器窗口变化了 1 像素时就触发 resize 事件，然后随着变化不断重复触发。Firefox 则只会在用户停止调 整窗口大小时才会触发 resize 事件</p>
<p>浏览器窗口最小化或最大化时也会触发 resize 事件<br>
<br></p>
<h3 id="scroll-事件"><strong>scroll 事件</strong></h3>
<p>scroll 事件也会在文档被滚动期间重复被触发，所以有必要尽量保持事件 处理程序的代码简单<br>
<br></p>
<h3 id="焦点事件"><strong>焦点事件</strong></h3>
<p>焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与 document.hasFocus()方法及 document.activeElement 属性配合，可以知晓用户在页面上的行踪</p>
<ul>
<li>
<p><strong>blur</strong></p>
<p>在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它</p>
</li>
<li>
<p>DOMFocusIn</p>
<p>在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它冒泡</p>
</li>
<li>
<p>DOMFoucusOut</p>
<p>在元素失去焦点时触发，兼容性不强</p>
</li>
<li>
<p><strong>focus</strong></p>
<p>在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。</p>
</li>
<li>
<p>focusin</p>
<p>这个事件与 HTML 事件 focus 等价，但它冒泡</p>
</li>
<li>
<p>focusout</p>
<p>这个事件是 HTML 事件 blur 的通用版本<br>
<br></p>
</li>
</ul>
<h3 id="鼠标与滚轮事件"><strong>鼠标与滚轮事件</strong></h3>
<ul>
<li>
<p>click</p>
<p>在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。</p>
</li>
<li>
<p>dblclick</p>
<p>在用户双击主鼠标按钮（一般是左边的按钮）时触发。</p>
</li>
<li>
<p>mousedown</p>
<p>在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。</p>
</li>
<li>
<p>mouseenter</p>
<p>在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且 在光标移动到后代元素上不会触发。</p>
</li>
<li>
<p>mouseleave</p>
<p>在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且 在光标移动到后代元素上不会触发。</p>
</li>
<li>
<p>mousemove</p>
<p>当鼠标指针在元素内部移动时重复地触发。</p>
</li>
<li>
<p>mouseout</p>
<p>在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。</p>
</li>
<li>
<p>mouseover<br>
在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触 发。</p>
</li>
<li>
<p>mouseup</p>
<p>在用户释放鼠标按钮时触发。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图解HTTP第五章]]></title>
        <id>https://fanfankill.github.io/post/tu-jie-http-di-liu-zhang/</id>
        <link href="https://fanfankill.github.io/post/tu-jie-http-di-liu-zhang/">
        </link>
        <updated>2021-04-27T00:11:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="与http协助的web服务器">与HTTP协助的Web服务器</h1>
<h2 id="用单台虚拟主机实现多个域名">用单台虚拟主机实现多个域名</h2>
<p>允许一台HTTP服务器搭建多个Web站点。</p>
<p>即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器</p>
<p>在互联网上，域名通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站，所以，当请求发送到服务器时，已经是IP地址形式访问了</p>
<h2 id="通信数据转发程序代理-网关-隧道">通信数据转发程序：代理、网关、隧道</h2>
<ul>
<li>
<p>代理</p>
<p>扮演中间人，接收由客户端发送的请求并转发给服务器，同是，也接收服务器返回的响应并转发给客户端</p>
</li>
<li>
<p>网关</p>
<p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的服务器</p>
</li>
<li>
<p>隧道</p>
<p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序</p>
</li>
</ul>
<h3 id="代理"><strong>代理</strong></h3>
<p>利用代理服务器的理由：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的</p>
<p>代理按两种基准分类：一种是是否使用缓存，另一种是是否会修改报文</p>
<h4 id="缓存代理">缓存代理</h4>
<p>代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上</p>
<p>当代理再次接收对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回</p>
<h4 id="透明代理">透明代理</h4>
<p>转发请求或响应时，不对报文做任何加工的代理类型被称为<strong>透明代理</strong>，反之，称为非透明代理</p>
<hr>
<h2 id="网关">网关</h2>
<p>可以利用网关将HTTP请求转化为其他协议通信</p>
<p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。<br>
<img src="https://fanfankill.github.io/post-images/1619484447634.png" alt="" loading="lazy"></p>
<h2 id="隧道">隧道</h2>
<p>隧道可以按要求建立起一条与其他服务器的通信线路，可以使用SSL等加密手段进行通信。隧道的目的就是保住客户端与服务器能安全进行通信<br>
<img src="https://fanfankill.github.io/post-images/1619484421757.png" alt="" loading="lazy"></p>
<p>隧道本身不会去解析HTTP请求。请求保持原样中转给服务器。隧道会在双方通信断开连接的时候结束</p>
<hr>
<h2 id="保存资源的缓存">保存资源的缓存</h2>
<p>代理服务器会在服务器返回的响应时，保存一份资源副本<br>
<img src="https://fanfankill.github.io/post-images/1619484470802.png" alt="" loading="lazy"></p>
<h3 id="缓存有效期">缓存有效期</h3>
<p>存在资源更新等影响，需要去向源服务器确认</p>
<h3 id="客户端的缓存">客户端的缓存</h3>
<p>缓存也可以存在于客户端浏览器中，这种叫做<strong>临时网络文件</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图解HTTP第四章]]></title>
        <id>https://fanfankill.github.io/post/tu-jie-http-di-si-zhang/</id>
        <link href="https://fanfankill.github.io/post/tu-jie-http-di-si-zhang/">
        </link>
        <updated>2021-04-26T06:02:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="返回结果的http状态">返回结果的HTTP状态</h1>
<h2 id="状态码告知从服务器端返回的请求结果">状态码告知从服务器端返回的请求结果</h2>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1619419502006.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="2-xx成功"><strong>2 XX成功</strong></h2>
<p>响应结果表明请求被正常处理</p>
<ul>
<li>
<h3 id="200-ok">200 OK</h3>
<p>正常处理</p>
</li>
<li>
<h3 id="204-no-content">204 NO Content</h3>
<p>表示请求被成功处理，但在返回的响应报文中不含实体的主体部分。</p>
<p>应用于只需要客户端往服务器发送信息，而对客户端不需要发送新信息的情况下使用</p>
</li>
<li>
<h3 id="206-partial-content">206 Partial Content</h3>
<p>表示客户端进行了范围请求，而服务器成功执行这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容</p>
<hr>
</li>
</ul>
<h2 id="3-xx重定向"><strong>3 XX重定向</strong></h2>
<p>表明浏览器需要执行某些特殊的处理以正确处理请求</p>
<ul>
<li>
<h3 id="301-moved-permanently">301 Moved Permanently</h3>
<p>永久性重定向。表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI</p>
<p>例如当指定路径末尾未加&quot;/&quot;时，会产生301状态码</p>
</li>
<li>
<h3 id="302-found">302 Found</h3>
<p>临时性重定向。表示请求的资源已经被分配了新的URI，希望用户能使用新的URI访问</p>
</li>
<li>
<h3 id="303-see-other">303 See Other</h3>
<p>表示请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源</p>
</li>
<li>
<h3 id="304-not-modified">304 Not Modified</h3>
<p>表示客户端发送附带条件的请求时，服务器允许请求访问资源，但未找到满足条件的情况。</p>
</li>
<li>
<h3 id="307-temporary-redirect">307 Temporary Redirect</h3>
<p>临时冲顶先。与302相似。</p>
</li>
</ul>
<hr>
<h2 id="4-xx客户端错误"><strong>4 XX客户端错误</strong></h2>
<p>表明客户端发生错误的原因所在</p>
<ul>
<li>
<h3 id="400-bad-request">400 Bad Request</h3>
<p>该状态码表示请求报文中存在语法错误。需修改请求的内容后再次发送请求。</p>
</li>
<li>
<h3 id="401-unauthorized">401 Unauthorized</h3>
<p>表示发送的请求需要有通过HTTP认证的认证信息</p>
<p>当浏览器初次接收到401响应，会弹出认证用的对话窗口</p>
</li>
<li>
<h3 id="403-forbidden">403 Forbidden</h3>
<p>表明请求的资源的访问被服务器拒绝了</p>
<p>未获得文件系统的访问授权，访问权限出现某些问题等列举的情况都可能发生403的原因</p>
</li>
<li>
<h3 id="404-not-found">404 Not Found</h3>
<p>表明服务器上无法找到请求的资源。</p>
<hr>
</li>
</ul>
<h2 id="5-xx服务器错误"><strong>5 XX服务器错误</strong></h2>
<p>服务器本身的错误</p>
<ul>
<li>
<h3 id="500-internal-server-error">500 Internal Server Error</h3>
<p>表明服务器在执行请求时发生了错误。也有可能是WEB应用存在的bug或某些临时故障</p>
</li>
<li>
<h3 id="503-service-unavailable">503 Service Unavailable</h3>
<p>表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。</p>
</li>
</ul>
<p>​</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图解HTTP第三章]]></title>
        <id>https://fanfankill.github.io/post/tu-jie-http-di-san-zhang/</id>
        <link href="https://fanfankill.github.io/post/tu-jie-http-di-san-zhang/">
        </link>
        <updated>2021-04-25T06:01:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http报文内的http信息"><strong>HTTP报文内的HTTP信息</strong></h1>
<h2 id="http报文"><strong>HTTP报文</strong></h2>
<p>用于HTTP协议交互的信息被称为HTTP报文。请求端的HTTP报文叫做请求报文，响应端的叫做响应报文</p>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1619330989639.png" alt="" loading="lazy"></figure>
<hr>
<h3 id="请求行"><strong>请求行</strong></h3>
<p>请求行包括请求的方法，URI和HTTP的版本</p>
<hr>
<h3 id="状态行"><strong>状态行</strong></h3>
<p>包含响应结果的状态码，原因短语和HTTP版本</p>
<hr>
<h3 id="首部字段"><strong>首部字段</strong></h3>
<p>包含表示请求和响应的各种条件和属性的各类首部</p>
<hr>
<h1 id="编码提升传输速率"><strong>编码提升传输速率</strong></h1>
<h2 id="报文主体和实体主体的差异"><strong>报文主体和实体主体的差异</strong></h2>
<ul>
<li>
<p>报文</p>
<p><strong>是HTTP通信中的基本单位</strong>，有8个字节流组成，通过HTTP通信传输</p>
</li>
<li>
<p>实体</p>
<p>作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成</p>
</li>
</ul>
<p>HTTP报文的主体用于传输请求或响应的实体主体</p>
<hr>
<h2 id="压缩传输的内容编码"><strong>压缩传输的内容编码</strong></h2>
<figure data-type="image" tabindex="2"><img src="https://fanfankill.github.io/post-images/1619331895496.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="分割发送的分块传输编码">分割发送的分块传输编码</h2>
<p>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面</p>
<p><strong>分块传输编码</strong>会将实体主体分成多个部分。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用&quot;0(CR+LF)&quot;来标记</p>
<p>客户端复制解码，恢复到编码前的实体主体</p>
<hr>
<h1 id="发送多种数据的多部分对象集合">发送多种数据的多部分对象集合</h1>
<p>例如图片，文件的上传</p>
<p>在HTTP报文使用多部分对象集合时，需要在首部字段里加上Content-Type。</p>
<p>boundary字符串来划分多部分对象集合指明的各类实体</p>
<hr>
<h1 id="获取部分内容的范围请求">获取部分内容的范围请求</h1>
<p>指定范围发送的请求叫<strong>范围请求</strong><br>
<img src="https://fanfankill.github.io/post-images/1619332602950.png" alt="" loading="lazy"></p>
<hr>
<h1 id="内容协商返回最合适的内容">内容协商返回最合适的内容</h1>
<p>例网站的中英文版本，以下内容作为为判断标准</p>
<ul>
<li>Accept</li>
<li>Accept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language</li>
</ul>
<p>内容协商三种类型</p>
<h3 id="服务器驱动协商">服务器驱动协商</h3>
<h3 id="客户端驱动协商">客户端驱动协商</h3>
<h3 id="透明协商">透明协商</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图解HTTP 第二章]]></title>
        <id>https://fanfankill.github.io/post/tu-jie-http-di-er-zhang/</id>
        <link href="https://fanfankill.github.io/post/tu-jie-http-di-er-zhang/">
        </link>
        <updated>2021-04-23T02:19:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="http协议用于客户端和服务端之间的通信"><strong>HTTP协议用于客户端和服务端之间的通信</strong></h2>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1619145642116.png" alt="" loading="lazy"></figure>
<hr>
<br>
<figure data-type="image" tabindex="2"><img src="https://fanfankill.github.io/post-images/1619145670666.png" alt="" loading="lazy"></figure>
<hr>
<br>
<h2 id="http是不保存状态协议"><strong>HTTP是不保存状态协议</strong></h2>
<p>HTTP是不保存状态的协议，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。这样是为了更快的处理大量事务，确保协议的 可伸缩性</p>
<p>为了保证页面跳转时的状态保存，Cooike就被引入</p>
<br>
<p>## <em><strong>*请求URI定位资源*</strong></em></p>
<figure data-type="image" tabindex="3"><img src="https://fanfankill.github.io/post-images/1619145690268.png" alt="" loading="lazy"></figure>
<hr>
<br>
<h2 id="告知服务器意图的http方法"><strong>告知服务器意图的HTTP方法</strong></h2>
<p><strong>GET</strong>：获取资源</p>
<p>GET方法用来请求访问已被URI 识别的资源</p>
<figure data-type="image" tabindex="4"><img src="https://fanfankill.github.io/post-images/1619147700579.png" alt="" loading="lazy"></figure>
<hr>
<p><strong>POST</strong>：传输实体主体</p>
<p>POST传输更常用<br>
<img src="https://fanfankill.github.io/post-images/1619147796053.png" alt="" loading="lazy"></p>
<hr>
<p><strong>PUT</strong>：传输文件</p>
<p>PUT方法自身不带验证机制，在一般情况下不用<br>
<img src="https://fanfankill.github.io/post-images/1619147670212.png" alt="" loading="lazy"></p>
<hr>
<p><strong>HEAD</strong>：获得报文头部</p>
<p>HEAD方法和GET方法一样，只是不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等<br>
<img src="https://fanfankill.github.io/post-images/1619147639933.png" alt="" loading="lazy"></p>
<hr>
<p><strong>DELETE</strong>：删除文件</p>
<p>与PUT方法相反的方法，也是不带验证机制的方法<br>
<img src="https://fanfankill.github.io/post-images/1619147846458.png" alt="" loading="lazy"></p>
<hr>
<p><strong>OPTIONS</strong>：询问支持的方法</p>
<p>OPTIONS方法用来查询针对URI指定的资源支持的方法</p>
<hr>
<p><strong>TRACE</strong>：追踪路径<br>
TRACE方法是让WEB服务器端将之前的请求通信返回给客户端的方法<br>
客户端用于查询发送出去的请求怎样被加工的，但不常用</p>
<hr>
<h2 id="持久连接"><strong>持久连接</strong></h2>
<p>因为每进行一次HTTP通信就要断开一次TCP连接，对于网页的请求就要很多次的连接和断开操作，浪费通信量。</p>
<p>所以HTTP keep-alive的方法出现，只要任意一端没有明确提出断开连接，则保持TCP连接状态</p>
<hr>
<h2 id="使用cookie的状态管理"><strong>使用Cookie的状态管理</strong></h2>
<p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态</p>
<p>Cookie会根据从服务端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值发送出去</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图解HTTP 第一章]]></title>
        <id>https://fanfankill.github.io/post/tu-jie-http/</id>
        <link href="https://fanfankill.github.io/post/tu-jie-http/">
        </link>
        <updated>2021-04-22T03:03:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="http超文本传输协议">HTTP（超文本传输协议）</h2>
<br>
<h2 id="tcpip-分层">TCP/IP 分层</h2>
<ol>
<li>
<p><strong>应用层</strong></p>
<pre><code>  	     1. 决定向用户提供应用服务时通信的活动 (HTTP，FTP，DNS)  
</code></pre>
</li>
<li>
<p><strong>传输层</strong></p>
<pre><code>  	     1. 提供处于网络连接中两台计算机之间的数据传输
</code></pre>
</li>
<li>
<p><strong>网络层</strong></p>
<pre><code>  	     1. 处理网络上流动的数据包，为数据传输选择一条路线
</code></pre>
</li>
<li>
<p><strong>数据链路层</strong></p>
<pre><code>  	     1. 一些肉眼可见的硬件设施 网卡 光纤 等
</code></pre>
<br>
</li>
</ol>
<h2 id="tcpip通信传输流">TCP/IP通信传输流</h2>
<table>
<thead>
<tr>
<th>客户端</th>
<th style="text-align:center">过程</th>
<th style="text-align:right">服务器</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td style="text-align:center">HTTP数据</td>
<td style="text-align:right">应用层</td>
</tr>
<tr>
<td>传输层</td>
<td style="text-align:center">加/消去 TCP首部</td>
<td style="text-align:right">传输层</td>
</tr>
<tr>
<td>网络层</td>
<td style="text-align:center">加/消去 IP首部</td>
<td style="text-align:right">网络层</td>
</tr>
<tr>
<td>链路层</td>
<td style="text-align:center">加/消去 以太网首部</td>
<td style="text-align:right">链路层</td>
</tr>
</tbody>
</table>
<h1 id="与http关系紧密的协议"><strong>与HTTP关系紧密的协议</strong></h1>
<br>
<h3 id="负责传输的ip协议"><strong>负责传输的IP协议</strong></h3>
<p>IP(网际协议)处于网络层，IP协议的作用是把各种数据包传送给对方，而确保传送到对方那里，要满足各种条件。其中两个重要的条件就是<strong>IP地址</strong>和<strong>MAC地址</strong></p>
<p><strong>IP地址</strong>指明了节点被分配到的地址，<strong>Mac地址</strong>是指网卡所属的固定地址，IP地址可以和MAC地址进行匹配。IP地址可以变换，MAC地址基本不会更改</p>
<br>
<h3 id="arp协议"><strong>ARP协议</strong></h3>
<p>IP间的通信依赖MAC地址。在网络上，通信的双方在同一局域网（LAN）内的情况还是很少的，通常需要多台计算机和网络设备中转。而在进行中转时，<strong>会利用下一站中转设备的MAC地址来搜索下一个中转目标</strong>。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址<br>
<br></p>
<h3 id="tcp协议"><strong>TCP协议</strong></h3>
<p>TCP协议位于传输层，提供可靠的字节流服务。</p>
<p><strong>字节流服务</strong>指为了方便传输将大块数据分割成以报文段为单位的数据包进行管理</p>
<p><strong>可靠的服务</strong>指TCP协议能够确认数据最终是否送到对方</p>
<br>
<h4 id="确保数据能达到目标"><strong>确保数据能达到目标</strong></h4>
<p>TCP协议采用<strong>三次握手</strong>策略。用TCP协议把数据包送出去后，TCP一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN和——ACK。</p>
<p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后发送端再回传一个带ACK标志的数据包，代表“握手”结束</p>
<p>若在握手的过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包<br>
<br></p>
<h2 id="负责域名解析的dns服务"><strong>负责域名解析的DNS服务</strong></h2>
<p>DNS服务位于应用层的协议。它提供域名到IP地址之间的解析服务</p>
<p>DNS协议提供通过<strong>域名</strong>(例如 www.baidu.com)查找<strong>IP</strong>(14.215.177.39)，或逆向从IP反查域名的服务(cmd的nslookup 指令)</p>
<br>
<h2 id="各种协议与http协议的关系">各种协议与HTTP协议的关系</h2>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1619064689862.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正则表达式]]></title>
        <id>https://fanfankill.github.io/post/zheng-ze-biao-da-shi/</id>
        <link href="https://fanfankill.github.io/post/zheng-ze-biao-da-shi/">
        </link>
        <updated>2021-04-09T00:29:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="语法">语法</h1>
<p>runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。</p>
<p>runoo<em>b，可以匹配 runob、runoob、runoooooob 等，</em> 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</p>
<p>colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VUE 前置导航守卫]]></title>
        <id>https://fanfankill.github.io/post/vue-qian-zhi-dao-hang-shou-wei/</id>
        <link href="https://fanfankill.github.io/post/vue-qian-zhi-dao-hang-shou-wei/">
        </link>
        <updated>2021-04-07T11:48:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="路由守卫">路由守卫</h1>
<h2 id="当token不存在时-跳转到登陆界面">当token不存在时 跳转到登陆界面</h2>
<p><strong>只有登录界面时 (不考虑注册等其他界面)</strong></p>
<pre><code class="language-router.beforeEach((to,from,next)=&gt;{">  let token=localStorage.getItem(&quot;token&quot;);
  if(token){//判断是否登录
    next()
  }

  else{
    if(to.path!=='/login'){
      alert(&quot;请先登录&quot;)
      next({path:'/login'})
    }
    else{
      next()
    }
  }
});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛客]]></title>
        <id>https://fanfankill.github.io/post/niu-ke-cuo-ti/</id>
        <link href="https://fanfankill.github.io/post/niu-ke-cuo-ti/">
        </link>
        <updated>2021-04-06T01:50:43.000Z</updated>
        <content type="html"><![CDATA[<br>
<h1 id="3true">3==true</h1>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1617673888601.PNG" alt="" loading="lazy"></figure>
<br>
<br>
<br>
<h1 id="2tostring">2.toString()</h1>
<p><img src="https://fanfankill.github.io/post-images/1617673913588.PNG" alt="" loading="lazy"><br>
<br><br>
<br></p>
<h1 id="3-数组查重返回有重复的值">3 数组查重(返回有重复的值)</h1>
<pre><code>function(arr)
{
    let res=[];
    arr.forEach(function(val){
        //保证是重复项且新数组中没有存这项
        if(arr.indexOf(val)!=arr.lastIndexOf(val)&amp;&amp;res.indexOf(val)==-1)
        {
            res.push(val)
        }
    } )
    return res
}
</code></pre>
]]></content>
    </entry>
</feed>