<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fanfankill.github.io</id>
    <title>fanfan</title>
    <updated>2021-07-11T11:28:00.793Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fanfankill.github.io"/>
    <link rel="self" href="https://fanfankill.github.io/atom.xml"/>
    <subtitle>&lt;strong&gt;前端小白&lt;/strong&gt;</subtitle>
    <logo>https://fanfankill.github.io/images/avatar.png</logo>
    <icon>https://fanfankill.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, fanfan</rights>
    <entry>
        <title type="html"><![CDATA[VUE文档]]></title>
        <id>https://fanfankill.github.io/post/vue-wen-dang/</id>
        <link href="https://fanfankill.github.io/post/vue-wen-dang/">
        </link>
        <updated>2021-07-11T11:20:09.000Z</updated>
        <content type="html"><![CDATA[<p>v-html :将模板字符串解析为html格式</p>
<p>split() 组成字符串数组</p>
<p>模板表达式都被放在沙盒中，只能访问<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9">全局变量的一个白名单</a>，如 <code>Math</code> 和 <code>Date</code> 。你不应该在模板表达式中试图访问用户定义的全局变量。</p>
<br>
<p>你可以使用动态参数为一个动态的事件名绑定处理函数：</p>
<pre><code class="language-js">&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;
</code></pre>
<p>当 <code>eventName</code> 的值为 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>。</p>
<h3 id="v-bind"><a href="https://cn.vuejs.org/v2/guide/syntax.html#v-bind-%E7%BC%A9%E5%86%99"><code>v-bind</code> 缩写</a></h3>
<pre><code class="language-js">&lt;!-- 完整语法 --&gt;
&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;

&lt;!-- 缩写 --&gt;
&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;

&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;
&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a&gt;
</code></pre>
<h3 id="v-on"><a href="https://cn.vuejs.org/v2/guide/syntax.html#v-on-%E7%BC%A9%E5%86%99"><code>v-on</code> 缩写</a></h3>
<pre><code class="language-js">&lt;!-- 完整语法 --&gt;
&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;

&lt;!-- 缩写 --&gt;
&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;

&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;
&lt;a @[event]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;
</code></pre>
<h2 id="计算属性和侦听器">计算属性和侦听器</h2>
<pre><code class="language-HTML">&lt;div id=&quot;example&quot;&gt;
  &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;
  &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-JS">var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
</code></pre>
<h3 id="计算属性缓存-vs-方法">计算属性缓存 vs 方法</h3>
<pre><code class="language-JS">&lt;p&gt;Reversed message: &quot;{{ reversedMessage() }}&quot;&lt;/p&gt;

// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
</code></pre>
<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。</p>
<p>这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
<p>所以计算属性要是响应试依赖</p>
<p>这也同样意味着下面的计算属性将不再更新，因为 <code>Date.now()</code> 不是响应式依赖：</p>
<pre><code class="language-js">computed: {
  now: function () {
    return Date.now()
  }
}
</code></pre>
<h2 id="计算属性-vs-侦听属性">计算属性 vs 侦听属性</h2>
<p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p>
<pre><code class="language-js">// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
</code></pre>
<p><strong>计算属性computed :</strong></p>
<ol>
<li>
<p>支持缓存，只有依赖数据发生改变，才会重新进行计算</p>
</li>
<li>
<p>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p>
</li>
</ol>
<p>​            3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行               缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p>
<ol start="4">
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li>
</ol>
<p>​           5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p>
<br>
<p><strong>侦听属性watch：</strong></p>
<ol>
<li>不支持缓存，数据变，直接会触发相应的操作；</li>
<li>watch支持异步；</li>
<li>当一个属性发生变化时，需要执行对应的操作；一对多；</li>
<li>监听数据必须是data中声明过或者父组件传递过来的props中的数据.函数有两个参数，
<ol>
<li>immediate：组件加载立即触发回调函数执行</li>
<li>deep: 深度监听，为了发现<strong>对象内部值</strong>的变化，复杂类型的数据时使用。deep无法监听到数组的变动和对象的新增</li>
</ol>
</li>
</ol>
<h2 id="条件渲染">条件渲染</h2>
<p>当 <code>v-if</code> 需要包裹多个元素时候 用 <code>&lt;template&gt;</code></p>
<p><code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</p>
<p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级</p>
<h2 id="事件处理方法">事件处理方法</h2>
<p>内联处理器中的方法</p>
<pre><code class="language-js">&lt;div id=&quot;example-3&quot;&gt; 
    &lt;button v-on:click=&quot;say('hi',$event)&quot;&gt;Say hi&lt;/button&gt;  
	&lt;button v-on:click=&quot;say('what')&quot;&gt;Say what&lt;/button&gt; &lt;/div&gt;

new Vue({
  el: '#example-3',
  methods: {
    say: function (message,event) {
      alert(message)
        // 现在我们可以访问原生事件对象
        if (event) {
          event.preventDefault()
        }
    }
  }
})
//有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：
</code></pre>
<h2 id="事情修饰符">事情修饰符</h2>
<p>原文博客(https://www.cnblogs.com/xiaoyaoxingchen/p/10405207.html)</p>
<ul>
<li>
<p><code>.stop</code>  阻止冒泡（通俗讲就是阻止事件向上级DOM元素传递）<br>
<img src="https://fanfankill.github.io/post-images/1626002759503.png" alt="" loading="lazy"></p>
</li>
<li>
<p><code>.prevent</code>  阻止默认事件的发生 例如a标签的跳转和表单的提交刷新</p>
</li>
<li></li>
<li>
<p><code>.capture</code> 捕获冒泡 即有冒泡发生时，有该修饰符的dom元素会先执行</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1626002752776.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><code>.self</code>  事件有自身才能触发，通常用于避免冒泡事件的影响<br>
<img src="https://fanfankill.github.io/post-images/1626002764276.png" alt="" loading="lazy"></p>
</li>
<li>
<p><code>.once</code>    只触发一次</p>
</li>
<li>
<p><code>.passive</code>   对DOM的默认事件进行性能优化</p>
</li>
<li>
<p><code>. native</code> 一般给组件绑定事件加的</p>
</li>
</ul>
<pre><code class="language-html">&lt;!-- 阻止单击事件继续传播 --&gt;
&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 修饰符可以串联 --&gt;
&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

&lt;!-- 只有修饰符 --&gt;
&lt;form v-on:submit.prevent&gt;&lt;/form&gt;

&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;
&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;
&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;
&lt;!-- 即事件不是从内部元素触发的 --&gt;
&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;
</code></pre>
<br>
<h2 id="按键修饰符">按键修饰符</h2>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“删除”和“退格”键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<pre><code class="language-js">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;
    &lt;input v-on:keyup.enter=&quot;submit&quot;&gt;
</code></pre>
<h2 id="系统修饰键">系统修饰键</h2>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<h2 id="exact"><code>.exact</code></h2>
<p>修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
<pre><code class="language-html">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;
&lt;button v-on:click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;
&lt;button v-on:click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;
&lt;button v-on:click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 媒体查询]]></title>
        <id>https://fanfankill.github.io/post/mei-ti-cha-xun/</id>
        <link href="https://fanfankill.github.io/post/mei-ti-cha-xun/">
        </link>
        <updated>2021-07-10T16:20:07.000Z</updated>
        <content type="html"><![CDATA[<p>媒体属性是CSS3新增的内容</p>
<p>媒体属性必须用括号()包起来</p>
<h5 id="media-媒体类型and-媒体特性你的样式">@media 媒体类型and （媒体特性）{你的样式}</h5>
<h2 id="最大宽度max-width">最大宽度max-width</h2>
<h5 id="意思是指媒体类型小于或等于指定的宽度时样式生效-如">意思是指媒体类型小于或等于指定的宽度时，样式生效。如：</h5>
<pre><code class="language-css">@media screen and (max-width:480px){
 body {
   display:none;
  }
}
</code></pre>
<h2 id="最小宽度min-width">最小宽度min-width</h2>
<pre><code class="language-css">@media screen and (min-width:600px) and (max-width:900px){
  body {background-color:#f5f5f5;}
}
</code></pre>
<h2 id="多个媒体特性使用"><strong>多个媒体特性使用</strong></h2>
<h5 id="media-query中可以包含0到多个表达式">Media Query中可以包含0到多个表达式</h5>
<pre><code class="language-css">/**当屏幕在600px~900px之间时，body的背景色渲染为“#f5f5f5”*/
@media screen and (min-width:600px) and (max-width:900px){
  body {background-color:#f5f5f5;}
}
</code></pre>
<h2 id="设备屏幕的输出宽度device-width"><strong>设备屏幕的输出宽度Device Width</strong></h2>
<h5 id="以根据屏幕设备的尺寸来设置相应的样式或者调用相应的样式文件">以根据屏幕设备的尺寸来设置相应的样式（或者调用相应的样式文件）</h5>
<pre><code class="language-xml">&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (max-device-width:480px)&quot; href=&quot;iphone.css&quot; /&gt;
</code></pre>
<h2 id="not关键词">not关键词</h2>
<h5 id="使用关键词not是用来排除某种制定的媒体类型">使用关键词“not”是用来排除某种制定的媒体类型</h5>
<pre><code class="language-css">@media not print and (max-width: 1200px){样式代码}
</code></pre>
<h2 id="only关键词">only关键词</h2>
<h5 id="only用来指定某种特定的媒体类型">only用来指定某种特定的媒体类型</h5>
<pre><code class="language-xml">&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (max-device-width:240px)&quot; href=&quot;android240.css&quot; /&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS度量单位 rem、em、vw、vh]]></title>
        <id>https://fanfankill.github.io/post/css-du-liang-dan-wei-rememvwvh/</id>
        <link href="https://fanfankill.github.io/post/css-du-liang-dan-wei-rememvwvh/">
        </link>
        <updated>2021-07-10T13:42:52.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1625924625206.png" alt="" loading="lazy"></figure>
<h2 id="em"><strong>em</strong></h2>
<p>继承父元素大小关系，2em 则为父元素大小的两倍  受自己上级节点影响</p>
<pre><code class="language-html">&lt;div class=&quot;div&quot; style=&quot;font-size:20px;&quot;&gt;div 标签中的文字大小为 20px
&lt;p class=&quot;p&quot; style=&quot;font-size:2em&quot;&gt;P 标签中的文字大小为 2em
&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>效果如下<br>
<br></p>
<style>
.div{font-size:20px;}
.p{font-size:2em;}
.span{font-size:0.5em;}
</style>
<div class="div" style="font-size:20px;">div 标签中的文字大小为 20px
<p class="p" style="font-size:2em">P 标签中的文字大小为 2em
    <span class="span" style="font-size:.5em">span标签中的文字大小为0.5em</span>
</p>
</div>
<br>
<h2 id="rem"><strong>rem</strong></h2>
<p>就是相对于根节点来进行缩放，如果有嵌套的关<br>
系，嵌套关系的元素的字体大小始终按照根节点的字体大小进行缩放</p>
<pre><code class="language-html">&lt;style&gt;
html{font-size:16px;}
.div{font-size:30px;background-color:pink;padding:50px;}
.p{font-size:1rem;}
.span{font-size:0.5rem;}
&lt;/style&gt;

&lt;div class=&quot;div&quot;&gt;div 标签中的文字大小为 30px
&lt;p class=&quot;p&quot;&gt;P 标签中的文字大小为 1rem
&lt;span class=&quot;span&quot;&gt;span 标 签 中 的 文 字 大 小 为
0.5rem&lt;/span&gt;
&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<div class="div" style="font-size:30px">div 标签中的文字大小为 30px
<p class="p" style="font-size:1rem;">P 标签中的文字大小为 1rem
<span class="span" style="font-size:.5rem">span 标 签 中 的 文 字 大 小 为
0.5rem</span>
</p>
</div>
<p><strong>这个rem继承的是html的font-size  默认为16px 这才是根节点</strong></p>
<br>
<br>
<h2 id="vw-和-vh"><strong>vw 和 vh</strong></h2>
<p>视窗的宽度和高度，相当于屏幕宽度和高度的 1%</p>
<p>处理宽度的时候%单位更合适，处理高度的话 vh 单位更好<br>
<br></p>
<h2 id="vmin-和-vmax"><strong>vmin 和 vmax</strong></h2>
<p>关于视口高度和宽度两者的最小值或者最大值。</p>
<p>如果你要让这个元素始终铺满整个视口的可见区域：</p>
<pre><code class="language-css">.box { 
height: 100vmax; 
width: 100vmax;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图片懒加载]]></title>
        <id>https://fanfankill.github.io/post/tu-pian-lan-jia-zai/</id>
        <link href="https://fanfankill.github.io/post/tu-pian-lan-jia-zai/">
        </link>
        <updated>2021-07-03T14:47:46.000Z</updated>
        <content type="html"><![CDATA[<p>实现图片懒加载先了解几个属性</p>
<ul>
<li>offsetWidth/offsetHeight</li>
</ul>
<p>对象的可见宽度</p>
<ul>
<li>clientWidth/clientHeight</li>
</ul>
<p>内容的可见宽度</p>
<ul>
<li>scrollWidth/scrollHeight</li>
</ul>
<p>元素完整的高度和宽度，overflow:hidden的部分也计算在内。</p>
<ul>
<li>offsetLeft/offsetTop</li>
</ul>
<p>当前元素距浏览器边界的偏移量，以像素为单位。</p>
<ul>
<li>clientTop/clientLeft</li>
</ul>
<p>这个属性测试下来的结果就是border。</p>
<ul>
<li>scrollLeft/scrollTop</li>
</ul>
<p>设置或返回已经滚动到元素的左边界或上边界的像素数。</p>
<h2 id="实现代码">实现代码</h2>
<pre><code class="language-js"> //显示器高度 window.innerHeight
    //图片到视窗上的距离 getBoundingClientRect().top
    let imgs=document.querySelectorAll('img')
    console.log(imgs);

    window.addEventListener('scroll',(e)=&gt;{
        imgs.forEach(v=&gt;{
            const imgtop=v.getBoundingClientRect().top
            console.log(imgtop);
            if(imgtop&lt;window.innerHeight)
            {
              
                let data_src=v.getAttribute('data-src')
                 v.setAttribute('src',data_src)
            }
            console.log('触发');
        })
    })

</code></pre>
<p>HTML</p>
<pre><code class="language-html">&lt;img  data-src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb1-q.mafengwo.net%2Fs7%2FM00%2F2E%2F37%2FwKgB6lSuHraAYMNtAAXF8ovILuk683.png&amp;refer=http%3A%2F%2Fb1-q.mafengwo.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1627892666&amp;t=953e6a19584b6772c33a1b84604fa63d&quot;&gt;
</code></pre>
<p><strong>感觉上面这样触发太频繁 加个节流吧</strong></p>
<pre><code class="language-JS">//节流写法
    window.onscroll = throttle(getscroll,200)
    



    //主体函数
    function getscroll() {
  
        let imgs = document.querySelectorAll('img')

        imgs.forEach(v=&gt;{
            const imgtop=v.getBoundingClientRect().top
            console.log(imgtop);
            if(imgtop&lt;window.innerHeight)
            {

                let data_src=v.getAttribute('data-src')
                 v.setAttribute('src',data_src)
            }
          
        })
    }

    //节流函数 过一段时间才触发
    function throttle(fn, delay) {
        let timer = true
        return function () {
            if (!timer) {
                return false
            }
  
            timer=false
            setTimeout(() =&gt; {
            fn()
            console.log('我是节流');
            timer = true;
        }, delay)

        }
    }

</code></pre>
<p><img src="https://fanfankill.github.io/post-images/1625323851326.png" alt="" loading="lazy"><br>
<img src="https://fanfankill.github.io/post-images/1625323855197.png" alt="" loading="lazy"></p>
<p>不节流效果</p>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1625323862788.png" alt="" loading="lazy"></figure>
<p>节流后的效果  200ms间隔</p>
<figure data-type="image" tabindex="2"><img src="https://fanfankill.github.io/post-images/1625323858842.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手写ajax]]></title>
        <id>https://fanfankill.github.io/post/shou-xie-axios/</id>
        <link href="https://fanfankill.github.io/post/shou-xie-axios/">
        </link>
        <updated>2021-06-26T13:00:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="axios">axios</h2>
<p>客户端  请求  服务端</p>
<ul>
<li>
<p>请求行</p>
<p>url</p>
<p>请求方式</p>
</li>
<li>
<p>多个请求头</p>
<p>域名，cooike，content-Type等</p>
</li>
<li>
<p>请求体</p>
</li>
</ul>
<p>post方法传的参数</p>
<p>服务端  响应  客户端</p>
<ul>
<li>
<p>响应行</p>
<p>status statusText</p>
</li>
<li>
<p>多个响应头</p>
<p>Content-Type:text/html</p>
</li>
<li>
<p>响应体</p>
<p>数据返回</p>
</li>
</ul>
<h2 id="xhr">XHR</h2>
<p>XMLHttpRequest对象可以和服务器交互 不会刷新网页</p>
<p>只有XHR和fetch发出的才是ajax请求</p>
<p>一般的请求就类似跳转和刷新页面</p>
<p>ajax只是调用监视回调函数并传入响应相关的数据</p>
<h2 id="api">API</h2>
<p>XMLHttpRequest() //创建XHR对象的构造函数</p>
<p>status：响应状态码</p>
<p>statusText：响应状态文本</p>
<p>onreadystatechange：绑定readyState改变的监听</p>
<p>open(method,url)：初始化请求</p>
<p>send(data)：发送请求</p>
<p>abort()：中断请求</p>
<br>
<br>
<h2 id="手写实现ajax">手写实现ajax</h2>
<pre><code class="language-js">&lt;script&gt;
    
    //接口在本地node.js实现
      function getdata()
    {
        console.log('发送get请求');
        ajax({
            url:'http://localhost:3000/getposition',
            parmas:{
               
            name:'fanfan',
            age:19,
            number:13142278876
            }
        }).then(res=&gt;{
            console.log(res);
        })
    }

    
    //ajax手写实现
     
    function ajax({
        //解构赋值  写好默认值
        url,
        method='GET',
        data={},
        parmas={},
    }){
        //返回promise对象
         return new Promise( (resolve,reject)=&gt;{
       
         //对url的处理  有些get请求参数需要拼接另外函数实现拼接
            url+='?'+pinjie(parmas)
    
             //创建xhr对象
             const request=new XMLHttpRequest()
            //打开连接
             request.open(method,url,true) 
            //转换为JSON对象 
            if(method=='GET')
            {
                request.send()
            }
           else if(method=='post')
           {
          
           //发送JSON格式的对象肯定要加请求头 告诉服务器请求体是JSON格式
            request.setRequestHeader('Content-Type','application/json;charset=uft-8')
            //转换为JSON发送
            request.send(JSON.stringify(data))
           }
    
           //绑定状态改变的监听 从发送变为成功或者失败调用的函数
           request.onreadystatechange=function(){
                //进入判断 如果请求没有完成 直接结束
                if(request.readyState!==4)
                {
                    return 
                }
                //如果响应状态码在 200~299为成功
                const {status,statusText} =request
                //自己加的属性
                let author='fanfan'
                
                if(status&gt;=200&amp;&amp;status&lt;=299)
                {
                    //准备结果对象response 的其中几条
                    const response={
                        //对应返回的数据可以知道这些东西是什么
                        data:JSON.parse(request.response),
                        status,
                        statusText,
                        //自己添加的属性
                        author
                      
                    }
                    resolve(response)
                }else{
                    //请求失败返回message信息和状态码
                    reject(new Error('requset error status is '+status))
                }
           }
              
         })
    }

    //拼接参数 for-in解决
    function pinjie(obj)
    {
        let  queryString=''
        for(let k in obj)
        {
            queryString+= k+'='+obj[k]+'&amp;'
        }
        //判断有没有值
        if(queryString)
        {
            queryString=queryString.slice(0,queryString.length-1)
        }
        //拼接到url上面
       return  queryString
    }
    
    
&lt;/script&gt;


</code></pre>
<br>
<br>
<h2 id="实现结果">实现结果</h2>
<figure data-type="image" tabindex="1"><img src="https://fanfankill.github.io/post-images/1624712565528.png" alt="" loading="lazy"></figure>
<h2 id="axios特点">axios特点</h2>
<ul>
<li>
<p>基本promise的异步ajax请求库</p>
</li>
<li>
<p>浏览器和node都可以使用</p>
</li>
<li>
<p>支持请求/响应数据转换</p>
</li>
<li>
<p>支持请求取消</p>
</li>
</ul>
<h2 id="多个请求响应拦截器-洋葱模型">多个请求/响应拦截器  （洋葱模型）</h2>
<p>请求拦截器 先添加后执行  响应拦截器 先添加先执行</p>
<pre><code class="language-js"> //添加请求拦截器
    axios.interceptors.request.use(
        config=&gt;{
            console.log('request interceptor1');
            return config
        },
        error=&gt;{
            return Promise.reject(error)
        }
    )

     //添加请求拦截器
     axios.interceptors.request.use(
        config=&gt;{
            console.log('request interceptor2');
            return config
        },
        error=&gt;{
            return Promise.reject(error)
        }
    )
    //添加响应拦截器
    axios.interceptors.response.use(
        response=&gt;{
            console.log('response interceptor1');
            return response
        },error=&gt;{
            return Promise.reject(error)
        }
    )
      //添加响应拦截器
      axios.interceptors.response.use(
        response=&gt;{
            console.log('response interceptor2');
            return response
        },error=&gt;{
            return Promise.reject(error)
        }
    )


 //config 就是传的配置文件 不返回的话就传不过去

//response return的结果会给下一个响应拦截器 最后执行.then(res) 将数据传给res


/*request interceptor2
request interceptor1
response interceptor1
response interceptor2*/

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mustache]]></title>
        <id>https://fanfankill.github.io/post/mustache/</id>
        <link href="https://fanfankill.github.io/post/mustache/">
        </link>
        <updated>2021-06-26T05:50:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vue源码学习">vue源码学习</h1>
<h2 id="什么是模板引擎">什么是模板引擎</h2>
<p><strong>将数据要变为试图最优雅的解决方案</strong></p>
<p>历史上出现过数据变为视图的方法</p>
<ul>
<li>
<p>纯DOM</p>
</li>
<li>
<p>数组join法</p>
</li>
<li>
<p>ES6的反引号法</p>
<p>新增的 <code>${a}</code>的语法糖</p>
</li>
<li>
<p>模板引擎</p>
</li>
</ul>
<p><strong>数组join法</strong></p>
<pre><code class="language-js">//换行一样
var message='fanfan'
var str=[
    '&lt;li&gt;',
    '&lt;div&gt;'+message+'&lt;/div&gt;',
    '&lt;/li&gt;'
].join()
</code></pre>
<p>ES6的语法糖</p>
<pre><code class="language-js">let a='fanfan'
list.innerHTTML+=`
	&lt;li&gt;
		&lt;div class=&quot;fanfan&quot;&gt;
				${a}的信息
		&lt;/div&gt;
	&lt;/li&gt;
`
</code></pre>
<h2 id="mustache库">mustache库</h2>
<p>{{ }} 像胡子  所以取名叫胡子</p>
<pre><code class="language-js">  var user = { name: &quot;Olive&quot;, age: 23, sex: &quot;girl&quot; };
        var template = &quot;My name is  {{name}} ,I'm  {{age}} ,Sex is {{sex}}&quot;;
        var view = Mustache.render(template, user)

   console.log(view);
</code></pre>
<p><strong>简单模式下正则表达式可以实现</strong></p>
<pre><code class="language-js"> var template = &quot;My name is  {{name}} ,I'm  {{age}} ,Sex is {{sex}}&quot;;
    
            console.log(template.replace(/\{\{(\w+)\}\}/g,function(a,b,c){
                console.log(a,b,c);
                return '❤'
            }));

/**
	b 找出了里面的内容 可以用来替换
	{{name}} name 12
	{{age}} age 27
	{{sex}} sex 43
 	My name is  ❤ ,I'm  ❤ ,Sex is ❤*/
</code></pre>
<pre><code class="language-js"> 
//进行函数封装
function likerender(template,data)
            {
                return template.replace(/\{\{(\w+)\}\}/g,function(findstr,$1){
                //匹配data对象里面的属性
                return data[$1]
                     });
            }

            var data={
                name:'fanfan',
                age:18,
                sex:'man'
            }

            console.log(likerender(template,data));
		
//My name is  fanfan ,I'm  18 ,Sex is man
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 微信小程序开发记录]]></title>
        <id>https://fanfankill.github.io/post/xiao-cheng-xu-kai-fa-ji-lu/</id>
        <link href="https://fanfankill.github.io/post/xiao-cheng-xu-kai-fa-ji-lu/">
        </link>
        <updated>2021-06-20T07:51:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="es6-map函数-选择作用">ES6 map()函数 (选择作用)</h2>
<pre><code>var users = [
{name: &quot;张含韵&quot;, &quot;email&quot;: &quot;zhang@email.com&quot;},
{name: &quot;江一燕&quot;, &quot;email&quot;: &quot;jiang@email.com&quot;},
{name: &quot;李小璐&quot;, &quot;email&quot;: &quot;li@email.com&quot;}
];

var emails = users.map(function (user) { return user.email; });

console.log(emails.join(&quot;, &quot;)); 

// zhang@email.com, jiang@email.com, li@email.com
</code></pre>
<p>此方法用于我对于获取总数据中选择data里面的数组去选择我需要的部分<br>
<br></p>
<h2 id="小程序本地储存">小程序本地储存</h2>
<p>wx.setStorageSync('key','value);</p>
<p>wx.getStorageSync( 'key');</p>
<p>web中存数据会先调用toString() 把数据变为字符串 再进行储存</p>
<p>小程序存的数据什么类型 获取的就是什么类型</p>
<br>
<h2 id="onloadoption">onload(option)</h2>
<p>{</p>
<p>​	//option里面包含我从其他页面跳转url带参的参数</p>
<p>}<br>
<br></p>
<h2 id="组件的子传父-父传子">组件的子传父 父传子</h2>
<pre><code class="language-html">&lt;!-- 监听自定义事件 bindtabsitemchange是子组件向父组件传值加bind --&gt;
&lt;tab tabs=&quot;{{tabs}}&quot; bindtabsitemchange=&quot;handitemchange&quot;&gt;&lt;/tab&gt;
</code></pre>
<p>子组件接受参数</p>
<pre><code class="language-js"> properties: {
    tabs:{
      type:Array,
      value:[]
    }
  },
</code></pre>
<p>子组件向父组件传值</p>
<pre><code class="language-js">  methods: {
      //点击事件
      handleitemtap(e)
      {
        const {index}=e.currentTarget.dataset
        this.triggerEvent(&quot;tabsitemchange&quot;,{index} )
      }
  }
</code></pre>
<p>父组件对传值的处理</p>
<pre><code class="language-js">//tab子组件点击事件
handitemchange(e)
{
  console.log(e);
  //获取被点击的标题索引
  const {index}=e.detail;
  let {tabs}=this.data
  tabs.forEach((value,i)=&gt;i==index?value.isactive=true:value.isactive=false)
  this.setData({
      //更新父组件的内容
    tabs
  })
  
},
</code></pre>
<br>
## 用到的周期函数
<pre><code class="language-js">//只用加载该页面才调用  
  onLoad: function (options) {
      console.log(options);
      this.qureyparams.cid=options.cid
      console.log(this.qureyparams);
      this.getgoodslist()
  },

       //每次回到该页面就会调用
     onShow(){
         ...
     },
      
//页面滚动条触底事件 要判断是否有下一页数据 总页数 页码   页码*获取条数&gt;=总数据 没有下一页
  onReachBottom()
  {
      //判断是否还有下一页
      if(this.qureyparams.pagenum&gt;=this.totalpagesize)
      {
        //给个提示
        wx.showToast({
          title:'',
          icon:'none',
          duration:1500,
         
        })
      }
      else{
     
         this.qureyparams.pagenum++
        console.log(this.qureyparams.pagenum);
        this.getgoodslist()
      }
  },
	
//下拉刷新触发函数 
  onPullDownRefresh(){
      //1 重置数组
      this.setData({
        goodslist:[]
      })
      //重置页数
      this.qureyparams.pagenum=1
      //重新发请求
      this.getgoodslist()
      //在方法里面手动关闭下拉刷新等待效果
      //（ wx.stopPullDownRefresh()）
  },
      
      
</code></pre>
<p>对于下拉刷新可以在需要的文件下加<code>&quot;enablePullDownRefresh&quot;: true</code></p>
<p>也可以在app.json全局加刷新效果 包括下拉刷新的样式也是可以添加的</p>
<pre><code class="language-js">  &quot;window&quot;:{
    &quot;backgroundTextStyle&quot;:&quot;light&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#eb4450&quot;,
    &quot;navigationBarTitleText&quot;: &quot;fanfan&quot;,
    &quot;navigationBarTextStyle&quot;:&quot;white&quot;,

    &quot;backgroundColor&quot;: &quot;#0094ff&quot;

  },
</code></pre>
<br>
<h2 id="对于下拉加载新数据的方法">对于下拉加载新数据的方法</h2>
<p>先对原先数据进行解构后，把新数据加进去，而不是刷新数组</p>
<pre><code class="language-js"> this.setData({
      goodslist:[...this.data.goodslist,...res.data.message.goods]
    })
</code></pre>
<br>
<br>
<h2 id="小程序对于用户权限调用以及获取">小程序对于用户权限调用以及获取</h2>
<pre><code class="language-js">//权限给与设置  ***
  //调用小程序内置api 获取用户的收货地址 追踪授权状态 SCOPE
  //增加收货地址
  handleaddress() {

    //打印授权的状态
    wx.getSetting({
      success: (res) =&gt; { 
        console.log(res);
        //判断用户是否给权限
        const scopeaddress = res.authSetting[&quot;scope.address&quot;]
        //用户同意权限 直接调用
        if (scopeaddress || scopeaddress == undefined) {
          wx.chooseAddress({
            success: (result) =&gt; {
              //存地址到缓存
              wx.setStorageSync('address', result);
              console.log(result);
            },
          });
        }
        //如果没给 调用接口让用户同意  打开授权页面
        else {
          wx.openSetting({
            success: (result) =&gt; {
              console.log(result);
              //调用用户同意权限接口
              wx.chooseAddress({
                success: (res) =&gt; {
                  wx.setStorageSync('address', res);
                  console.log(res);

                },

              });
            },

          });
        }
      },
    });
  },

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[socket.io实现实时聊天室]]></title>
        <id>https://fanfankill.github.io/post/socketio-shi-xian-shi-shi-liao-tian-shi/</id>
        <link href="https://fanfankill.github.io/post/socketio-shi-xian-shi-shi-liao-tian-shi/">
        </link>
        <updated>2021-06-15T17:55:30.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Node.js</strong>部分（服务端）</p>
<pre><code class="language-js">  var express=require('express')
var app=express()
var server=require('http').createServer(app)
var io=require('socket.io')(server)

app.use(express.static(__dirname+'/public'))

//设置允许跨域
app.all('*', function (req, res, next) {
      res.header(&quot;Access-Control-Allow-Credentials&quot;, true)
      res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)
      res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;)
      res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;)
      res.header(&quot;X-Powered-By&quot;, ' 3.2.1')
      res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;)
      next()
})

//放用户
const users=[]

io.on('connection',function(socket){
    console.log(&quot;新用户加入房间&quot;);

    //监听Login事件
    socket.on('login',(data)=&gt;{
            console.log(data);
        //放数据,顺便增加唯一id
        users.push({...data,id:socket.id})

        console.log('id是'+socket.id);
        //所有人广播
        io.emit('loginback',{...data,id:socket.id})
    })

    socket.on('client',data2=&gt;{
        console.log(data2.value);
        data2.users=users.find(u=&gt;u.id==socket.id)
        console.log(data2.users);
        socket.broadcast.emit('sendmes',data2)
    })
    
})

server.listen(3000,()=&gt;{
    console.log('http://127.0.0.1:3000');
})

</code></pre>
<h2 id="前端部分">前端部分</h2>
<pre><code class="language-js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;Socket聊天室&lt;/title&gt;
  &lt;style type=&quot;text/css&quot;&gt;
    /**输入框样式*/
    .text * {
      margin: 0;
      padding: 0;
    }

    #main {
      text-align: center;
    }

    #showmes {
      position: relative;
      background: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fcdn.duitang.com%2Fuploads%2Fitem%2F201209%2F08%2F20120908134318_YVAwx.jpeg&amp;refer=http%3A%2F%2Fcdn.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1626261869&amp;t=964bbb79e059f74901698cdd5f6de691) no-repeat;
      background-size: 100% 110%;
      margin: auto;
      width: 600px;
      height: 600px;
      overflow: hidden;
      overflow-y: scroll;
    }

    /**别人气泡*/
    .leftspan2 {
      float: left;
      color: grey;
      font-weight: 1000;
      position: absolute;
      top: -18px;
      font-size: 3px;
      left: 25px;
    }

    .leftspan {
      color: white;
      background-color: #635f5fec;
      padding: 5px 8px;
      font-size: 14px;
      float: left;
      position: relative;
      border-radius: 4px;
      margin-left: 25px;
      margin-right: 5px;

    }

    .leftspan::after {
      content: '';
      border: 8px solid #ffffff00;
      border-right: 8px solid #635f5fec;
      ;
      position: absolute;
      top: 6px;
      left: -16px;
    }

    /*自己气泡**/
    .pp {
      width: 100%;
      position: relative;
      min-height: 20px;
      float: right;
      margin-bottom: 15px;
    }

    .rightspan2 {
      float: right;
      color: grey;
      font-weight: 1000;
      position: absolute;
      top: -18px;
      font-size: 3px;
      right: 15px;
    }

    .rightspan {
      float: right;
      position: relative;
      color: rgb(2, 2, 2);
      font-weight: 500;
      background-color: #88e99d;
      padding: 5px 8px;
      font-size: 14px;
      border-radius: 4px;
      margin-left: 5px;
      margin-right: 15px;

    }

    .rightspan::after {
      content: '';
      border: 8px solid #ffffff00;
      border-left: 8px solid #88e99d;
      ;
      position: absolute;
      top: 6px;
      right: -13px;

    }

    /**输入框*/
    #text {
      width: 500px;
      height: 25px;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;

  &lt;div id=&quot;joinname&quot;&gt;
    &lt;span&gt;请输入加入的姓名&lt;/span&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;&lt;button onclick=&quot;joinchat()&quot;&gt;提交&lt;/button&gt;
  &lt;/div&gt;
  &lt;div id=&quot;main&quot; style=&quot;display: none;&quot;&gt;
    
    &lt;h1&gt;fanfan的聊天室&lt;/h1&gt;
    &lt;div id=&quot;showmes&quot;&gt;

    &lt;/div&gt;
    &lt;div class=&quot;inputtxt&quot;&gt;
      &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt;&lt;/input&gt;
      &lt;button id=&quot;btn&quot; onclick=&quot;sendmes()&quot;&gt;发送&lt;/button&gt;
    &lt;/div&gt;

  &lt;/div&gt;

  &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    //全局变量
    name = ''
    var socket = io(); //连接聊天室的io服务器 io服务器的根地址
    //连接进聊天室
    function firstjoin() {

      socket.on('hello', data =&gt; {
        console.log('服务端发送的东西为：' + data);
      })
    }

    function notnull() {
      if (document.getElementById('text').value != '') {
        return 1;
      }
      else {
        return 0;
      }
    }
    //自己发信息
    function sendmes() {
      if (notnull()) {
        var mes = document.getElementById('text').value
        var p = document.createElement('p');
        var span = document.createElement('span')
        var span2 = document.createElement('span')
        span.innerHTML = mes;
        span2.innerHTML = name;
        span2.className = 'rightspan2'
        span.className = 'rightspan'
        p.className = 'pp'
        p.appendChild(span2)
        p.appendChild(span)
        document.getElementById('showmes').appendChild(p)
        socket.emit('client', {'value':document.getElementById('text').value,'name':name})
        document.getElementById('text').value = ''

        document.getElementById(&quot;showmes&quot;).scrollTop += document.getElementById(&quot;showmes&quot;).offsetHeight;
      }

    }
    //收到别人发的信息
    socket.on('sendmes', data =&gt; {
      console.log(data);
      var p = document.createElement('p');
      var span = document.createElement('span');
      var span2 = document.createElement('span');
      span.className = 'leftspan'
      console.log('姓名是'+data.users.name);
      span2.innerHTML = data.users.name
      span2.className = 'leftspan2'
      span.innerHTML = data.value;
      p.appendChild(span2)
      p.appendChild(span)
      p.className = 'pp'

      document.getElementById('showmes').appendChild(p)

      document.getElementById(&quot;showmes&quot;).scrollTop += document.getElementById(&quot;showmes&quot;).offsetHeight;
    })

    //加入聊天室提醒
    function joinchat() {
      if (document.getElementById('name').value.length &gt;= 1 &amp;&amp; document.getElementById('name').value.length &lt;= 6) {
        //加入盒子隐藏 聊天盒子显示
        document.getElementById('main').style.display='block'
        document.getElementById('joinname').style.display='none'
        name=document.getElementById('name').value
        socket.emit('login', { 'name': document.getElementById('name').value })
      }

    }
    socket.on('loginback', data =&gt; {
      var p = document.createElement('p');
      p.innerHTML = data.name + '加入了房间';
      p.style.color = 'grey'
      p.style.fontWeight = '1000'
      p.style.textAlign = 'center'
      p.style.fontSize = '6px'
      document.getElementById('showmes').appendChild(p)
    })
    //回车发送消息
    document.onkeydown = function (e) {
      console.log('1');
      var ev = document.all ? window.event : e;
      if (ev.keyCode == 13) {
        sendmes();
      }
    }
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;

</code></pre>
<br>
<br>
<br>
每次进入页面先输入自己的姓名才能进入聊天室
每个客户端对应自己独特的socket id来获取发送消息的名称
给回车绑定事件，每次回车发送 可以实现多人在线实时聊天，且有自己对应的名称 自己发送的消息和收到的消息进行区分
<figure data-type="image" tabindex="1"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015910759.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015915621.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015921537.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015925385.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015929804.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/image-20210616015931812.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="file://C:/Users/16239/AppData/Roaming/Typora/typora-user-images/mage-20210616015934765.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事件循环]]></title>
        <id>https://fanfankill.github.io/post/shi-jian-xun-huan/</id>
        <link href="https://fanfankill.github.io/post/shi-jian-xun-huan/">
        </link>
        <updated>2021-06-09T16:10:14.000Z</updated>
        <content type="html"><![CDATA[<p>JS为单线程<br>
宏任务主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)</p>
<p>微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)<br>
<img src="https://fanfankill.github.io/post-images/1623256115003.webp" alt="" loading="lazy"></p>
<p>例子1</p>
<pre><code class="language-js">console.log('script start');

setTimeout(function() {
  console.log('timeout1');
}, 10);

new Promise(resolve =&gt; {
    console.log('promise1');
    resolve();
    setTimeout(() =&gt; console.log('timeout2'), 10);
}).then(function() {
    console.log('then1')
})

console.log('script end');
</code></pre>
<p><img src="https://fanfankill.github.io/post-images/1623255042505.png" alt="" loading="lazy"><br>
先执行第一个log</p>
<p>setTimeout推入宏队列hong1</p>
<p>遇到promise马上执行打印然后将它所有的then推入微队列后把setTimeout推入宏队列hong2</p>
<p>先执行微队列，所以先打印then里面的。然后宏队列再打印<br>
<br><br>
<br><br>
<br><br>
例子2</p>
<pre><code class="language-js">  console.log('1');

setTimeout(function() {
    console.log('2');
  
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})

new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
   
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})
</code></pre>
<p><img src="https://fanfankill.github.io/post-images/1623255137440.png" alt="" loading="lazy"><br>
当在只剩两个宏任务的setTimeout时候执行第一个时，Promise压入了then的微任务，让第二个宏任务又排到微任务后等待</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS 节流和防抖 判断数组]]></title>
        <id>https://fanfankill.github.io/post/js-zhi-shi-dian/</id>
        <link href="https://fanfankill.github.io/post/js-zhi-shi-dian/">
        </link>
        <updated>2021-06-05T12:44:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="节流和防抖">节流和防抖</h2>
<p><strong>防抖</strong></p>
<pre><code class="language-js"> //防抖 在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms  用于停止动作后才开始触发的
    function debounce(fn,delay){
        let timer=null;
        return function(){
            if(timer){
                clearTimeout(timer)//存在即重新计时
                
            }
              timer=setTimeout(fn,delay)
            
        }
    }
</code></pre>
<p><strong>节流</strong></p>
<pre><code class="language-js">//节流 适合一直不给机会触发防抖的
    function throttle(fn,delay){
       
    let valid = true
    return function() {
        
        //闭包函数内的vaild为同一个
       if(!valid){
           
           return false 
       }
       
        valid = false//防止多次触发
        
        setTimeout(() =&gt; {
            fn()
            valid = true;
        }, delay)
    }
}
</code></pre>
<br>
<br>
<br>
<h2 id="判断是不是数组">判断是不是数组</h2>
<pre><code class="language-js">var a=new Array()
var b=new Object()

console.log(Array instanceof Object); //true   js数组可以看作对象

console.log(Array.isArray(a)); //true   数组方法

//误区
typeof(a) //object  typeof运算符用于判断对象的类型，但是对于一些创建的对象，它们都会返回'object'  返回的类型 undefined' 'boolean' 'string' 'number' 'object'  'function'

Object.prototype.toString.call(a) //Object Array 用来判断类型

Object.prototype.toString.call(b) //object Object

//Array 和 Function都是Object的实例 都重写了toString()方法 所以直接调用的话是重写后的方法 调用原型上的方法返回类型

//对toString()方法重写的证明
console.log(Array.prototype.hasOwnProperty(&quot;toString&quot;));//true

delete Array.prototype.toString;//delete操作符可以删除实例属性

console.log(arr.toString());//&quot;[object Array]&quot;


//  prototype 和__proto__    一般来说 __proto__==constructor.prototype


</code></pre>
]]></content>
    </entry>
</feed>